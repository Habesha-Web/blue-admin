
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>bluerpc: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">blue-admin.com/bluerpc/bluerpc.go (0.0%)</option>
				
				<option value="file1">blue-admin.com/bluerpc/bluerpc.pb.go (0.0%)</option>
				
				<option value="file2">blue-admin.com/bluerpc/bluerpc_grpc.pb.go (0.0%)</option>
				
				<option value="file3">blue-admin.com/bluetasks/logfile.go (0.0%)</option>
				
				<option value="file4">blue-admin.com/bluetasks/tasks..go (0.0%)</option>
				
				<option value="file5">blue-admin.com/common/common.go (75.4%)</option>
				
				<option value="file6">blue-admin.com/configs/configs.go (17.9%)</option>
				
				<option value="file7">blue-admin.com/controllers/app_controller.go (51.1%)</option>
				
				<option value="file8">blue-admin.com/controllers/dashboard.go (0.0%)</option>
				
				<option value="file9">blue-admin.com/controllers/email.go (0.0%)</option>
				
				<option value="file10">blue-admin.com/controllers/endpoint_controller.go (80.0%)</option>
				
				<option value="file11">blue-admin.com/controllers/feature_controller.go (48.6%)</option>
				
				<option value="file12">blue-admin.com/controllers/jwtsalt_controller.go (0.0%)</option>
				
				<option value="file13">blue-admin.com/controllers/login.go (86.7%)</option>
				
				<option value="file14">blue-admin.com/controllers/page_controller.go (56.2%)</option>
				
				<option value="file15">blue-admin.com/controllers/role_controller.go (35.4%)</option>
				
				<option value="file16">blue-admin.com/controllers/user_controller.go (37.3%)</option>
				
				<option value="file17">blue-admin.com/database/database.go (45.0%)</option>
				
				<option value="file18">blue-admin.com/docs/docs.go (100.0%)</option>
				
				<option value="file19">blue-admin.com/main.go (0.0%)</option>
				
				<option value="file20">blue-admin.com/manager/consumer.go (25.0%)</option>
				
				<option value="file21">blue-admin.com/manager/devfiber.go (59.2%)</option>
				
				<option value="file22">blue-admin.com/manager/manager.go (0.0%)</option>
				
				<option value="file23">blue-admin.com/manager/migrate.go (25.0%)</option>
				
				<option value="file24">blue-admin.com/messages/connection.go (0.0%)</option>
				
				<option value="file25">blue-admin.com/messages/consumer.go (0.0%)</option>
				
				<option value="file26">blue-admin.com/messages/publishers.go (0.0%)</option>
				
				<option value="file27">blue-admin.com/models/app.go (100.0%)</option>
				
				<option value="file28">blue-admin.com/models/helper.go (44.4%)</option>
				
				<option value="file29">blue-admin.com/models/init.go (78.9%)</option>
				
				<option value="file30">blue-admin.com/models/user.go (100.0%)</option>
				
				<option value="file31">blue-admin.com/observe/tracer.go (22.2%)</option>
				
				<option value="file32">blue-admin.com/tests/test_app.go (100.0%)</option>
				
				<option value="file33">blue-admin.com/utils/dynamic_salt.go (81.2%)</option>
				
				<option value="file34">blue-admin.com/utils/sendemail.go (0.0%)</option>
				
				<option value="file35">blue-admin.com/utils/utils.go (91.8%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package bluerpc

import (
        "fmt"

        "blue-admin.com/utils"
        "golang.org/x/net/context"
)

type BlueRPCServer struct {
        BlueServiceServer
}

func (server *BlueRPCServer) GetSalt(ctx context.Context, message *BlueAppID) (*BlueSalt, error) <span class="cov0" title="0">{
        fmt.Printf("The APP ID: %v\n", message.AppId)
        salt_a, salt_b := utils.GetJWTSalt()
        return &amp;BlueSalt{SaltA: salt_a, SaltB: salt_b}, nil
}</span>
</pre>
		
		<pre class="file" id="file1" style="display: none">// Code generated by protoc-gen-go. DO NOT EDIT.
// versions:
//         protoc-gen-go v1.32.0
//         protoc        v3.21.12
// source: bluerpc/bluerpc.proto

package bluerpc

import (
        protoreflect "google.golang.org/protobuf/reflect/protoreflect"
        protoimpl "google.golang.org/protobuf/runtime/protoimpl"
        reflect "reflect"
        sync "sync"
)

const (
        // Verify that this generated code is sufficiently up-to-date.
        _ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
        // Verify that runtime/protoimpl is sufficiently up-to-date.
        _ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
)

type BlueSalt struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        SaltA string `protobuf:"bytes,1,opt,name=salt_a,json=saltA,proto3" json:"salt_a,omitempty"`
        SaltB string `protobuf:"bytes,2,opt,name=salt_b,json=saltB,proto3" json:"salt_b,omitempty"`
}

func (x *BlueSalt) Reset() <span class="cov0" title="0">{
        *x = BlueSalt{}
        if protoimpl.UnsafeEnabled </span><span class="cov0" title="0">{
                mi := &amp;file_bluerpc_bluerpc_proto_msgTypes[0]
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                ms.StoreMessageInfo(mi)
        }</span>
}

func (x *BlueSalt) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*BlueSalt) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *BlueSalt) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_bluerpc_bluerpc_proto_msgTypes[0]
        if protoimpl.UnsafeEnabled &amp;&amp; x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use BlueSalt.ProtoReflect.Descriptor instead.
func (*BlueSalt) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_bluerpc_bluerpc_proto_rawDescGZIP(), []int{0}
}</span>

func (x *BlueSalt) GetSaltA() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.SaltA
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *BlueSalt) GetSaltB() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.SaltB
        }</span>
        <span class="cov0" title="0">return ""</span>
}

type BlueAppID struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        AppId string `protobuf:"bytes,1,opt,name=app_id,json=appId,proto3" json:"app_id,omitempty"`
}

func (x *BlueAppID) Reset() <span class="cov0" title="0">{
        *x = BlueAppID{}
        if protoimpl.UnsafeEnabled </span><span class="cov0" title="0">{
                mi := &amp;file_bluerpc_bluerpc_proto_msgTypes[1]
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                ms.StoreMessageInfo(mi)
        }</span>
}

func (x *BlueAppID) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*BlueAppID) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *BlueAppID) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_bluerpc_bluerpc_proto_msgTypes[1]
        if protoimpl.UnsafeEnabled &amp;&amp; x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use BlueAppID.ProtoReflect.Descriptor instead.
func (*BlueAppID) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_bluerpc_bluerpc_proto_rawDescGZIP(), []int{1}
}</span>

func (x *BlueAppID) GetAppId() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.AppId
        }</span>
        <span class="cov0" title="0">return ""</span>
}

var File_bluerpc_bluerpc_proto protoreflect.FileDescriptor

var file_bluerpc_bluerpc_proto_rawDesc = []byte{
        0x0a, 0x15, 0x62, 0x6c, 0x75, 0x65, 0x72, 0x70, 0x63, 0x2f, 0x62, 0x6c, 0x75, 0x65, 0x72, 0x70,
        0x63, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x22, 0x38, 0x0a, 0x08, 0x42, 0x6c, 0x75, 0x65, 0x53,
        0x61, 0x6c, 0x74, 0x12, 0x15, 0x0a, 0x06, 0x73, 0x61, 0x6c, 0x74, 0x5f, 0x61, 0x18, 0x01, 0x20,
        0x01, 0x28, 0x09, 0x52, 0x05, 0x73, 0x61, 0x6c, 0x74, 0x41, 0x12, 0x15, 0x0a, 0x06, 0x73, 0x61,
        0x6c, 0x74, 0x5f, 0x62, 0x18, 0x02, 0x20, 0x01, 0x28, 0x09, 0x52, 0x05, 0x73, 0x61, 0x6c, 0x74,
        0x42, 0x22, 0x22, 0x0a, 0x09, 0x42, 0x6c, 0x75, 0x65, 0x41, 0x70, 0x70, 0x49, 0x44, 0x12, 0x15,
        0x0a, 0x06, 0x61, 0x70, 0x70, 0x5f, 0x69, 0x64, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x05,
        0x61, 0x70, 0x70, 0x49, 0x64, 0x32, 0x31, 0x0a, 0x0b, 0x42, 0x6c, 0x75, 0x65, 0x53, 0x65, 0x72,
        0x76, 0x69, 0x63, 0x65, 0x12, 0x22, 0x0a, 0x07, 0x47, 0x65, 0x74, 0x53, 0x61, 0x6c, 0x74, 0x12,
        0x0a, 0x2e, 0x42, 0x6c, 0x75, 0x65, 0x41, 0x70, 0x70, 0x49, 0x44, 0x1a, 0x09, 0x2e, 0x42, 0x6c,
        0x75, 0x65, 0x53, 0x61, 0x6c, 0x74, 0x22, 0x00, 0x42, 0x0b, 0x5a, 0x09, 0x2e, 0x2f, 0x62, 0x6c,
        0x75, 0x65, 0x72, 0x70, 0x63, 0x62, 0x06, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x33,
}

var (
        file_bluerpc_bluerpc_proto_rawDescOnce sync.Once
        file_bluerpc_bluerpc_proto_rawDescData = file_bluerpc_bluerpc_proto_rawDesc
)

func file_bluerpc_bluerpc_proto_rawDescGZIP() []byte <span class="cov0" title="0">{
        file_bluerpc_bluerpc_proto_rawDescOnce.Do(func() </span><span class="cov0" title="0">{
                file_bluerpc_bluerpc_proto_rawDescData = protoimpl.X.CompressGZIP(file_bluerpc_bluerpc_proto_rawDescData)
        }</span>)
        <span class="cov0" title="0">return file_bluerpc_bluerpc_proto_rawDescData</span>
}

var file_bluerpc_bluerpc_proto_msgTypes = make([]protoimpl.MessageInfo, 2)
var file_bluerpc_bluerpc_proto_goTypes = []interface{}{
        (*BlueSalt)(nil),  // 0: BlueSalt
        (*BlueAppID)(nil), // 1: BlueAppID
}
var file_bluerpc_bluerpc_proto_depIdxs = []int32{
        1, // 0: BlueService.GetSalt:input_type -&gt; BlueAppID
        0, // 1: BlueService.GetSalt:output_type -&gt; BlueSalt
        1, // [1:2] is the sub-list for method output_type
        0, // [0:1] is the sub-list for method input_type
        0, // [0:0] is the sub-list for extension type_name
        0, // [0:0] is the sub-list for extension extendee
        0, // [0:0] is the sub-list for field type_name
}

func init() <span class="cov0" title="0">{ file_bluerpc_bluerpc_proto_init() }</span>
func file_bluerpc_bluerpc_proto_init() <span class="cov0" title="0">{
        if File_bluerpc_bluerpc_proto != nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">if !protoimpl.UnsafeEnabled </span><span class="cov0" title="0">{
                file_bluerpc_bluerpc_proto_msgTypes[0].Exporter = func(v interface{}, i int) interface{} </span><span class="cov0" title="0">{
                        switch v := v.(*BlueSalt); i </span>{
                        case 0:<span class="cov0" title="0">
                                return &amp;v.state</span>
                        case 1:<span class="cov0" title="0">
                                return &amp;v.sizeCache</span>
                        case 2:<span class="cov0" title="0">
                                return &amp;v.unknownFields</span>
                        default:<span class="cov0" title="0">
                                return nil</span>
                        }
                }
                <span class="cov0" title="0">file_bluerpc_bluerpc_proto_msgTypes[1].Exporter = func(v interface{}, i int) interface{} </span><span class="cov0" title="0">{
                        switch v := v.(*BlueAppID); i </span>{
                        case 0:<span class="cov0" title="0">
                                return &amp;v.state</span>
                        case 1:<span class="cov0" title="0">
                                return &amp;v.sizeCache</span>
                        case 2:<span class="cov0" title="0">
                                return &amp;v.unknownFields</span>
                        default:<span class="cov0" title="0">
                                return nil</span>
                        }
                }
        }
        <span class="cov0" title="0">type x struct{}
        out := protoimpl.TypeBuilder{
                File: protoimpl.DescBuilder{
                        GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
                        RawDescriptor: file_bluerpc_bluerpc_proto_rawDesc,
                        NumEnums:      0,
                        NumMessages:   2,
                        NumExtensions: 0,
                        NumServices:   1,
                },
                GoTypes:           file_bluerpc_bluerpc_proto_goTypes,
                DependencyIndexes: file_bluerpc_bluerpc_proto_depIdxs,
                MessageInfos:      file_bluerpc_bluerpc_proto_msgTypes,
        }.Build()
        File_bluerpc_bluerpc_proto = out.File
        file_bluerpc_bluerpc_proto_rawDesc = nil
        file_bluerpc_bluerpc_proto_goTypes = nil
        file_bluerpc_bluerpc_proto_depIdxs = nil</span>
}
</pre>
		
		<pre class="file" id="file2" style="display: none">// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.3.0
// - protoc             v3.21.12
// source: bluerpc/bluerpc.proto

package bluerpc

import (
        context "context"
        grpc "google.golang.org/grpc"
        codes "google.golang.org/grpc/codes"
        status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.32.0 or later.
const _ = grpc.SupportPackageIsVersion7

const (
        BlueService_GetSalt_FullMethodName = "/BlueService/GetSalt"
)

// BlueServiceClient is the client API for BlueService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type BlueServiceClient interface {
        GetSalt(ctx context.Context, in *BlueAppID, opts ...grpc.CallOption) (*BlueSalt, error)
}

type blueServiceClient struct {
        cc grpc.ClientConnInterface
}

func NewBlueServiceClient(cc grpc.ClientConnInterface) BlueServiceClient <span class="cov0" title="0">{
        return &amp;blueServiceClient{cc}
}</span>

func (c *blueServiceClient) GetSalt(ctx context.Context, in *BlueAppID, opts ...grpc.CallOption) (*BlueSalt, error) <span class="cov0" title="0">{
        out := new(BlueSalt)
        err := c.cc.Invoke(ctx, BlueService_GetSalt_FullMethodName, in, out, opts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

// BlueServiceServer is the server API for BlueService service.
// All implementations must embed UnimplementedBlueServiceServer
// for forward compatibility
type BlueServiceServer interface {
        GetSalt(context.Context, *BlueAppID) (*BlueSalt, error)
        mustEmbedUnimplementedBlueServiceServer()
}

// UnimplementedBlueServiceServer must be embedded to have forward compatible implementations.
type UnimplementedBlueServiceServer struct {
}

func (UnimplementedBlueServiceServer) GetSalt(context.Context, *BlueAppID) (*BlueSalt, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method GetSalt not implemented")
}</span>
func (UnimplementedBlueServiceServer) mustEmbedUnimplementedBlueServiceServer() {<span class="cov0" title="0">}</span>

// UnsafeBlueServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to BlueServiceServer will
// result in compilation errors.
type UnsafeBlueServiceServer interface {
        mustEmbedUnimplementedBlueServiceServer()
}

func RegisterBlueServiceServer(s grpc.ServiceRegistrar, srv BlueServiceServer) <span class="cov0" title="0">{
        s.RegisterService(&amp;BlueService_ServiceDesc, srv)
}</span>

func _BlueService_GetSalt_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov0" title="0">{
        in := new(BlueAppID)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(BlueServiceServer).GetSalt(ctx, in)
        }</span>
        <span class="cov0" title="0">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: BlueService_GetSalt_FullMethodName,
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return srv.(BlueServiceServer).GetSalt(ctx, req.(*BlueAppID))
        }</span>
        <span class="cov0" title="0">return interceptor(ctx, in, info, handler)</span>
}

// BlueService_ServiceDesc is the grpc.ServiceDesc for BlueService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var BlueService_ServiceDesc = grpc.ServiceDesc{
        ServiceName: "BlueService",
        HandlerType: (*BlueServiceServer)(nil),
        Methods: []grpc.MethodDesc{
                {
                        MethodName: "GetSalt",
                        Handler:    _BlueService_GetSalt_Handler,
                },
        },
        Streams:  []grpc.StreamDesc{},
        Metadata: "bluerpc/bluerpc.proto",
}
</pre>
		
		<pre class="file" id="file3" style="display: none">package bluetasks

import (
        "log"
        "os"
)

func Logfile() (*os.File, error) <span class="cov0" title="0">{

        // Custom File Writer for logging
        file, err := os.OpenFile("blue-admin.log", os.O_RDWR|os.O_CREATE|os.O_APPEND, 0666)
        if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("error opening file: %v", err)
                return nil, err
        }</span>
        <span class="cov0" title="0">return file, nil</span>

}
</pre>
		
		<pre class="file" id="file4" style="display: none">package bluetasks

import (
        "fmt"
        "os/exec"
        "strconv"
        "time"

        "blue-admin.com/configs"
        "blue-admin.com/database"
        "blue-admin.com/utils"

        "github.com/madflojo/tasks"
)

func ScheduledTasks() *tasks.Scheduler <span class="cov0" title="0">{

        //  initalizing scheduler for regullarly running tasks
        scheduler := tasks.New()

        // JWT signature salt will be updated based on the env variable provided
        // this is what the peice of code below does, using golangs task scheduler
        //  Salt Timer Tasks
        clear_run, _ := strconv.Atoi(configs.AppConfig.Get("JWT_SALT_LIFE_TIME"))
        clear_run = int(clear_run)
        jwt_update_interval := time.Minute * time.Duration(clear_run)
        //  Task 2 for testing Make random heartbeat call
        if _, err := scheduler.Add(&amp;tasks.Task{
                Interval: jwt_update_interval,
                TaskFunc: func() error </span><span class="cov0" title="0">{
                        utils.JWTSaltUpdate()
                        return nil
                }</span>,
        }); err != nil <span class="cov0" title="0">{
                fmt.Println(err)
        }</span>

        // // Add a task to move to Logs Directory Every Interval, Interval to Be Provided From Configuration File
        <span class="cov0" title="0">gormLoggerfile, _ := database.GormLoggerFile()
        //  App should not start
        log_file, _ := Logfile()
        if _, err := scheduler.Add(&amp;tasks.Task{
                Interval: time.Duration(1 * time.Hour),
                TaskFunc: func() error </span><span class="cov0" title="0">{
                        currentTime := time.Now()
                        FileName := fmt.Sprintf("%v-%v-%v-%v-%v", currentTime.Year(), currentTime.Month(), currentTime.Day(), currentTime.Hour(), currentTime.Minute())
                        Command := fmt.Sprintf("cp goblue.log logs/blue-%v.log", FileName)
                        Command2 := fmt.Sprintf("cp blue-admin.log logs/gorm-%v.log", FileName)
                        if _, err := exec.Command("bash", "-c", Command).Output(); err != nil </span><span class="cov0" title="0">{
                                fmt.Printf("error: %v\n", err)
                        }</span>

                        <span class="cov0" title="0">if _, err := exec.Command("bash", "-c", Command2).Output(); err != nil </span><span class="cov0" title="0">{
                                fmt.Printf("error: %v\n", err)
                        }</span>
                        <span class="cov0" title="0">gormLoggerfile.Truncate(0)
                        log_file.Truncate(0)
                        return nil</span>
                },
        }); err != nil <span class="cov0" title="0">{
                fmt.Println(err)

        }</span>

        <span class="cov0" title="0">return scheduler</span>
}
</pre>
		
		<pre class="file" id="file5" style="display: none">
package common

import (
        "math"
        "context"

        "gorm.io/gorm"
        "gorm.io/gorm/clause"
)

type ResponseHTTP struct {
        Success bool        `json:"success"`
        Data    interface{} `json:"data"`
        Message string      `json:"details"`
}

type ResponsePagination struct {
        Success bool        `json:"success"`
        Items   interface{} `json:"data"`
        Message string      `json:"details"`
        Total   uint        `json:"total"`
        Page    uint        `json:"page"`
        Size    uint        `json:"size"`
        Pages   uint        `json:"pages"`
}

func Pagination(db *gorm.DB, queryModel interface{}, responseObjectModel interface{}, page uint, size uint, tracer context.Context) (ResponsePagination, error) <span class="cov8" title="1">{
        //  protection against requesting large amount of data
        //  set to 50
        var update_size uint
        if size &gt; 50 </span><span class="cov0" title="0">{
                size = 50
        }</span>

        <span class="cov8" title="1">count_channel := make(chan int64)
        str_chann := make(chan string)
        var offset int64 = int64(page-1) * int64(update_size)
        //finding count value
        go func() </span><span class="cov8" title="1">{
                var local_counter int64
                if tracer != nil </span><span class="cov8" title="1">{
                        db.WithContext(tracer).Select("*").Model(&amp;queryModel).Count(&amp;local_counter)
                }</span> else<span class="cov0" title="0"> {
                        db.Select("*").Model(&amp;queryModel).Count(&amp;local_counter)
                }</span>
                <span class="cov8" title="1">count_channel &lt;- local_counter</span>

        }()
        //  set offset value for page One
        <span class="cov8" title="1">var response_page int64
        go func() </span><span class="cov8" title="1">{
                if page == 1 </span><span class="cov8" title="1">{
                        if tracer != nil </span><span class="cov8" title="1">{
                                db.WithContext(tracer).Order("id asc").Limit(int(size)).Offset(0).Preload(clause.Associations).Find(&amp;responseObjectModel)

                        }</span> else<span class="cov0" title="0"> {
                                db.Order("id asc").Limit(int(size)).Offset(0).Preload(clause.Associations).Find(&amp;responseObjectModel)

                        }</span>

                        <span class="cov8" title="1">response_page = 1</span>
                } else<span class="cov0" title="0"> {
                        if tracer != nil </span><span class="cov0" title="0">{
                                db.WithContext(tracer).Order("id asc").Limit(int(size)).Offset(int(offset)).Preload(clause.Associations).Find(&amp;responseObjectModel)

                        }</span> else<span class="cov0" title="0"> {
                                db.Order("id asc").Limit(int(size)).Offset(int(offset)).Preload(clause.Associations).Find(&amp;responseObjectModel)
                        }</span>
                        // response_channel &lt;- loc_resp
                        <span class="cov0" title="0">response_page = int64(page)</span>
                }
                <span class="cov8" title="1">str_chann &lt;- "completed"</span>
        }()
        <span class="cov8" title="1">count := &lt;-count_channel
        response_obj := &lt;-str_chann
        pages := math.Ceil(float64(count) / float64(size))

        result := ResponsePagination{
                Success: true,
                Items:   responseObjectModel,
                Message: response_obj,
                Total:   uint(count),
                Page:    uint(response_page),
                Size:    uint(size),
                Pages:   uint(pages),
        }
        return result, nil</span>
}

func PaginationPureModel(db *gorm.DB, queryModel interface{}, responseObjectModel interface{}, page uint, size uint, tracer context.Context) (ResponsePagination, error) <span class="cov8" title="1">{
        if size &gt; 50 </span><span class="cov0" title="0">{
                size = 50
        }</span>
        <span class="cov8" title="1">count_channel := make(chan int64)
        str_chann := make(chan string)
        var offset int64 = int64(page-1) * int64(size)
        //finding count value
        go func() </span><span class="cov8" title="1">{
                var local_counter int64
                if tracer != nil </span><span class="cov8" title="1">{
                        db.WithContext(tracer).Select("*").Model(&amp;queryModel).Count(&amp;local_counter)
                }</span> else<span class="cov0" title="0"> {
                        db.Select("*").Model(&amp;queryModel).Count(&amp;local_counter)
                }</span>
                <span class="cov8" title="1">count_channel &lt;- local_counter</span>

        }()
        //  set offset value for page One
        <span class="cov8" title="1">var response_page int64
        go func() </span><span class="cov8" title="1">{
                if page == 1 </span><span class="cov8" title="1">{
                        if tracer != nil </span><span class="cov8" title="1">{
                                db.WithContext(tracer).Model(&amp;queryModel).Order("id asc").Limit(int(size)).Offset(0).Find(&amp;responseObjectModel)
                        }</span> else<span class="cov0" title="0"> {
                                db.Model(&amp;queryModel).Order("id asc").Limit(int(size)).Offset(0).Find(&amp;responseObjectModel)
                        }</span>
                        <span class="cov8" title="1">response_page = 1</span>
                } else<span class="cov0" title="0"> {
                        if tracer != nil </span><span class="cov0" title="0">{
                                db.WithContext(tracer).Model(&amp;queryModel).Order("id asc").Limit(int(size)).Offset(int(offset)).Find(&amp;responseObjectModel)
                        }</span> else<span class="cov0" title="0"> {
                                db.Model(&amp;queryModel).Order("id asc").Limit(int(size)).Offset(int(offset)).Find(&amp;responseObjectModel)
                        }</span>
                        // response_channel &lt;- loc_resp
                        <span class="cov0" title="0">response_page = int64(page)</span>
                }
                <span class="cov8" title="1">str_chann &lt;- "completed"</span>
        }()

        <span class="cov8" title="1">count := &lt;-count_channel
        response_obj := &lt;-str_chann
        pages := math.Ceil(float64(count) / float64(size))
        result := ResponsePagination{
                Success: true,
                Items:   responseObjectModel,
                Message: response_obj,
                Total:   uint(count),
                Page:    uint(response_page),
                Size:    uint(size),
                Pages:   uint(pages),
        }
        return result, nil</span>
}

</pre>
		
		<pre class="file" id="file6" style="display: none">package configs

import (
        "fmt"
        "os"

        "github.com/joho/godotenv"
)

const (
        defaultFileName         = "/.env"
        defaultOverrideFileName = "/.local.env"
)

type EnvConfig struct {
        defaultPath string
        prodFlag    string
}

type RenderConfig struct{}

type Config interface {
        Get(string) string
        GetOrDefault(string, string) string
}

// var AppConfig EnvConfig
var AppConfig RenderConfig

func NewEnvFile(configFolder string) <span class="cov8" title="1">{
        AppConfig = RenderConfig{}
        AppConfig.SetEnv("some")
}</span>

// func NewEnvFile(configFolder string) {
//         AppConfig = EnvConfig{
//                 defaultPath: configFolder,
//         }
//         AppConfig.read()
// }

func (e *EnvConfig) read() <span class="cov0" title="0">{
        var (
                defaultFile  = e.defaultPath + defaultFileName
                overrideFile = e.defaultPath + defaultOverrideFileName
        )
        err := godotenv.Overload(defaultFile)
        env := e.Get("APP_ENV")
        if err != nil </span><span class="cov0" title="0">{
                fmt.Printf("WARNING: Failed to load config from file: %v, Err: %v \n", defaultFile, err)
        }</span> else<span class="cov0" title="0"> {
                fmt.Printf("INFO: Loaded config from file: %v\n", defaultFile)
        }</span>

        // If 'APP_ENV' is set to x, then App will read '.env' from configs directory, and then it will be overwritten
        // by configs present in file '.x.env'
        <span class="cov0" title="0">overrideFile = fmt.Sprintf("%s/.%s.env", e.defaultPath, env)
        if env == "" &amp;&amp; e.prodFlag == "" </span><span class="cov0" title="0">{
                overrideFile = fmt.Sprintf("%s/dev.env", e.defaultPath)
        }</span>

        <span class="cov0" title="0">if e.prodFlag != "" </span><span class="cov0" title="0">{
                overrideFile = fmt.Sprintf("%s/.%s.env", e.defaultPath, e.prodFlag)
        }</span>
        <span class="cov0" title="0">err = godotenv.Overload(overrideFile)
        if err != nil </span><span class="cov0" title="0">{
                fmt.Printf("WARNING: to load config from file: %v, Err: %v \n", overrideFile, err)
        }</span> else<span class="cov0" title="0"> {
                fmt.Printf("INFO: config from file: %v \n", overrideFile)
        }</span>
}

func (e *EnvConfig) Get(key string) string <span class="cov0" title="0">{
        return os.Getenv(key)
}</span>
func (e *RenderConfig) Get(key string) string <span class="cov8" title="1">{
        return os.Getenv(key)
}</span>

//        func (e *EnvConfig) SetEnv(key string) {
//                AppConfig = EnvConfig{
//                        defaultPath: "./configs",
//                        prodFlag:    key,
//                }
//                AppConfig.read()
//        }
func (e *RenderConfig) SetEnv(env string) <span class="cov8" title="1">{
        // fmt.Println(env)
        AppConfig = RenderConfig{}
        if err := godotenv.Load(); err != nil </span><span class="cov0" title="0">{
                fmt.Println(err.Error())
        }</span>

}

func (e *EnvConfig) GetOrDefault(key, defaultValue string) string <span class="cov0" title="0">{
        if val := os.Getenv(key); val != "" </span><span class="cov0" title="0">{
                return val
        }</span>

        <span class="cov0" title="0">return defaultValue</span>
}
func (e *RenderConfig) GetOrDefault(key, defaultValue string) string <span class="cov0" title="0">{
        if val := os.Getenv(key); val != "" </span><span class="cov0" title="0">{
                return val
        }</span>

        <span class="cov0" title="0">return defaultValue</span>
}
</pre>
		
		<pre class="file" id="file7" style="display: none">package controllers

import (
        "net/http"
        "strconv"

        "blue-admin.com/common"
        "blue-admin.com/models"
        "blue-admin.com/observe"
        "github.com/go-playground/validator/v10"
        "github.com/gofiber/fiber/v2"
        "github.com/mitchellh/mapstructure"
        "gorm.io/gorm"
        "gorm.io/gorm/clause"
)

// GetAppis a function to get a Apps by ID
// @Summary Get Apps
// @Description Get Apps
// @Tags Apps
// @Accept json
// @Produce json
// @Security ApiKeyAuth
// @Security Refresh
// @Param page query int true "page"
// @Param size query int true "page size"
// @Success 200 {object} common.ResponsePagination{data=[]models.AppGet}
// @Failure 404 {object} common.ResponseHTTP{}
// @Router /app [get]
func GetApps(contx *fiber.Ctx) error <span class="cov8" title="1">{

        //  Getting tracer context
        ctx := contx.Locals("tracer")
        tracer, _ := ctx.(*observe.RouteTracer)

        //  Getting Database connection
        db, _ := contx.Locals("db").(*gorm.DB)

        //  parsing Query Prameters
        Page, _ := strconv.Atoi(contx.Query("page"))
        Limit, _ := strconv.Atoi(contx.Query("size"))
        //  checking if query parameters  are correct
        if Page == 0 || Limit == 0 </span><span class="cov8" title="1">{
                return contx.Status(http.StatusBadRequest).JSON(common.ResponseHTTP{
                        Success: false,
                        Message: "Not Allowed, Bad request",
                        Data:    nil,
                })
        }</span>

        //  querying result with pagination using gorm function
        <span class="cov8" title="1">result, err := common.PaginationPureModel(db, models.App{}, []models.App{}, uint(Page), uint(Limit), tracer.Tracer)
        if err != nil </span><span class="cov0" title="0">{
                return contx.Status(http.StatusInternalServerError).JSON(common.ResponseHTTP{
                        Success: false,
                        Message: "Failed to get all App.",
                        Data:    "something",
                })
        }</span>

        // returning result if all the above completed successfully
        <span class="cov8" title="1">return contx.Status(http.StatusOK).JSON(result)</span>
}

// GetAppByID is a function to get a Apps by ID
// @Summary Get App by ID
// @Description Get app by ID
// @Tags Apps
// @Security ApiKeyAuth
// @Accept json
// @Produce json
// @Param app_id path int true "App ID"
// @Success 200 {object} common.ResponseHTTP{data=models.AppGet}
// @Failure 404 {object} common.ResponseHTTP{}
// @Router /app/{app_id} [get]
func GetAppByID(contx *fiber.Ctx) error <span class="cov8" title="1">{

        // Starting tracer context and tracer
        ctx := contx.Locals("tracer")
        tracer, _ := ctx.(*observe.RouteTracer)

        //  Getting Database connection
        db, _ := contx.Locals("db").(*gorm.DB)

        //  parsing Query Prameters
        id, err := strconv.Atoi(contx.Params("app_id"))
        if err != nil </span><span class="cov0" title="0">{
                return contx.Status(http.StatusBadRequest).JSON(common.ResponseHTTP{
                        Success: false,
                        Message: err.Error(),
                        Data:    nil,
                })
        }</span>

        // Preparing and querying database using Gorm
        <span class="cov8" title="1">var apps_get models.AppGet
        var apps models.App
        if res := db.WithContext(tracer.Tracer).Model(&amp;models.App{}).Preload(clause.Associations).Where("id = ?", id).First(&amp;apps); res.Error != nil </span><span class="cov8" title="1">{
                return contx.Status(http.StatusNotFound).JSON(common.ResponseHTTP{
                        Success: false,
                        Message: res.Error.Error(),
                        Data:    nil,
                })
        }</span>

        // filtering response data according to filtered defined struct
        <span class="cov8" title="1">mapstructure.Decode(apps, &amp;apps_get)

        //  Finally returing response if All the above compeleted successfully
        return contx.Status(http.StatusOK).JSON(common.ResponseHTTP{
                Success: true,
                Message: "Success got one app.",
                Data:    &amp;apps_get,
        })</span>
}

// GetAppRoleUUID is a function to get a Apps by ID
// @Summary Get App Roles by UUID
// @Description Get app roles by UUID
// @Tags Apps
// @Security ApiKeyAuth
// @Accept json
// @Produce json
// @Param app_uuid path string true "App UUID"
// @Success 200 {object} common.ResponseHTTP{data=[]models.RolePut}
// @Failure 404 {object} common.ResponseHTTP{}
// @Router /appruid/{app_uuid} [get]
func GetAppRoleUUID(contx *fiber.Ctx) error <span class="cov0" title="0">{

        // Starting tracer context and tracer
        ctx := contx.Locals("tracer")
        tracer, _ := ctx.(*observe.RouteTracer)

        //  Getting Database connection
        db, _ := contx.Locals("db").(*gorm.DB)

        //  parsing Query Prameters
        uuid := contx.Params("app_uuid")
        if uuid == "" </span><span class="cov0" title="0">{
                return contx.Status(http.StatusBadRequest).JSON(common.ResponseHTTP{
                        Success: false,
                        Message: "No uuid",
                        Data:    nil,
                })
        }</span>

        // Preparing and querying database using Gorm
        <span class="cov0" title="0">var roles []models.RolePut
        // select apps.id as appID, roles.id, roles.name, roles.description,roles.active from roles inner join apps on roles.app_id == apps.id where apps.uuid =="0191c74f-d039-71c6-a3be-66e2571a9cf1" ORDER BY roles.id;
        query_string := `select apps.id as appID, roles.id, roles.name, roles.description,roles.active from roles
                                                inner join apps on roles.app_id == apps.id
                                                where apps.uuid = ? and roles.active = true ORDER BY roles.id;`

        if res := db.WithContext(tracer.Tracer).Raw(query_string, uuid).Scan(&amp;roles); res.Error != nil </span><span class="cov0" title="0">{
                return contx.Status(http.StatusNotFound).JSON(common.ResponseHTTP{
                        Success: false,
                        Message: res.Error.Error(),
                        Data:    nil,
                })
        }</span>

        //  Finally returing response if All the above compeleted successfully
        <span class="cov0" title="0">return contx.Status(http.StatusOK).JSON(common.ResponseHTTP{
                Success: true,
                Message: "Success got one app.",
                Data:    &amp;roles,
        })</span>
}

// Add App to data
// @Summary Add a new App
// @Description Add App
// @Tags Apps
// @Security ApiKeyAuth
// @Accept json
// @Produce json
// @Param app body models.AppPost true "Add App"
// @Success 200 {object} common.ResponseHTTP{data=models.AppPost}
// @Failure 400 {object} common.ResponseHTTP{}
// @Failure 500 {object} common.ResponseHTTP{}
// @Router /app [post]
func PostApp(contx *fiber.Ctx) error <span class="cov8" title="1">{

        // Starting tracer context and tracer
        ctx := contx.Locals("tracer")
        tracer, _ := ctx.(*observe.RouteTracer)

        // Getting Database Connection
        db, _ := contx.Locals("db").(*gorm.DB)

        // validator initialization
        validate := validator.New()

        //validating post data
        posted_app := new(models.AppPost)

        //first parse request data
        if err := contx.BodyParser(&amp;posted_app); err != nil </span><span class="cov0" title="0">{
                return contx.Status(http.StatusBadRequest).JSON(common.ResponseHTTP{
                        Success: false,
                        Message: err.Error(),
                        Data:    nil,
                })
        }</span>

        // then validate structure
        <span class="cov8" title="1">if err := validate.Struct(posted_app); err != nil </span><span class="cov0" title="0">{
                return contx.Status(http.StatusBadRequest).JSON(common.ResponseHTTP{
                        Success: false,
                        Message: err.Error(),
                        Data:    nil,
                })
        }</span>

        //  initiate -&gt; app
        <span class="cov8" title="1">app := new(models.App)
        app.Name = posted_app.Name
        app.Description = posted_app.Description

        //  start transaction to database
        tx := db.WithContext(tracer.Tracer).Begin()

        // add  data using transaction if values are valid
        if err := tx.Create(&amp;app).Error; err != nil </span><span class="cov8" title="1">{
                tx.Rollback()
                return contx.Status(http.StatusInternalServerError).JSON(common.ResponseHTTP{
                        Success: false,
                        Message: "App Creation Failed",
                        Data:    err,
                })
        }</span>

        // close transaction
        <span class="cov8" title="1">tx.Commit()

        // return data if transaction is sucessfull
        return contx.Status(http.StatusOK).JSON(common.ResponseHTTP{
                Success: true,
                Message: "App created successfully.",
                Data:    app,
        })</span>
}

// Patch App to data
// @Summary Patch App
// @Description Patch App
// @Tags Apps
// @Security ApiKeyAuth
// @Accept json
// @Produce json
// @Param app body models.AppPost true "Patch App"
// @Param app_id path int true "App ID"
// @Success 200 {object} common.ResponseHTTP{data=models.AppPost}
// @Failure 400 {object} common.ResponseHTTP{}
// @Failure 500 {object} common.ResponseHTTP{}
// @Router /app/{app_id} [patch]
func PatchApp(contx *fiber.Ctx) error <span class="cov8" title="1">{

        // Starting tracer context and tracer
        ctx := contx.Locals("tracer")
        tracer, _ := ctx.(*observe.RouteTracer)

        // Get database connection
        db, _ := contx.Locals("db").(*gorm.DB)

        //  initialize data validator
        validate := validator.New()

        // validate path params
        id, err := strconv.Atoi(contx.Params("app_id"))
        if err != nil </span><span class="cov8" title="1">{
                return contx.Status(http.StatusBadRequest).JSON(common.ResponseHTTP{
                        Success: false,
                        Message: err.Error(),
                        Data:    nil,
                })
        }</span>

        // validate data struct
        <span class="cov8" title="1">patch_app := new(models.AppPatch)
        if err := contx.BodyParser(&amp;patch_app); err != nil </span><span class="cov0" title="0">{
                return contx.Status(http.StatusBadRequest).JSON(common.ResponseHTTP{
                        Success: false,
                        Message: err.Error(),
                        Data:    nil,
                })
        }</span>

        // then validating
        <span class="cov8" title="1">if err := validate.Struct(patch_app); err != nil </span><span class="cov0" title="0">{
                return contx.Status(http.StatusBadRequest).JSON(common.ResponseHTTP{
                        Success: false,
                        Message: err.Error(),
                        Data:    nil,
                })
        }</span>

        // startng update transaction
        <span class="cov8" title="1">var app models.App
        app.ID = uint(id)
        tx := db.WithContext(tracer.Tracer).Begin()

        // Check if the record exists
        if err := db.WithContext(tracer.Tracer).First(&amp;app, app.ID).Error; err != nil </span><span class="cov8" title="1">{
                // If there's an unexpected error, return an internal server error response
                tx.Rollback()
                return contx.Status(http.StatusNotFound).JSON(common.ResponseHTTP{
                        Success: false,
                        Message: err.Error(),
                        Data:    nil,
                })
        }</span>

        // Update the record
        <span class="cov8" title="1">if err := db.WithContext(tracer.Tracer).Model(&amp;app).UpdateColumns(*patch_app).Error; err != nil </span><span class="cov0" title="0">{
                tx.Rollback()
                return contx.Status(http.StatusInternalServerError).JSON(common.ResponseHTTP{
                        Success: false,
                        Message: err.Error(),
                        Data:    nil,
                })
        }</span>

        // Return  success response
        <span class="cov8" title="1">return contx.Status(http.StatusOK).JSON(common.ResponseHTTP{
                Success: true,
                Message: "App updated successfully.",
                Data:    app,
        })</span>
}

// DeleteApps function removes a app by ID
// @Summary Remove App by ID
// @Description Remove app by ID
// @Tags Apps
// @Security ApiKeyAuth
// @Accept json
// @Produce json
// @Param app_id path int true "App ID"
// @Success 200 {object} common.ResponseHTTP{}
// @Failure 404 {object} common.ResponseHTTP{}
// @Failure 503 {object} common.ResponseHTTP{}
// @Router /app/{app_id} [delete]
func DeleteApp(contx *fiber.Ctx) error <span class="cov8" title="1">{

        // Starting tracer context and tracer
        ctx := contx.Locals("tracer")
        tracer, _ := ctx.(*observe.RouteTracer)

        // Getting Database connection
        db, _ := contx.Locals("db").(*gorm.DB)

        // get deleted app attributes to return
        var app models.App

        // validate path params
        id, err := strconv.Atoi(contx.Params("app_id"))
        if err != nil </span><span class="cov8" title="1">{
                return contx.Status(http.StatusBadRequest).JSON(common.ResponseHTTP{
                        Success: false,
                        Message: err.Error(),
                        Data:    nil,
                })
        }</span>

        // perform delete operation if the object exists
        <span class="cov8" title="1">tx := db.WithContext(tracer.Tracer).Begin()

        // first getting app and checking if it exists
        if err := db.Where("id = ?", id).First(&amp;app).Error; err != nil </span><span class="cov8" title="1">{
                tx.Rollback()
                return contx.Status(http.StatusNotFound).JSON(common.ResponseHTTP{
                        Success: false,
                        Message: err.Error(),
                        Data:    nil,
                })
        }</span>

        // Delete the app
        <span class="cov8" title="1">if err := db.Delete(&amp;app).Error; err != nil </span><span class="cov0" title="0">{
                tx.Rollback()
                return contx.Status(http.StatusInternalServerError).JSON(common.ResponseHTTP{
                        Success: false,
                        Message: "Error deleting app",
                        Data:    nil,
                })
        }</span>

        // Commit the transaction
        <span class="cov8" title="1">tx.Commit()

        // Return success respons
        return contx.Status(http.StatusOK).JSON(common.ResponseHTTP{
                Success: true,
                Message: "App deleted successfully.",
                Data:    app,
        })</span>
}

// ################################################################
// Relationship Based Endpoints
// ################################################################

// Add App Role
// @Summary Add App to Role
// @Description Add App to Role
// @Tags Apps
// @Security ApiKeyAuth
// @Accept json
// @Produce json
// @Param role_id path int true "Role ID"
// @Param app_id query int true " App ID"
// @Failure 400 {object} common.ResponseHTTP{}
// @Router /roleapp/{role_id} [patch]
func AddRoleApps(contx *fiber.Ctx) error <span class="cov0" title="0">{

        // Starting tracer context and tracer
        ctx := contx.Locals("tracer")
        tracer, _ := ctx.(*observe.RouteTracer)

        // connect
        db, _ := contx.Locals("db").(*gorm.DB)

        // validate path params
        role_id, err := strconv.Atoi(contx.Params("role_id"))
        if err != nil </span><span class="cov0" title="0">{
                return contx.Status(http.StatusBadRequest).JSON(common.ResponseHTTP{
                        Success: false,
                        Message: err.Error(),
                        Data:    nil,
                })
        }</span>

        // fetching Endpionts
        <span class="cov0" title="0">var role models.Role
        if res := db.WithContext(tracer.Tracer).Model(&amp;models.Role{}).Where("id = ?", role_id).First(&amp;role); res.Error != nil </span><span class="cov0" title="0">{
                return contx.Status(http.StatusServiceUnavailable).JSON(common.ResponseHTTP{
                        Success: false,
                        Message: res.Error.Error(),
                        Data:    nil,
                })
        }</span>

        // fetching role to be added
        <span class="cov0" title="0">app_id, _ := strconv.Atoi(contx.Query("app_id"))
        var app models.App
        if res := db.WithContext(tracer.Tracer).Model(&amp;models.App{}).Where("id = ?", app_id).First(&amp;app); res.Error != nil </span><span class="cov0" title="0">{
                return contx.Status(http.StatusServiceUnavailable).JSON(common.ResponseHTTP{
                        Success: false,
                        Message: res.Error.Error(),
                        Data:    nil,
                })
        }</span>

        // startng update transaction

        <span class="cov0" title="0">tx := db.WithContext(tracer.Tracer).Begin()
        //  Adding one to many Relation
        if err := db.WithContext(tracer.Tracer).Model(&amp;app).Association("Roles").Append(&amp;role); err != nil </span><span class="cov0" title="0">{
                tx.Rollback()
                return contx.Status(http.StatusNotFound).JSON(common.ResponseHTTP{
                        Success: false,
                        Message: "Error Adding Record",
                        Data:    err.Error(),
                })
        }</span>
        <span class="cov0" title="0">tx.Commit()

        // return value if transaction is sucessfull
        return contx.Status(http.StatusOK).JSON(common.ResponseHTTP{
                Success: true,
                Message: "Success Adding a Role to App.",
                Data:    app,
        })</span>
}

// Delete App Role
// @Summary Delete App Role
// @Description Delete App Role
// @Tags Apps
// @Security ApiKeyAuth
// @Accept json
// @Produce json
// @Param role_id path int true "App ID"
// @Param app_id query int true "Role ID"
// @Failure 400 {object} common.ResponseHTTP{}
// @Router /roleapp/{role_id} [delete]
func DeleteRoleApps(contx *fiber.Ctx) error <span class="cov0" title="0">{

        // Starting tracer context and tracer
        ctx := contx.Locals("tracer")
        tracer, _ := ctx.(*observe.RouteTracer)

        //  database connection
        db, _ := contx.Locals("db").(*gorm.DB)

        // validate path params
        role_id, err := strconv.Atoi(contx.Params("role_id"))
        if err != nil </span><span class="cov0" title="0">{
                return contx.Status(http.StatusBadRequest).JSON(common.ResponseHTTP{
                        Success: false,
                        Message: err.Error(),
                        Data:    nil,
                })
        }</span>

        // Getting Role
        <span class="cov0" title="0">var role models.Role
        if res := db.WithContext(tracer.Tracer).Model(&amp;models.Role{}).Where("id = ?", role_id).First(&amp;role); res.Error != nil </span><span class="cov0" title="0">{
                return contx.Status(http.StatusServiceUnavailable).JSON(common.ResponseHTTP{
                        Success: false,
                        Message: res.Error.Error(),
                        Data:    nil,
                })
        }</span>

        // fetching app to be added
        <span class="cov0" title="0">var app models.App
        app_id, _ := strconv.Atoi(contx.Query("app_id"))
        if res := db.WithContext(tracer.Tracer).Model(&amp;models.App{}).Where("id = ?", app_id).First(&amp;app); res.Error != nil </span><span class="cov0" title="0">{
                return contx.Status(http.StatusServiceUnavailable).JSON(common.ResponseHTTP{
                        Success: false,
                        Message: res.Error.Error(),
                        Data:    nil,
                })
        }</span>

        // Removing Role From App
        <span class="cov0" title="0">tx := db.WithContext(tracer.Tracer).Begin()
        if err := db.WithContext(tracer.Tracer).Model(&amp;app).Association("Roles").Delete(&amp;role); err != nil </span><span class="cov0" title="0">{
                tx.Rollback()
                return contx.Status(http.StatusNotFound).JSON(common.ResponseHTTP{
                        Success: false,
                        Message: "Record not Found",
                        Data:    err.Error(),
                })
        }</span>
        <span class="cov0" title="0">tx.Commit()

        // return value if transaction is sucessfull
        return contx.Status(http.StatusOK).JSON(common.ResponseHTTP{
                Success: true,
                Message: "Success Deleteing a Role From App.",
                Data:    app,
        })</span>
}

type AppsDropDown struct {
        ID   uint   `validate:"required" json:"id"`
        Name string `validate:"required" json:"name"`
}

// Get Feature Dropdown only active roles
// @Summary Get FeatureDropDown
// @Description Get FeatureDropDown
// @Tags Feature
// @Security ApiKeyAuth
// @Accept json
// @Produce json
// @Success 200 {object} common.ResponseHTTP{data=[]FeatureDropDown}
// @Failure 404 {object} common.ResponseHTTP{}
// @Router /appsdrop [get]
func GetDropApps(contx *fiber.Ctx) error <span class="cov0" title="0">{

        // Starting tracer context and tracer
        ctx := contx.Locals("tracer")
        tracer, _ := ctx.(*observe.RouteTracer)

        //  database connection
        db, _ := contx.Locals("db").(*gorm.DB)

        var apps_drop []AppsDropDown
        if res := db.WithContext(tracer.Tracer).Model(&amp;models.App{}).Where("active = ?", true).Find(&amp;apps_drop); res.Error != nil </span><span class="cov0" title="0">{
                return contx.Status(http.StatusServiceUnavailable).JSON(common.ResponseHTTP{
                        Success: false,
                        Message: res.Error.Error(),
                        Data:    nil,
                })
        }</span>

        <span class="cov0" title="0">return contx.Status(http.StatusOK).JSON(common.ResponseHTTP{
                Success: true,
                Message: "Success got response",
                Data:    &amp;apps_drop,
        })</span>
}
</pre>
		
		<pre class="file" id="file8" style="display: none">package controllers

import (
        "fmt"
        "net/http"

        "blue-admin.com/common"
        "blue-admin.com/models"
        "blue-admin.com/observe"
        "blue-admin.com/utils"
        "github.com/gofiber/fiber/v2"
        "github.com/google/uuid"
        "github.com/mitchellh/mapstructure"
        "gorm.io/gorm"
        "gorm.io/gorm/clause"
)

type endpoints struct {
        Name       string `json:"name"`
        RoutePaths string `json:"route_path"`
        Method     string `json:"method"`
}

type features struct {
        Name      string      `json:"name"`
        Endpoints []endpoints `json:"endpoints"`
}
type roles struct {
        Name     string     `json:"name"`
        Features []features `json:"features"`
}

type AppMeta struct {
        Name  string    `json:"name"`
        UUID  uuid.UUID `json:"uuid"`
        Roles []roles   `json:"roles"`
}
type Role string
type Featuers []string
type EndPoints []string
type AppFeaturesMeta map[Role]Featuers
type AppEndpointsMeta map[Role]EndPoints

// Get App Summary
// @Summary Get Roles Grouped By APP ID
// @Description Get App summary by App ID
// @Tags Dashboard Meta
// @Security ApiKeyAuth
// @Accept json
// @Produce json
// @Param app_id query string true "App ID"
// @Success 200 {object} common.ResponseHTTP{data=AppMeta}
// @Failure 404 {object} common.ResponseHTTP{}
// @Router /dashboard [get]
func GetDashBoardGrouped(contx *fiber.Ctx) error <span class="cov0" title="0">{
        //  Getting tracer context
        ctx := contx.Locals("tracer")
        tracer, _ := ctx.(*observe.RouteTracer)

        //  Getting Database connection
        db, _ := contx.Locals("db").(*gorm.DB)

        //  getting the uuid from query string
        app_uuid, _ := uuid.Parse(contx.Query("app_id"))

        var app models.App
        var app_get AppMeta
        if res := db.WithContext(tracer.Tracer).Model(&amp;models.App{}).Preload(clause.Associations).Preload("Roles.Features").Preload("Roles.Features.Endpoints").Where("uuid = ?", app_uuid).First(&amp;app); res.Error != nil </span><span class="cov0" title="0">{
                return contx.Status(http.StatusServiceUnavailable).JSON(common.ResponseHTTP{
                        Success: false,
                        Message: res.Error.Error(),
                        Data:    "nil",
                })
        }</span>
        <span class="cov0" title="0">mapstructure.Decode(app, &amp;app_get)

        return contx.Status(http.StatusOK).JSON(common.ResponseHTTP{
                Success: true,
                Message: "Success got.",
                Data:    &amp;app_get,
        })</span>
}

// Get App Endpoints
// @Summary Get App Endpoints Grouped By Role
// @Description Get App Endpoints summary
// @Tags Dashboard Meta
// @Security ApiKeyAuth
// @Accept json
// @Produce json
// @Param app_id query string true "App ID"
// @Success 200 {object} common.ResponseHTTP{data=AppEndpointsMeta}
// @Failure 404 {object} common.ResponseHTTP{}
// @Router /dashboardends [get]
func GetAppEndpoitnsGroupedBy(contx *fiber.Ctx) error <span class="cov0" title="0">{
        //  Getting tracer context
        ctx := contx.Locals("tracer")
        tracer, _ := ctx.(*observe.RouteTracer)

        //  Getting Database connection
        db, _ := contx.Locals("db").(*gorm.DB)

        var app models.App
        var app_get = make(map[string][]string)
        app_uuid, _ := uuid.Parse(contx.Query("app_id"))

        if res := db.WithContext(tracer.Tracer).Model(&amp;models.App{}).Preload(clause.Associations).Preload("Roles.Features").Preload("Roles.Features.Endpoints").Where("uuid = ?", app_uuid).First(&amp;app); res.Error != nil </span><span class="cov0" title="0">{
                return contx.Status(http.StatusServiceUnavailable).JSON(common.ResponseHTTP{
                        Success: false,
                        Message: res.Error.Error(),
                        Data:    "nil",
                })
        }</span>

        <span class="cov0" title="0">for _, value := range app.Roles </span><span class="cov0" title="0">{
                key := value.Name
                for _, value := range value.Features </span><span class="cov0" title="0">{
                        for _, value := range value.Endpoints </span><span class="cov0" title="0">{

                                app_get[key] = append(app_get[key], value.RoutePath)
                        }</span>
                }

        }

        <span class="cov0" title="0">return contx.Status(http.StatusOK).JSON(common.ResponseHTTP{
                Success: true,
                Message: "Success got.",
                Data:    &amp;app_get,
        })</span>
}

// Get App Features Grouped by Role
// @Summary Get App Features Grouped By Role
// @Description Get App Featuers summary
// @Tags Dashboard Meta
// @Security ApiKeyAuth
// @Accept json
// @Produce json
// @Param app_id query string true "App ID"
// @Success 200 {object} common.ResponseHTTP{data=AppFeaturesMeta}
// @Failure 404 {object} common.ResponseHTTP{}
// @Router /dashboardfeat [get]
func GetAppFeaturesGroupedBy(contx *fiber.Ctx) error <span class="cov0" title="0">{
        //  Getting tracer context
        ctx := contx.Locals("tracer")
        tracer, _ := ctx.(*observe.RouteTracer)

        //  Getting Database connection
        db, _ := contx.Locals("db").(*gorm.DB)

        var app models.App
        var app_get = make(map[string][]string)
        app_uuid, _ := uuid.Parse(contx.Query("app_id"))

        if res := db.WithContext(tracer.Tracer).Model(&amp;models.App{}).Preload(clause.Associations).Preload("Roles.Features").Preload("Roles.Features.Endpoints").Where("uuid = ?", app_uuid).First(&amp;app); res.Error != nil </span><span class="cov0" title="0">{
                return contx.Status(http.StatusServiceUnavailable).JSON(common.ResponseHTTP{
                        Success: false,
                        Message: res.Error.Error(),
                        Data:    "nil",
                })
        }</span>

        <span class="cov0" title="0">for _, value := range app.Roles </span><span class="cov0" title="0">{
                key := value.Name
                for _, value := range value.Features </span><span class="cov0" title="0">{
                        app_get[key] = append(app_get[key], value.Name)
                }</span>

        }

        <span class="cov0" title="0">return contx.Status(http.StatusOK).JSON(common.ResponseHTTP{
                Success: true,
                Message: "Success got.",
                Data:    &amp;app_get,
        })</span>
}

// Get App Pages
// @Summary Get App Pages
// @Description Get App Pages summary
// @Tags Dashboard Meta
// @Security ApiKeyAuth
// @Accept json
// @Produce json
// @Param app_id query string true "App ID"
// @Success 200 {object} common.ResponseHTTP{data=AppFeaturesMeta}
// @Failure 404 {object} common.ResponseHTTP{}
// @Router /dashboardpages [get]
func GetAppPages(contx *fiber.Ctx) error <span class="cov0" title="0">{
        //  Getting tracer context
        ctx := contx.Locals("tracer")
        tracer, _ := ctx.(*observe.RouteTracer)

        //  Getting Database connection
        db, _ := contx.Locals("db").(*gorm.DB)

        var app models.App
        var app_pages = make(map[string][]string)
        app_uuid, _ := uuid.Parse(contx.Query("app_id"))

        if res := db.WithContext(tracer.Tracer).Model(&amp;models.App{}).Preload(clause.Associations).Preload("Roles.Pages").Where("uuid = ?", app_uuid).First(&amp;app); res.Error != nil </span><span class="cov0" title="0">{
                fmt.Println(res.Error.Error())
                return contx.Status(http.StatusServiceUnavailable).JSON(common.ResponseHTTP{
                        Success: false,
                        Message: res.Error.Error(),
                        Data:    "nil",
                })
        }</span>

        <span class="cov0" title="0">key := app.Name
        for _, value := range app.Roles </span><span class="cov0" title="0">{
                for _, value := range value.Pages </span><span class="cov0" title="0">{
                        app_pages[key] = append(app_pages[key], value.Name)
                }</span>

        }
        <span class="cov0" title="0">app_page := utils.UniqueSlice(app_pages[key])
        app_pages[key] = app_page
        return contx.Status(http.StatusOK).JSON(common.ResponseHTTP{
                Success: true,
                Message: "Success got.",
                Data:    &amp;app_pages,
        })</span>

}

// Get App Roles
// @Summary Get App Roles
// @Description Get App Roles summary
// @Tags Dashboard Meta
// @Security ApiKeyAuth
// @Accept json
// @Produce json
// @Param app_id query string true "App ID"
// @Success 200 {object} common.ResponseHTTP{data=AppFeaturesMeta}
// @Failure 404 {object} common.ResponseHTTP{}
// @Router /dashboardroles [get]
func GetAppRoles(contx *fiber.Ctx) error <span class="cov0" title="0">{
        //  Getting tracer context
        ctx := contx.Locals("tracer")
        tracer, _ := ctx.(*observe.RouteTracer)

        //  Getting Database connection
        db, _ := contx.Locals("db").(*gorm.DB)
        var app models.App
        var app_roles = make(map[string][]string)
        app_uuid, _ := uuid.Parse(contx.Query("app_id"))

        if res := db.WithContext(tracer.Tracer).Model(&amp;models.App{}).Preload(clause.Associations).Preload("Roles").Where("uuid = ?", app_uuid).First(&amp;app); res.Error != nil </span><span class="cov0" title="0">{
                return contx.Status(http.StatusServiceUnavailable).JSON(common.ResponseHTTP{
                        Success: false,
                        Message: res.Error.Error(),
                        Data:    "nil",
                })
        }</span>

        <span class="cov0" title="0">key := app.Name
        for _, value := range app.Roles </span><span class="cov0" title="0">{
                app_roles[key] = append(app_roles[key], value.Name)
        }</span>
        <span class="cov0" title="0">return contx.Status(http.StatusOK).JSON(common.ResponseHTTP{
                Success: true,
                Message: "Success got.",
                Data:    &amp;app_roles,
        })</span>

}

// Get Page Found for Every role in App
// @Summary Get Page Roles for Secfic App by ID
// @Description Get Roles by page by ID
// @Tags Dashboard Meta
// @Security ApiKeyAuth
// @Accept json
// @Produce json
// @Param app_id query string true "App ID"
// @Success 200 {object} common.ResponseHTTP{data=models.PageGet}
// @Failure 404 {object} common.ResponseHTTP{}
// @Router /dashboardrolespage [get]
func GetAppPagesInRoles(contx *fiber.Ctx) error <span class="cov0" title="0">{
        //  Getting tracer context
        ctx := contx.Locals("tracer")
        tracer, _ := ctx.(*observe.RouteTracer)

        //  Getting Database connection
        db, _ := contx.Locals("db").(*gorm.DB)

        app_uuid, _ := uuid.Parse(contx.Query("app_id"))
        var role_pages = make(map[string][]string)
        var app models.App
        if res := db.WithContext(tracer.Tracer).Model(&amp;models.App{}).Preload(clause.Associations).Preload("Roles.Pages").Where("uuid = ?", app_uuid).First(&amp;app); res.Error != nil </span><span class="cov0" title="0">{
                return contx.Status(http.StatusServiceUnavailable).JSON(common.ResponseHTTP{
                        Success: false,
                        Message: res.Error.Error(),
                        Data:    "nil",
                })
        }</span>
        <span class="cov0" title="0">for _, value := range app.Roles </span><span class="cov0" title="0">{
                key := value.Name
                for _, value := range value.Pages </span><span class="cov0" title="0">{
                        role_pages[key] = append(role_pages[key], value.Name)
                }</span>
        }
        <span class="cov0" title="0">return contx.Status(http.StatusOK).JSON(common.ResponseHTTP{
                Success: true,
                Message: "Success got.",
                Data:    &amp;role_pages,
        })</span>
}
</pre>
		
		<pre class="file" id="file9" style="display: none">package controllers

import (
        "net/http"

        "blue-admin.com/common"
        "blue-admin.com/messages"
        "github.com/go-playground/validator/v10"
        "github.com/gofiber/fiber/v2"
)

// Send Email to list of users using rabbit
// @Summary Send Email to
// @Description Sending Email
// @Tags Utilities
// @Security ApiKeyAuth
// @Accept json
// @Produce json
// @Param User body messages.EmailMessage true "messages"
// @Success 200 {object} common.ResponseHTTP{data=messages.EmailMessage}
// @Failure 404 {object} common.ResponseHTTP{}
// @Router /email [post]
func SendEmail(contx *fiber.Ctx) error <span class="cov0" title="0">{
        validate := validator.New()

        //validating post data
        posted_message := new(messages.EmailMessage)

        //first parse post data
        if err := contx.BodyParser(&amp;posted_message); err != nil </span><span class="cov0" title="0">{
                return contx.Status(http.StatusBadRequest).JSON(common.ResponseHTTP{
                        Success: false,
                        Message: err.Error(),
                        Data:    nil,
                })
        }</span>

        // then validate structure
        <span class="cov0" title="0">if err := validate.Struct(posted_message); err != nil </span><span class="cov0" title="0">{
                return contx.Status(http.StatusBadRequest).JSON(common.ResponseHTTP{
                        Success: false,
                        Message: err.Error(),
                        Data:    nil,
                })
        }</span>

        //send to rabbit app module qeue using channel
        // Attempt to publish a message to the queue.
        <span class="cov0" title="0">if err := messages.PublishEmailQueue(*posted_message, "email"); err != nil </span><span class="cov0" title="0">{
                return contx.Status(http.StatusBadRequest).JSON(common.ResponseHTTP{
                        Success: false,
                        Message: err.Error(),
                        Data:    nil,
                })
        }</span>
        // close connection and channel of the rabbitmq server

        <span class="cov0" title="0">return contx.Status(http.StatusOK).JSON(common.ResponseHTTP{
                Success: true,
                Message: "Success Sent Emails.",
                Data:    posted_message,
        })</span>

}
</pre>
		
		<pre class="file" id="file10" style="display: none">package controllers

import (
        "net/http"
        "strconv"

        "blue-admin.com/common"
        "blue-admin.com/models"
        "blue-admin.com/observe"
        "github.com/go-playground/validator/v10"
        "github.com/gofiber/fiber/v2"
        "github.com/mitchellh/mapstructure"
        "gorm.io/gorm"
        "gorm.io/gorm/clause"
)

// GetEndpointis a function to get a Endpoints by ID
// @Summary Get Endpoints
// @Description Get Endpoints
// @Tags Endpoints
// @Accept json
// @Produce json
// @Security ApiKeyAuth
// @Security Refresh
// @Param page query int true "page"
// @Param size query int true "page size"
// @Success 200 {object} common.ResponsePagination{data=[]models.EndpointGet}
// @Failure 404 {object} common.ResponseHTTP{}
// @Router /endpoint [get]
func GetEndpoints(contx *fiber.Ctx) error <span class="cov8" title="1">{

        //  Getting tracer context
        ctx := contx.Locals("tracer")
        tracer, _ := ctx.(*observe.RouteTracer)

        //  Getting Database connection
        db, _ := contx.Locals("db").(*gorm.DB)

        //  parsing Query Prameters
        Page, _ := strconv.Atoi(contx.Query("page"))
        Limit, _ := strconv.Atoi(contx.Query("size"))
        //  checking if query parameters  are correct
        if Page == 0 || Limit == 0 </span><span class="cov8" title="1">{
                return contx.Status(http.StatusBadRequest).JSON(common.ResponseHTTP{
                        Success: false,
                        Message: "Not Allowed, Bad request",
                        Data:    nil,
                })
        }</span>

        //  querying result with pagination using gorm function
        <span class="cov8" title="1">result, err := common.PaginationPureModel(db, models.Endpoint{}, []models.Endpoint{}, uint(Page), uint(Limit), tracer.Tracer)
        if err != nil </span><span class="cov0" title="0">{
                return contx.Status(http.StatusInternalServerError).JSON(common.ResponseHTTP{
                        Success: false,
                        Message: "Failed to get all Endpoint.",
                        Data:    "something",
                })
        }</span>

        // returning result if all the above completed successfully
        <span class="cov8" title="1">return contx.Status(http.StatusOK).JSON(result)</span>
}

// GetEndpointByID is a function to get a Endpoints by ID
// @Summary Get Endpoint by ID
// @Description Get endpoint by ID
// @Tags Endpoints
// @Security ApiKeyAuth
// @Accept json
// @Produce json
// @Param endpoint_id path int true "Endpoint ID"
// @Success 200 {object} common.ResponseHTTP{data=models.EndpointGet}
// @Failure 404 {object} common.ResponseHTTP{}
// @Router /endpoint/{endpoint_id} [get]
func GetEndpointByID(contx *fiber.Ctx) error <span class="cov8" title="1">{

        // Starting tracer context and tracer
        ctx := contx.Locals("tracer")
        tracer, _ := ctx.(*observe.RouteTracer)

        //  Getting Database connection
        db, _ := contx.Locals("db").(*gorm.DB)

        //  parsing Query Prameters
        id, err := strconv.Atoi(contx.Params("endpoint_id"))
        if err != nil </span><span class="cov0" title="0">{
                return contx.Status(http.StatusBadRequest).JSON(common.ResponseHTTP{
                        Success: false,
                        Message: err.Error(),
                        Data:    nil,
                })
        }</span>

        // Preparing and querying database using Gorm
        <span class="cov8" title="1">var endpoints_get models.EndpointGet
        var endpoints models.Endpoint
        if res := db.WithContext(tracer.Tracer).Model(&amp;models.Endpoint{}).Preload(clause.Associations).Where("id = ?", id).First(&amp;endpoints); res.Error != nil </span><span class="cov8" title="1">{
                return contx.Status(http.StatusNotFound).JSON(common.ResponseHTTP{
                        Success: false,
                        Message: res.Error.Error(),
                        Data:    nil,
                })
        }</span>

        // filtering response data according to filtered defined struct
        <span class="cov8" title="1">mapstructure.Decode(endpoints, &amp;endpoints_get)

        //  Finally returing response if All the above compeleted successfully
        return contx.Status(http.StatusOK).JSON(common.ResponseHTTP{
                Success: true,
                Message: "Success got one endpoint.",
                Data:    &amp;endpoints_get,
        })</span>
}

// Add Endpoint to data
// @Summary Add a new Endpoint
// @Description Add Endpoint
// @Tags Endpoints
// @Security ApiKeyAuth
// @Accept json
// @Produce json
// @Param endpoint body models.EndpointPost true "Add Endpoint"
// @Success 200 {object} common.ResponseHTTP{data=models.EndpointPost}
// @Failure 400 {object} common.ResponseHTTP{}
// @Failure 500 {object} common.ResponseHTTP{}
// @Router /endpoint [post]
func PostEndpoint(contx *fiber.Ctx) error <span class="cov8" title="1">{

        // Starting tracer context and tracer
        ctx := contx.Locals("tracer")
        tracer, _ := ctx.(*observe.RouteTracer)

        // Getting Database Connection
        db, _ := contx.Locals("db").(*gorm.DB)

        // validator initialization
        validate := validator.New()

        //validating post data
        posted_endpoint := new(models.EndpointPost)

        //first parse request data
        if err := contx.BodyParser(&amp;posted_endpoint); err != nil </span><span class="cov0" title="0">{
                return contx.Status(http.StatusBadRequest).JSON(common.ResponseHTTP{
                        Success: false,
                        Message: err.Error(),
                        Data:    nil,
                })
        }</span>

        // then validate structure
        <span class="cov8" title="1">if err := validate.Struct(posted_endpoint); err != nil </span><span class="cov0" title="0">{
                return contx.Status(http.StatusBadRequest).JSON(common.ResponseHTTP{
                        Success: false,
                        Message: err.Error(),
                        Data:    nil,
                })
        }</span>

        //  initiate -&gt; endpoint
        <span class="cov8" title="1">endpoint := new(models.Endpoint)
        endpoint.Name = posted_endpoint.Name
        endpoint.Description = posted_endpoint.Description

        //  start transaction to database
        tx := db.WithContext(tracer.Tracer).Begin()

        // add  data using transaction if values are valid
        if err := tx.Create(&amp;endpoint).Error; err != nil </span><span class="cov8" title="1">{
                tx.Rollback()
                return contx.Status(http.StatusInternalServerError).JSON(common.ResponseHTTP{
                        Success: false,
                        Message: "Endpoint Creation Failed",
                        Data:    err,
                })
        }</span>

        // close transaction
        <span class="cov8" title="1">tx.Commit()

        // return data if transaction is sucessfull
        return contx.Status(http.StatusOK).JSON(common.ResponseHTTP{
                Success: true,
                Message: "Endpoint created successfully.",
                Data:    endpoint,
        })</span>
}

// Patch Endpoint to data
// @Summary Patch Endpoint
// @Description Patch Endpoint
// @Tags Endpoints
// @Security ApiKeyAuth
// @Accept json
// @Produce json
// @Param endpoint body models.EndpointPost true "Patch Endpoint"
// @Param endpoint_id path int true "Endpoint ID"
// @Success 200 {object} common.ResponseHTTP{data=models.EndpointPost}
// @Failure 400 {object} common.ResponseHTTP{}
// @Failure 500 {object} common.ResponseHTTP{}
// @Router /endpoint/{endpoint_id} [patch]
func PatchEndpoint(contx *fiber.Ctx) error <span class="cov8" title="1">{

        // Starting tracer context and tracer
        ctx := contx.Locals("tracer")
        tracer, _ := ctx.(*observe.RouteTracer)

        // Get database connection
        db, _ := contx.Locals("db").(*gorm.DB)

        //  initialize data validator
        validate := validator.New()

        // validate path params
        id, err := strconv.Atoi(contx.Params("endpoint_id"))
        if err != nil </span><span class="cov8" title="1">{
                return contx.Status(http.StatusBadRequest).JSON(common.ResponseHTTP{
                        Success: false,
                        Message: err.Error(),
                        Data:    nil,
                })
        }</span>

        // validate data struct
        <span class="cov8" title="1">patch_endpoint := new(models.EndpointPatch)
        if err := contx.BodyParser(&amp;patch_endpoint); err != nil </span><span class="cov0" title="0">{
                return contx.Status(http.StatusBadRequest).JSON(common.ResponseHTTP{
                        Success: false,
                        Message: err.Error(),
                        Data:    nil,
                })
        }</span>

        // then validating
        <span class="cov8" title="1">if err := validate.Struct(patch_endpoint); err != nil </span><span class="cov0" title="0">{
                return contx.Status(http.StatusBadRequest).JSON(common.ResponseHTTP{
                        Success: false,
                        Message: err.Error(),
                        Data:    nil,
                })
        }</span>

        // startng update transaction
        <span class="cov8" title="1">var endpoint models.Endpoint
        tx := db.WithContext(tracer.Tracer).Begin()

        // Check if the record exists
        if err := db.WithContext(tracer.Tracer).Where("id = ?", id).First(&amp;endpoint).Error; err != nil </span><span class="cov8" title="1">{
                // If there's an unexpected error, return an internal server error response
                tx.Rollback()
                return contx.Status(http.StatusNotFound).JSON(common.ResponseHTTP{
                        Success: false,
                        Message: err.Error(),
                        Data:    nil,
                })
        }</span>

        // Update the record
        <span class="cov8" title="1">if err := db.WithContext(tracer.Tracer).Model(&amp;endpoint).UpdateColumns(*patch_endpoint).Error; err != nil </span><span class="cov0" title="0">{
                tx.Rollback()
                return contx.Status(http.StatusInternalServerError).JSON(common.ResponseHTTP{
                        Success: false,
                        Message: err.Error(),
                        Data:    nil,
                })
        }</span>

        // Return  success response
        <span class="cov8" title="1">return contx.Status(http.StatusOK).JSON(common.ResponseHTTP{
                Success: true,
                Message: "Endpoint updated successfully.",
                Data:    endpoint,
        })</span>
}

// DeleteEndpoints function removes a endpoint by ID
// @Summary Remove Endpoint by ID
// @Description Remove endpoint by ID
// @Tags Endpoints
// @Security ApiKeyAuth
// @Accept json
// @Produce json
// @Param endpoint_id path int true "Endpoint ID"
// @Success 200 {object} common.ResponseHTTP{}
// @Failure 404 {object} common.ResponseHTTP{}
// @Failure 503 {object} common.ResponseHTTP{}
// @Router /endpoint/{endpoint_id} [delete]
func DeleteEndpoint(contx *fiber.Ctx) error <span class="cov8" title="1">{

        // Starting tracer context and tracer
        ctx := contx.Locals("tracer")
        tracer, _ := ctx.(*observe.RouteTracer)

        // Getting Database connection
        db, _ := contx.Locals("db").(*gorm.DB)

        // get deleted endpoint attributes to return
        var endpoint models.Endpoint

        // validate path params
        id, err := strconv.Atoi(contx.Params("endpoint_id"))
        if err != nil </span><span class="cov8" title="1">{
                return contx.Status(http.StatusBadRequest).JSON(common.ResponseHTTP{
                        Success: false,
                        Message: err.Error(),
                        Data:    nil,
                })
        }</span>

        // perform delete operation if the object exists
        <span class="cov8" title="1">tx := db.WithContext(tracer.Tracer).Begin()

        // first getting endpoint and checking if it exists
        if err := db.Where("id = ?", id).First(&amp;endpoint).Error; err != nil </span><span class="cov8" title="1">{
                tx.Rollback()
                return contx.Status(http.StatusNotFound).JSON(common.ResponseHTTP{
                        Success: false,
                        Message: err.Error(),
                        Data:    nil,
                })
        }</span>

        // Delete the endpoint
        <span class="cov8" title="1">if err := db.Delete(&amp;endpoint).Error; err != nil </span><span class="cov0" title="0">{
                tx.Rollback()
                return contx.Status(http.StatusInternalServerError).JSON(common.ResponseHTTP{
                        Success: false,
                        Message: "Error deleting endpoint",
                        Data:    nil,
                })
        }</span>

        // Commit the transaction
        <span class="cov8" title="1">tx.Commit()

        // Return success respons
        return contx.Status(http.StatusOK).JSON(common.ResponseHTTP{
                Success: true,
                Message: "Endpoint deleted successfully.",
                Data:    endpoint,
        })</span>
}

// ################################################################
// Relationship Based Endpoints
// ################################################################

type EndPointDropDown struct {
        ID   uint   `validate:"required" json:"id"`
        Name string `validate:"required" json:"name"`
}

// Get EndPoint Dropdown only active roles
// @Summary Get EndPointDropDown
// @Description Get EndPointDropDown
// @Tags EndPoints
// @Security ApiKeyAuth
// @Accept json
// @Produce json
// @Success 200 {object} common.ResponseHTTP{data=[]EndPointDropDown}
// @Failure 404 {object} common.ResponseHTTP{}
// @Router /endpointdrop [get]
func GetDropEndPoints(contx *fiber.Ctx) error <span class="cov0" title="0">{
        //  Getting tracer context
        ctx := contx.Locals("tracer")
        tracer, _ := ctx.(*observe.RouteTracer)

        //  Getting Database connection
        db, _ := contx.Locals("db").(*gorm.DB)

        var features_drop []EndPointDropDown
        if res := db.WithContext(tracer.Tracer).Model(&amp;models.Endpoint{}).Find(&amp;features_drop); res.Error != nil </span><span class="cov0" title="0">{
                return contx.Status(http.StatusServiceUnavailable).JSON(common.ResponseHTTP{
                        Success: false,
                        Message: res.Error.Error(),
                        Data:    nil,
                })
        }</span>

        <span class="cov0" title="0">return contx.Status(http.StatusOK).JSON(common.ResponseHTTP{
                Success: true,
                Message: "Success got one role.",
                Data:    &amp;features_drop,
        })</span>
}
</pre>
		
		<pre class="file" id="file11" style="display: none">package controllers

import (
        "net/http"
        "strconv"

        "blue-admin.com/common"
        "blue-admin.com/models"
        "blue-admin.com/observe"
        "github.com/go-playground/validator/v10"
        "github.com/gofiber/fiber/v2"
        "github.com/mitchellh/mapstructure"
        "gorm.io/gorm"
        "gorm.io/gorm/clause"
)

// GetFeatureis a function to get a Features by ID
// @Summary Get Features
// @Description Get Features
// @Tags Features
// @Accept json
// @Produce json
// @Security ApiKeyAuth
// @Security Refresh
// @Param page query int true "page"
// @Param size query int true "page size"
// @Success 200 {object} common.ResponsePagination{data=[]models.FeatureGet}
// @Failure 404 {object} common.ResponseHTTP{}
// @Router /feature [get]
func GetFeatures(contx *fiber.Ctx) error <span class="cov8" title="1">{

        //  Getting tracer context
        ctx := contx.Locals("tracer")
        tracer, _ := ctx.(*observe.RouteTracer)

        //  Getting Database connection
        db, _ := contx.Locals("db").(*gorm.DB)

        //  parsing Query Prameters
        Page, _ := strconv.Atoi(contx.Query("page"))
        Limit, _ := strconv.Atoi(contx.Query("size"))
        //  checking if query parameters  are correct
        if Page == 0 || Limit == 0 </span><span class="cov8" title="1">{
                return contx.Status(http.StatusBadRequest).JSON(common.ResponseHTTP{
                        Success: false,
                        Message: "Not Allowed, Bad request",
                        Data:    nil,
                })
        }</span>

        //  querying result with pagination using gorm function
        <span class="cov8" title="1">result, err := common.PaginationPureModel(db, models.Feature{}, []models.Feature{}, uint(Page), uint(Limit), tracer.Tracer)
        if err != nil </span><span class="cov0" title="0">{
                return contx.Status(http.StatusInternalServerError).JSON(common.ResponseHTTP{
                        Success: false,
                        Message: "Failed to get all Feature.",
                        Data:    "something",
                })
        }</span>

        // returning result if all the above completed successfully
        <span class="cov8" title="1">return contx.Status(http.StatusOK).JSON(result)</span>
}

// GetFeatureByID is a function to get a Features by ID
// @Summary Get Feature by ID
// @Description Get feature by ID
// @Tags Features
// @Security ApiKeyAuth
// @Accept json
// @Produce json
// @Param feature_id path int true "Feature ID"
// @Success 200 {object} common.ResponseHTTP{data=models.FeatureGet}
// @Failure 404 {object} common.ResponseHTTP{}
// @Router /feature/{feature_id} [get]
func GetFeatureByID(contx *fiber.Ctx) error <span class="cov8" title="1">{

        // Starting tracer context and tracer
        ctx := contx.Locals("tracer")
        tracer, _ := ctx.(*observe.RouteTracer)

        //  Getting Database connection
        db, _ := contx.Locals("db").(*gorm.DB)

        //  parsing Query Prameters
        id, err := strconv.Atoi(contx.Params("feature_id"))
        if err != nil </span><span class="cov0" title="0">{
                return contx.Status(http.StatusBadRequest).JSON(common.ResponseHTTP{
                        Success: false,
                        Message: err.Error(),
                        Data:    nil,
                })
        }</span>

        // Preparing and querying database using Gorm
        <span class="cov8" title="1">var features_get models.FeatureGet
        var features models.Feature
        if res := db.WithContext(tracer.Tracer).Model(&amp;models.Feature{}).Preload(clause.Associations).Where("id = ?", id).First(&amp;features); res.Error != nil </span><span class="cov8" title="1">{
                return contx.Status(http.StatusNotFound).JSON(common.ResponseHTTP{
                        Success: false,
                        Message: res.Error.Error(),
                        Data:    nil,
                })
        }</span>

        // filtering response data according to filtered defined struct
        <span class="cov8" title="1">mapstructure.Decode(features, &amp;features_get)

        //  Finally returing response if All the above compeleted successfully
        return contx.Status(http.StatusOK).JSON(common.ResponseHTTP{
                Success: true,
                Message: "Success got one feature.",
                Data:    &amp;features_get,
        })</span>
}

// Add Feature to data
// @Summary Add a new Feature
// @Description Add Feature
// @Tags Features
// @Security ApiKeyAuth
// @Accept json
// @Produce json
// @Param feature body models.FeaturePost true "Add Feature"
// @Success 200 {object} common.ResponseHTTP{data=models.FeaturePost}
// @Failure 400 {object} common.ResponseHTTP{}
// @Failure 500 {object} common.ResponseHTTP{}
// @Router /feature [post]
func PostFeature(contx *fiber.Ctx) error <span class="cov8" title="1">{

        // Starting tracer context and tracer
        ctx := contx.Locals("tracer")
        tracer, _ := ctx.(*observe.RouteTracer)

        // Getting Database Connection
        db, _ := contx.Locals("db").(*gorm.DB)

        // validator initialization
        validate := validator.New()

        //validating post data
        posted_feature := new(models.FeaturePost)

        //first parse request data
        if err := contx.BodyParser(&amp;posted_feature); err != nil </span><span class="cov0" title="0">{
                return contx.Status(http.StatusBadRequest).JSON(common.ResponseHTTP{
                        Success: false,
                        Message: err.Error(),
                        Data:    nil,
                })
        }</span>

        // then validate structure
        <span class="cov8" title="1">if err := validate.Struct(posted_feature); err != nil </span><span class="cov0" title="0">{
                return contx.Status(http.StatusBadRequest).JSON(common.ResponseHTTP{
                        Success: false,
                        Message: err.Error(),
                        Data:    nil,
                })
        }</span>

        //  initiate -&gt; feature
        <span class="cov8" title="1">feature := new(models.Feature)
        feature.Name = posted_feature.Name
        feature.Description = posted_feature.Description

        //  start transaction to database
        tx := db.WithContext(tracer.Tracer).Begin()

        // add  data using transaction if values are valid
        if err := tx.Create(&amp;feature).Error; err != nil </span><span class="cov8" title="1">{
                tx.Rollback()
                return contx.Status(http.StatusInternalServerError).JSON(common.ResponseHTTP{
                        Success: false,
                        Message: "Feature Creation Failed",
                        Data:    err,
                })
        }</span>

        // close transaction
        <span class="cov8" title="1">tx.Commit()

        // return data if transaction is sucessfull
        return contx.Status(http.StatusOK).JSON(common.ResponseHTTP{
                Success: true,
                Message: "Feature created successfully.",
                Data:    feature,
        })</span>
}

// Patch Feature to data
// @Summary Patch Feature
// @Description Patch Feature
// @Tags Features
// @Security ApiKeyAuth
// @Accept json
// @Produce json
// @Param feature body models.FeaturePost true "Patch Feature"
// @Param feature_id path int true "Feature ID"
// @Success 200 {object} common.ResponseHTTP{data=models.FeaturePost}
// @Failure 400 {object} common.ResponseHTTP{}
// @Failure 500 {object} common.ResponseHTTP{}
// @Router /feature/{feature_id} [patch]
func PatchFeature(contx *fiber.Ctx) error <span class="cov8" title="1">{

        // Starting tracer context and tracer
        ctx := contx.Locals("tracer")
        tracer, _ := ctx.(*observe.RouteTracer)

        // Get database connection
        db, _ := contx.Locals("db").(*gorm.DB)

        //  initialize data validator
        validate := validator.New()

        // validate path params
        id, err := strconv.Atoi(contx.Params("feature_id"))
        if err != nil </span><span class="cov8" title="1">{
                return contx.Status(http.StatusBadRequest).JSON(common.ResponseHTTP{
                        Success: false,
                        Message: err.Error(),
                        Data:    nil,
                })
        }</span>

        // validate data struct
        <span class="cov8" title="1">patch_feature := new(models.FeaturePatch)
        if err := contx.BodyParser(&amp;patch_feature); err != nil </span><span class="cov0" title="0">{
                return contx.Status(http.StatusBadRequest).JSON(common.ResponseHTTP{
                        Success: false,
                        Message: err.Error(),
                        Data:    nil,
                })
        }</span>

        // then validating
        <span class="cov8" title="1">if err := validate.Struct(patch_feature); err != nil </span><span class="cov0" title="0">{
                return contx.Status(http.StatusBadRequest).JSON(common.ResponseHTTP{
                        Success: false,
                        Message: err.Error(),
                        Data:    nil,
                })
        }</span>

        // startng update transaction
        <span class="cov8" title="1">var feature models.Feature
        tx := db.WithContext(tracer.Tracer).Begin()
        // Check if the record exists
        if err := db.WithContext(tracer.Tracer).Where("id = ?", id).First(&amp;feature).Error; err != nil </span><span class="cov8" title="1">{
                // If there's an unexpected error, return an internal server error response
                tx.Rollback()
                return contx.Status(http.StatusNotFound).JSON(common.ResponseHTTP{
                        Success: false,
                        Message: err.Error(),
                        Data:    nil,
                })
        }</span>

        // Update the record
        <span class="cov8" title="1">if err := db.WithContext(tracer.Tracer).Model(&amp;feature).UpdateColumns(*patch_feature).Error; err != nil </span><span class="cov0" title="0">{
                tx.Rollback()
                return contx.Status(http.StatusInternalServerError).JSON(common.ResponseHTTP{
                        Success: false,
                        Message: err.Error(),
                        Data:    nil,
                })
        }</span>

        // Return  success response
        <span class="cov8" title="1">return contx.Status(http.StatusOK).JSON(common.ResponseHTTP{
                Success: true,
                Message: "Feature updated successfully.",
                Data:    feature,
        })</span>
}

// DeleteFeatures function removes a feature by ID
// @Summary Remove Feature by ID
// @Description Remove feature by ID
// @Tags Features
// @Security ApiKeyAuth
// @Accept json
// @Produce json
// @Param feature_id path int true "Feature ID"
// @Success 200 {object} common.ResponseHTTP{}
// @Failure 404 {object} common.ResponseHTTP{}
// @Failure 503 {object} common.ResponseHTTP{}
// @Router /feature/{feature_id} [delete]
func DeleteFeature(contx *fiber.Ctx) error <span class="cov8" title="1">{

        // Starting tracer context and tracer
        ctx := contx.Locals("tracer")
        tracer, _ := ctx.(*observe.RouteTracer)

        // Getting Database connection
        db, _ := contx.Locals("db").(*gorm.DB)

        // get deleted feature attributes to return
        var feature models.Feature

        // validate path params
        id, err := strconv.Atoi(contx.Params("feature_id"))
        if err != nil </span><span class="cov8" title="1">{
                return contx.Status(http.StatusBadRequest).JSON(common.ResponseHTTP{
                        Success: false,
                        Message: err.Error(),
                        Data:    nil,
                })
        }</span>

        // perform delete operation if the object exists
        <span class="cov8" title="1">tx := db.WithContext(tracer.Tracer).Begin()

        // first getting feature and checking if it exists
        if err := db.Where("id = ?", id).First(&amp;feature).Error; err != nil </span><span class="cov8" title="1">{
                tx.Rollback()
                return contx.Status(http.StatusNotFound).JSON(common.ResponseHTTP{
                        Success: false,
                        Message: err.Error(),
                        Data:    nil,
                })
        }</span>

        // Delete the feature
        <span class="cov8" title="1">if err := db.Delete(&amp;feature).Error; err != nil </span><span class="cov0" title="0">{
                tx.Rollback()
                return contx.Status(http.StatusInternalServerError).JSON(common.ResponseHTTP{
                        Success: false,
                        Message: "Error deleting feature",
                        Data:    nil,
                })
        }</span>

        // Commit the transaction
        <span class="cov8" title="1">tx.Commit()

        // Return success respons
        return contx.Status(http.StatusOK).JSON(common.ResponseHTTP{
                Success: true,
                Message: "Feature deleted successfully.",
                Data:    feature,
        })</span>
}

// ################################################################
// Relationship Based Endpoints
// ################################################################

// Add Feature Endpoint
// @Summary Add Feature to Endpoint
// @Description Add Feature to Endpoint
// @Tags Features
// @Security ApiKeyAuth
// @Accept json
// @Produce json
// @Param endpoint_id path int true "Endpoint ID"
// @Param feature_id query int true " Feature ID"
// @Failure 400 {object} common.ResponseHTTP{}
// @Router /endpointfeature/{endpoint_id} [patch]
func AddEndpointFeatures(contx *fiber.Ctx) error <span class="cov0" title="0">{

        // Starting tracer context and tracer
        ctx := contx.Locals("tracer")
        tracer, _ := ctx.(*observe.RouteTracer)

        // connect
        db, _ := contx.Locals("db").(*gorm.DB)

        // validate path params
        endpoint_id, err := strconv.Atoi(contx.Params("endpoint_id"))
        if err != nil </span><span class="cov0" title="0">{
                return contx.Status(http.StatusBadRequest).JSON(common.ResponseHTTP{
                        Success: false,
                        Message: err.Error(),
                        Data:    nil,
                })
        }</span>

        // fetching Endpionts
        <span class="cov0" title="0">var endpoint models.Endpoint
        if res := db.WithContext(tracer.Tracer).Model(&amp;models.Endpoint{}).Where("id = ?", endpoint_id).First(&amp;endpoint); res.Error != nil </span><span class="cov0" title="0">{
                return contx.Status(http.StatusServiceUnavailable).JSON(common.ResponseHTTP{
                        Success: false,
                        Message: res.Error.Error(),
                        Data:    nil,
                })
        }</span>

        // fetching endpoint to be added
        <span class="cov0" title="0">feature_id, _ := strconv.Atoi(contx.Query("feature_id"))
        var feature models.Feature
        if res := db.WithContext(tracer.Tracer).Model(&amp;models.Feature{}).Where("id = ?", feature_id).First(&amp;feature); res.Error != nil </span><span class="cov0" title="0">{
                return contx.Status(http.StatusServiceUnavailable).JSON(common.ResponseHTTP{
                        Success: false,
                        Message: res.Error.Error(),
                        Data:    nil,
                })
        }</span>

        // startng update transaction

        <span class="cov0" title="0">tx := db.WithContext(tracer.Tracer).Begin()
        //  Adding one to many Relation
        if err := db.WithContext(tracer.Tracer).Model(&amp;feature).Association("Endpoints").Append(&amp;endpoint); err != nil </span><span class="cov0" title="0">{
                tx.Rollback()
                return contx.Status(http.StatusNotFound).JSON(common.ResponseHTTP{
                        Success: false,
                        Message: "Error Adding Record",
                        Data:    err.Error(),
                })
        }</span>
        <span class="cov0" title="0">tx.Commit()

        // return value if transaction is sucessfull
        return contx.Status(http.StatusOK).JSON(common.ResponseHTTP{
                Success: true,
                Message: "Success Adding a Endpoint to Feature.",
                Data:    feature,
        })</span>
}

// Delete Feature Endpoint
// @Summary Delete Feature Endpoint
// @Description Delete Feature Endpoint
// @Tags Features
// @Security ApiKeyAuth
// @Accept json
// @Produce json
// @Param endpoint_id path int true "Feature ID"
// @Param feature_id query int true "Endpoint ID"
// @Failure 400 {object} common.ResponseHTTP{}
// @Router /endpointfeature/{endpoint_id} [delete]
func DeleteEndpointFeatures(contx *fiber.Ctx) error <span class="cov0" title="0">{

        // Starting tracer context and tracer
        ctx := contx.Locals("tracer")
        tracer, _ := ctx.(*observe.RouteTracer)

        //  database connection
        db, _ := contx.Locals("db").(*gorm.DB)

        // validate path params
        endpoint_id, err := strconv.Atoi(contx.Params("endpoint_id"))
        if err != nil </span><span class="cov0" title="0">{
                return contx.Status(http.StatusBadRequest).JSON(common.ResponseHTTP{
                        Success: false,
                        Message: err.Error(),
                        Data:    nil,
                })
        }</span>

        // Getting Endpoint
        <span class="cov0" title="0">var endpoint models.Endpoint
        if res := db.WithContext(tracer.Tracer).Model(&amp;models.Endpoint{}).Where("id = ?", endpoint_id).First(&amp;endpoint); res.Error != nil </span><span class="cov0" title="0">{
                return contx.Status(http.StatusServiceUnavailable).JSON(common.ResponseHTTP{
                        Success: false,
                        Message: res.Error.Error(),
                        Data:    nil,
                })
        }</span>

        // fetching feature to be added
        <span class="cov0" title="0">var feature models.Feature
        feature_id, _ := strconv.Atoi(contx.Query("feature_id"))
        if res := db.WithContext(tracer.Tracer).Model(&amp;models.Feature{}).Where("id = ?", feature_id).First(&amp;feature); res.Error != nil </span><span class="cov0" title="0">{
                return contx.Status(http.StatusServiceUnavailable).JSON(common.ResponseHTTP{
                        Success: false,
                        Message: res.Error.Error(),
                        Data:    nil,
                })
        }</span>

        // Removing Endpoint From Feature
        <span class="cov0" title="0">tx := db.WithContext(tracer.Tracer).Begin()
        if err := db.WithContext(tracer.Tracer).Model(&amp;feature).Association("Endpoints").Delete(&amp;endpoint); err != nil </span><span class="cov0" title="0">{
                tx.Rollback()
                return contx.Status(http.StatusNotFound).JSON(common.ResponseHTTP{
                        Success: false,
                        Message: "Record not Found",
                        Data:    err.Error(),
                })
        }</span>
        <span class="cov0" title="0">tx.Commit()

        // return value if transaction is sucessfull
        return contx.Status(http.StatusOK).JSON(common.ResponseHTTP{
                Success: true,
                Message: "Success Deleteing a Endpoint From Feature.",
                Data:    feature,
        })</span>
}

type FeatureDropDown struct {
        ID   uint   `validate:"required" json:"id"`
        Name string `validate:"required" json:"name"`
}

// Get Feature Dropdown only active roles
// @Summary Get FeatureDropDown
// @Description Get FeatureDropDown
// @Tags Feature
// @Security ApiKeyAuth
// @Accept json
// @Produce json
// @Success 200 {object} common.ResponseHTTP{data=[]FeatureDropDown}
// @Failure 404 {object} common.ResponseHTTP{}
// @Router /featuredrop [get]
func GetDropFeatures(contx *fiber.Ctx) error <span class="cov0" title="0">{
        //  Getting tracer context
        ctx := contx.Locals("tracer")
        tracer, _ := ctx.(*observe.RouteTracer)

        //  Getting Database connection
        db, _ := contx.Locals("db").(*gorm.DB)

        var features_drop []FeatureDropDown
        if res := db.WithContext(tracer.Tracer).Model(&amp;models.Feature{}).Where("active = ?", true).Find(&amp;features_drop); res.Error != nil </span><span class="cov0" title="0">{
                return contx.Status(http.StatusServiceUnavailable).JSON(common.ResponseHTTP{
                        Success: false,
                        Message: res.Error.Error(),
                        Data:    nil,
                })
        }</span>

        <span class="cov0" title="0">return contx.Status(http.StatusOK).JSON(common.ResponseHTTP{
                Success: true,
                Message: "Success got one role.",
                Data:    &amp;features_drop,
        })</span>
}

// Activate/Deactivate Feature to data
// @Summary Activate/Deactivate Feature
// @Description Activate/Deactivate Feature
// @Tags Feature
// @Security ApiKeyAuth
// @Accept json
// @Produce json
// @Param feature_id path int true "Feature ID"
// @Param active query bool true "Active"
// @Success 200 {object} common.ResponseHTTP{data=models.FeaturePost}
// @Failure 400 {object} common.ResponseHTTP{}
// @Router /features/{feature_id} [put]
func ActivateDeactivateFeature(contx *fiber.Ctx) error <span class="cov0" title="0">{

        //  Getting tracer context
        ctx := contx.Locals("tracer")
        tracer, _ := ctx.(*observe.RouteTracer)

        //  Getting Database connection
        db, _ := contx.Locals("db").(*gorm.DB)

        // validate path params
        feature_id, err := strconv.Atoi(contx.Params("feature_id"))
        if err != nil </span><span class="cov0" title="0">{
                return contx.Status(http.StatusBadRequest).JSON(common.ResponseHTTP{
                        Success: false,
                        Message: err.Error(),
                        Data:    nil,
                })
        }</span>
        //  gettng query parm
        <span class="cov0" title="0">active := contx.QueryBool("active")
        // startng update transaction
        var feature models.Feature
        tx := db.WithContext(tracer.Tracer).Begin()
        if err := db.WithContext(tracer.Tracer).Where("id = ?", feature_id).First(&amp;feature).Update("active", active).Error; err != nil </span><span class="cov0" title="0">{
                tx.Rollback()
                return contx.Status(http.StatusNotFound).JSON(common.ResponseHTTP{
                        Success: false,
                        Message: "Record not Found",
                        Data:    err,
                })
        }</span>
        <span class="cov0" title="0">tx.Commit()
        if feature.ID != 0 </span><span class="cov0" title="0">{
                feature.Active = active
                // return value if transaction is sucessfull
                return contx.Status(http.StatusOK).JSON(common.ResponseHTTP{
                        Success: true,
                        Message: "Success Updating a feature.",
                        Data:    feature,
                })

        }</span>

        // Finally if no record found
        <span class="cov0" title="0">return contx.Status(http.StatusBadRequest).JSON(common.ResponseHTTP{
                Success: false,
                Message: "No Record Found",
                Data:    nil,
        })</span>
}
</pre>
		
		<pre class="file" id="file12" style="display: none">package controllers

import (
        "errors"
        "net/http"

        "blue-admin.com/common"
        "blue-admin.com/models"
        "blue-admin.com/observe"
        "github.com/gofiber/fiber/v2"
        "gorm.io/gorm"
)

// GetJWTSaltis a function to get a JWTSalts by ID
// @Summary Get JWTSalts
// @Description Get JWTSalts
// @Tags JWTSalts
// @Accept json
// @Produce json
// @Security ApiKeyAuth
// @Security Refresh
// @Success 200 {object} common.ResponsePagination{data=models.JWTSalt}
// @Failure 404 {object} common.ResponseHTTP{}
// @Router /jwtsalt [get]
func GetJWTSalts(contx *fiber.Ctx) error <span class="cov0" title="0">{

        //  Getting tracer context
        ctx := contx.Locals("tracer")
        tracer, _ := ctx.(*observe.RouteTracer)

        //  Getting Database connection
        db, _ := contx.Locals("db").(*gorm.DB)

        //  querying result with pagination using gorm function
        var salts models.JWTSalt
        if res := db.WithContext(tracer.Tracer).Model(&amp;models.JWTSalt{}).Where("id = ?", 1).First(&amp;salts); res.Error != nil </span><span class="cov0" title="0">{
                if errors.Is(res.Error, gorm.ErrRecordNotFound) </span><span class="cov0" title="0">{
                        return contx.Status(http.StatusNotFound).JSON(common.ResponseHTTP{
                                Success: false,
                                Message: "Role not found",
                                Data:    nil,
                        })
                }</span>
                <span class="cov0" title="0">return contx.Status(http.StatusInternalServerError).JSON(common.ResponseHTTP{
                        Success: false,
                        Message: "Error retrieving Role",
                        Data:    nil,
                })</span>
        }

        // returning result if all the above completed successfully
        //  Finally returing response if All the above compeleted successfully
        <span class="cov0" title="0">return contx.Status(http.StatusOK).JSON(common.ResponseHTTP{
                Success: true,
                Message: "Success got one salts.",
                Data:    &amp;salts,
        })</span>
}
</pre>
		
		<pre class="file" id="file13" style="display: none">package controllers

import (
        "net/http"

        "blue-admin.com/common"
        "blue-admin.com/database"
        "blue-admin.com/models"
        "blue-admin.com/observe"
        "blue-admin.com/utils"
        "github.com/go-playground/validator/v10"
        "github.com/gofiber/fiber/v2"
        "gorm.io/gorm/clause"
)

// Login Request for Endpoint
type LoginPost struct {
        GrantType string `json:"grant_type" validate:"required" example:"authorization_code"`
        Email     string `json:"email" validate:"email,min=6,max=32"`
        Password  string `json:"password"`
        Token     string `json:"token"`
}

// Access token Response
type TokenResponse struct {
        AccessToken  string `json:"access_token"`
        RefreshToken string `json:"refresh_token"`
        TokenType    string `json:"token_type"`
}

// Login is a function to login by EMAIL and ID
// @Summary Auth
// @Description Login
// @Tags Authentication
// @Accept json
// @Produce json
// @Param user body LoginPost true "Login"
// @Success 200 {object} common.ResponseHTTP{data=TokenResponse{}}
// @Failure 404 {object} common.ResponseHTTP{}
// @Failure 503 {object} common.ResponseHTTP{}
// @Router /login [post]
func PostLogin(contx *fiber.Ctx) error <span class="cov8" title="1">{

        // Starting tracer context and tracer
        ctx := contx.Locals("tracer")
        tracer, _ := ctx.(*observe.RouteTracer)

        // Getting Databse session
        db, _ := database.ReturnSession()
        validate := validator.New()

        //validating post data
        login_request_data := new(LoginPost)

        //first parse post data
        if err := contx.BodyParser(&amp;login_request_data); err != nil </span><span class="cov0" title="0">{
                return contx.Status(http.StatusBadRequest).JSON(common.ResponseHTTP{
                        Success: false,
                        Message: err.Error(),
                        Data:    nil,
                })
        }</span>

        // then validate structure
        <span class="cov8" title="1">if err := validate.Struct(login_request_data); err != nil </span><span class="cov0" title="0">{
                return contx.Status(http.StatusBadRequest).JSON(common.ResponseHTTP{
                        Success: false,
                        Message: err.Error(),
                        Data:    nil,
                })
        }</span>
        <span class="cov8" title="1">switch login_request_data.GrantType </span>{
        case "authorization_code":<span class="cov8" title="1">
                var user models.User
                res := db.WithContext(tracer.Tracer).Model(&amp;models.User{}).Preload(clause.Associations).Where("email = ?", login_request_data.Email).First(&amp;user)
                if res.Error != nil </span><span class="cov0" title="0">{
                        return contx.Status(http.StatusServiceUnavailable).JSON(common.ResponseHTTP{
                                Success: false,
                                Message: res.Error.Error(),
                                Data:    nil,
                        })
                }</span> else<span class="cov8" title="1"> if utils.PasswordsMatch(user.Password, login_request_data.Password) </span><span class="cov8" title="1">{
                        roles := make([]string, 0, 20)
                        for _, value := range user.Roles </span><span class="cov0" title="0">{

                                roles = append(roles, string(value.Name))
                        }</span>
                        <span class="cov8" title="1">accessString, _ := utils.CreateJWTToken(user.Email, user.UUID, roles, 60)
                        refreshString, _ := utils.CreateJWTToken(user.Email, user.UUID, roles, 65)

                        data := TokenResponse{
                                AccessToken:  accessString,
                                RefreshToken: refreshString,
                                TokenType:    "Bearer",
                        }
                        return contx.Status(http.StatusAccepted).JSON(common.ResponseHTTP{
                                Success: true,
                                Message: "Authorization Granted",
                                Data:    data,
                        })</span>
                } else<span class="cov8" title="1"> {
                        return contx.Status(http.StatusUnauthorized).JSON(common.ResponseHTTP{
                                Success: false,
                                Message: "Make sure You are Providing the Correct Credentials",
                                Data:    "Authenthication Failed",
                        })
                }</span>
                // return "something"
        case "refresh_token":<span class="cov8" title="1">
                claims, err := utils.ParseJWTToken(login_request_data.Token)
                email := claims.Email
                uuid := claims.UUID
                roles := claims.Roles
                if err == nil </span><span class="cov8" title="1">{
                        accessString, _ := utils.CreateJWTToken(email, uuid, roles, 60)
                        refreshString, _ := utils.CreateJWTToken(email, uuid, roles, 65)
                        data := TokenResponse{
                                AccessToken:  accessString,
                                RefreshToken: refreshString,
                                TokenType:    "Bearer",
                        }
                        return contx.Status(http.StatusAccepted).JSON(common.ResponseHTTP{
                                Success: true,
                                Message: "Authorization Granted",
                                Data:    data,
                        })
                }</span>

                <span class="cov0" title="0">return contx.Status(http.StatusBadRequest).JSON(common.ResponseHTTP{
                        Success: false,
                        Message: "Request Type Unknown",
                        Data:    "Currently Not Implemented",
                })</span>
        case "token_decode":<span class="cov8" title="1">
                claims, err := utils.ParseJWTToken(login_request_data.Token)

                if err == nil </span><span class="cov8" title="1">{
                        return contx.Status(http.StatusAccepted).JSON(common.ResponseHTTP{
                                Success: true,
                                Message: "Token decode sucessfull",
                                Data:    claims,
                        })
                }</span>
                <span class="cov0" title="0">return contx.Status(http.StatusBadRequest).JSON(common.ResponseHTTP{
                        Success: false,
                        Message: err.Error(),
                        Data:    "Unknown grant type",
                })</span>
        default:<span class="cov8" title="1">
                return contx.Status(http.StatusBadRequest).JSON(common.ResponseHTTP{
                        Success: false,
                        Message: "Request Type Unknown",
                        Data:    "Unknown grant type",
                })</span>
        }

}

// CheckLogin is a function to checktoken Status
// @Summary Auth
// @Description CheckLogin
// @Tags Authentication
// @Accept json
// @Produce json
// @Security ApiKeyAuth
// @Success 200 {object} common.ResponseHTTP{data=TokenResponse{}}
// @Failure 404 {object} common.ResponseHTTP{}
// @Router /checklogin [get]
func CheckLogin(contx *fiber.Ctx) error <span class="cov8" title="1">{

        token := contx.Get("X-APP-TOKEN")

        if token == "" </span><span class="cov8" title="1">{
                contx.Status(http.StatusBadRequest).JSON(common.ResponseHTTP{
                        Success: false,
                        Message: "No header provided",
                        Data:    "Error Getting Header Value",
                })
        }</span>


        <span class="cov8" title="1">claims, err := utils.ParseJWTToken(token)
        //  Decoding the token
        if err != nil </span><span class="cov8" title="1">{
                return contx.Status(http.StatusForbidden).JSON(common.ResponseHTTP{
                        Success: false,
                        Message: err.Error(),
                        Data:    nil,
                })
        }</span>

        // returning the value
        <span class="cov8" title="1">return contx.Status(http.StatusAccepted).JSON(common.ResponseHTTP{
                Success: true,
                Message: "Token decode sucessfull",
                Data:    claims,
        })</span>
}
</pre>
		
		<pre class="file" id="file14" style="display: none">package controllers

import (
        "net/http"
        "strconv"

        "blue-admin.com/common"
        "blue-admin.com/models"
        "blue-admin.com/observe"
        "github.com/go-playground/validator/v10"
        "github.com/gofiber/fiber/v2"
        "github.com/mitchellh/mapstructure"
        "gorm.io/gorm"
        "gorm.io/gorm/clause"
)

// GetPageis a function to get a Pages by ID
// @Summary Get Pages
// @Description Get Pages
// @Tags Pages
// @Accept json
// @Produce json
// @Security ApiKeyAuth
// @Security Refresh
// @Param page query int true "page"
// @Param size query int true "page size"
// @Success 200 {object} common.ResponsePagination{data=[]models.PageGet}
// @Failure 404 {object} common.ResponseHTTP{}
// @Router /page [get]
func GetPages(contx *fiber.Ctx) error <span class="cov8" title="1">{

        //  Getting tracer context
        ctx := contx.Locals("tracer")
        tracer, _ := ctx.(*observe.RouteTracer)

        //  Getting Database connection
        db, _ := contx.Locals("db").(*gorm.DB)

        //  parsing Query Prameters
        Page, _ := strconv.Atoi(contx.Query("page"))
        Limit, _ := strconv.Atoi(contx.Query("size"))
        //  checking if query parameters  are correct
        if Page == 0 || Limit == 0 </span><span class="cov8" title="1">{
                return contx.Status(http.StatusBadRequest).JSON(common.ResponseHTTP{
                        Success: false,
                        Message: "Not Allowed, Bad request",
                        Data:    nil,
                })
        }</span>

        //  querying result with pagination using gorm function
        <span class="cov8" title="1">result, err := common.Pagination(db, models.Page{}, []models.Page{}, uint(Page), uint(Limit), tracer.Tracer)
        if err != nil </span><span class="cov0" title="0">{
                return contx.Status(http.StatusInternalServerError).JSON(common.ResponseHTTP{
                        Success: false,
                        Message: "Failed to get all Page.",
                        Data:    "something",
                })
        }</span>

        // returning result if all the above completed successfully
        <span class="cov8" title="1">return contx.Status(http.StatusOK).JSON(result)</span>
}

// GetPageByID is a function to get a Pages by ID
// @Summary Get Page by ID
// @Description Get page by ID
// @Tags Pages
// @Security ApiKeyAuth
// @Accept json
// @Produce json
// @Param page_id path int true "Page ID"
// @Success 200 {object} common.ResponseHTTP{data=models.PageGet}
// @Failure 404 {object} common.ResponseHTTP{}
// @Router /page/{page_id} [get]
func GetPageByID(contx *fiber.Ctx) error <span class="cov8" title="1">{

        // Starting tracer context and tracer
        ctx := contx.Locals("tracer")
        tracer, _ := ctx.(*observe.RouteTracer)

        //  Getting Database connection
        db, _ := contx.Locals("db").(*gorm.DB)

        //  parsing Query Prameters
        id, err := strconv.Atoi(contx.Params("page_id"))
        if err != nil </span><span class="cov0" title="0">{
                return contx.Status(http.StatusBadRequest).JSON(common.ResponseHTTP{
                        Success: false,
                        Message: err.Error(),
                        Data:    nil,
                })
        }</span>

        // Preparing and querying database using Gorm
        <span class="cov8" title="1">var pages_get models.PageGet
        var pages models.Page
        if res := db.WithContext(tracer.Tracer).Model(&amp;models.Page{}).Preload(clause.Associations).Where("id = ?", id).First(&amp;pages); res.Error != nil </span><span class="cov8" title="1">{
                return contx.Status(http.StatusNotFound).JSON(common.ResponseHTTP{
                        Success: false,
                        Message: res.Error.Error(),
                        Data:    nil,
                })
        }</span>

        // filtering response data according to filtered defined struct
        <span class="cov8" title="1">mapstructure.Decode(pages, &amp;pages_get)

        //  Finally returing response if All the above compeleted successfully
        return contx.Status(http.StatusOK).JSON(common.ResponseHTTP{
                Success: true,
                Message: "Success got one page.",
                Data:    &amp;pages_get,
        })</span>
}

// Add Page to data
// @Summary Add a new Page
// @Description Add Page
// @Tags Pages
// @Security ApiKeyAuth
// @Accept json
// @Produce json
// @Param page body models.PagePost true "Add Page"
// @Success 200 {object} common.ResponseHTTP{data=models.PagePost}
// @Failure 400 {object} common.ResponseHTTP{}
// @Failure 500 {object} common.ResponseHTTP{}
// @Router /page [post]
func PostPage(contx *fiber.Ctx) error <span class="cov8" title="1">{

        // Starting tracer context and tracer
        ctx := contx.Locals("tracer")
        tracer, _ := ctx.(*observe.RouteTracer)

        // Getting Database Connection
        db, _ := contx.Locals("db").(*gorm.DB)

        // validator initialization
        validate := validator.New()

        //validating post data
        posted_page := new(models.PagePost)

        //first parse request data
        if err := contx.BodyParser(&amp;posted_page); err != nil </span><span class="cov0" title="0">{
                return contx.Status(http.StatusBadRequest).JSON(common.ResponseHTTP{
                        Success: false,
                        Message: err.Error(),
                        Data:    nil,
                })
        }</span>

        // then validate structure
        <span class="cov8" title="1">if err := validate.Struct(posted_page); err != nil </span><span class="cov0" title="0">{
                return contx.Status(http.StatusBadRequest).JSON(common.ResponseHTTP{
                        Success: false,
                        Message: err.Error(),
                        Data:    nil,
                })
        }</span>

        //  initiate -&gt; page
        <span class="cov8" title="1">page := new(models.Page)
        page.Name = posted_page.Name
        page.Description = posted_page.Description

        //  start transaction to database
        tx := db.WithContext(tracer.Tracer).Begin()

        // add  data using transaction if values are valid
        if err := tx.Create(&amp;page).Error; err != nil </span><span class="cov8" title="1">{
                tx.Rollback()
                return contx.Status(http.StatusInternalServerError).JSON(common.ResponseHTTP{
                        Success: false,
                        Message: "Page Creation Failed",
                        Data:    err,
                })
        }</span>

        // close transaction
        <span class="cov8" title="1">tx.Commit()

        // return data if transaction is sucessfull
        return contx.Status(http.StatusOK).JSON(common.ResponseHTTP{
                Success: true,
                Message: "Page created successfully.",
                Data:    page,
        })</span>
}

// Patch Page to data
// @Summary Patch Page
// @Description Patch Page
// @Tags Pages
// @Security ApiKeyAuth
// @Accept json
// @Produce json
// @Param page body models.PagePost true "Patch Page"
// @Param page_id path int true "Page ID"
// @Success 200 {object} common.ResponseHTTP{data=models.PagePost}
// @Failure 400 {object} common.ResponseHTTP{}
// @Failure 500 {object} common.ResponseHTTP{}
// @Router /page/{page_id} [patch]
func PatchPage(contx *fiber.Ctx) error <span class="cov8" title="1">{

        // Starting tracer context and tracer
        ctx := contx.Locals("tracer")
        tracer, _ := ctx.(*observe.RouteTracer)

        // Get database connection
        db, _ := contx.Locals("db").(*gorm.DB)

        //  initialize data validator
        validate := validator.New()

        // validate path params
        id, err := strconv.Atoi(contx.Params("page_id"))
        if err != nil </span><span class="cov8" title="1">{
                return contx.Status(http.StatusBadRequest).JSON(common.ResponseHTTP{
                        Success: false,
                        Message: err.Error(),
                        Data:    nil,
                })
        }</span>

        // validate data struct
        <span class="cov8" title="1">patch_page := new(models.PagePatch)
        if err := contx.BodyParser(&amp;patch_page); err != nil </span><span class="cov0" title="0">{
                return contx.Status(http.StatusBadRequest).JSON(common.ResponseHTTP{
                        Success: false,
                        Message: err.Error(),
                        Data:    nil,
                })
        }</span>

        // then validating
        <span class="cov8" title="1">if err := validate.Struct(patch_page); err != nil </span><span class="cov0" title="0">{
                return contx.Status(http.StatusBadRequest).JSON(common.ResponseHTTP{
                        Success: false,
                        Message: err.Error(),
                        Data:    nil,
                })
        }</span>

        // startng update transaction
        <span class="cov8" title="1">var page models.Page
        tx := db.WithContext(tracer.Tracer).Begin()
        // Check if the record exists
        if err := db.WithContext(tracer.Tracer).Where("id = ?", id).First(&amp;page).Error; err != nil </span><span class="cov8" title="1">{
                // If the record doesn't exist, return an error response
                tx.Rollback()
                return contx.Status(http.StatusNotFound).JSON(common.ResponseHTTP{
                        Success: false,
                        Message: err.Error(),
                        Data:    nil,
                })
        }</span>

        // Update the record
        <span class="cov8" title="1">if err := db.WithContext(tracer.Tracer).Model(&amp;page).UpdateColumns(*patch_page).Error; err != nil </span><span class="cov0" title="0">{
                tx.Rollback()
                return contx.Status(http.StatusInternalServerError).JSON(common.ResponseHTTP{
                        Success: false,
                        Message: err.Error(),
                        Data:    nil,
                })
        }</span>

        // Return  success response
        <span class="cov8" title="1">return contx.Status(http.StatusOK).JSON(common.ResponseHTTP{
                Success: true,
                Message: "Page updated successfully.",
                Data:    page,
        })</span>
}

// DeletePages function removes a page by ID
// @Summary Remove Page by ID
// @Description Remove page by ID
// @Tags Pages
// @Security ApiKeyAuth
// @Accept json
// @Produce json
// @Param page_id path int true "Page ID"
// @Success 200 {object} common.ResponseHTTP{}
// @Failure 404 {object} common.ResponseHTTP{}
// @Failure 503 {object} common.ResponseHTTP{}
// @Router /page/{page_id} [delete]
func DeletePage(contx *fiber.Ctx) error <span class="cov8" title="1">{

        // Starting tracer context and tracer
        ctx := contx.Locals("tracer")
        tracer, _ := ctx.(*observe.RouteTracer)

        // Getting Database connection
        db, _ := contx.Locals("db").(*gorm.DB)

        // get deleted page attributes to return
        var page models.Page

        // validate path params
        id, err := strconv.Atoi(contx.Params("page_id"))
        if err != nil </span><span class="cov8" title="1">{
                return contx.Status(http.StatusBadRequest).JSON(common.ResponseHTTP{
                        Success: false,
                        Message: err.Error(),
                        Data:    nil,
                })
        }</span>

        // perform delete operation if the object exists
        <span class="cov8" title="1">tx := db.WithContext(tracer.Tracer).Begin()

        // first getting page and checking if it exists
        if err := db.Where("id = ?", id).First(&amp;page).Error; err != nil </span><span class="cov8" title="1">{
                tx.Rollback()
                return contx.Status(http.StatusNotFound).JSON(common.ResponseHTTP{
                        Success: false,
                        Message: err.Error(),
                        Data:    nil,
                })

        }</span>

        // Delete the page
        <span class="cov8" title="1">if err := db.Delete(&amp;page).Error; err != nil </span><span class="cov0" title="0">{
                tx.Rollback()
                return contx.Status(http.StatusInternalServerError).JSON(common.ResponseHTTP{
                        Success: false,
                        Message: "Error deleting page",
                        Data:    nil,
                })
        }</span>

        // Commit the transaction
        <span class="cov8" title="1">tx.Commit()

        // Return success respons
        return contx.Status(http.StatusOK).JSON(common.ResponseHTTP{
                Success: true,
                Message: "Page deleted successfully.",
                Data:    page,
        })</span>
}

// ################################################################
// Relationship Based Endpoints
// ################################################################

// Add Role to Page
// @Summary Add Page to Role
// @Description Add Role Page
// @Tags RolePages
// @Security ApiKeyAuth
// @Accept json
// @Produce json
// @Param role_id path int true "Role ID"
// @Param page_id path int true "Page ID"
// @Failure 400 {object} common.ResponseHTTP{}
// @Router /rolepage/{role_id}/{page_id} [post]
func AddRolePages(contx *fiber.Ctx) error <span class="cov0" title="0">{

        // Starting tracer context and tracer
        ctx := contx.Locals("tracer")
        tracer, _ := ctx.(*observe.RouteTracer)

        // database connection
        db, _ := contx.Locals("db").(*gorm.DB)

        // validate path params
        role_id, err := strconv.Atoi(contx.Params("role_id"))
        if err != nil </span><span class="cov0" title="0">{
                return contx.Status(http.StatusBadRequest).JSON(common.ResponseHTTP{
                        Success: false,
                        Message: err.Error(),
                        Data:    nil,
                })
        }</span>

        // validate path params
        <span class="cov0" title="0">page_id, err := strconv.Atoi(contx.Params("page_id"))
        if err != nil </span><span class="cov0" title="0">{
                return contx.Status(http.StatusBadRequest).JSON(common.ResponseHTTP{
                        Success: false,
                        Message: err.Error(),
                        Data:    nil,
                })
        }</span>

        // fetching page to be added
        <span class="cov0" title="0">var page models.Page
        if res := db.WithContext(tracer.Tracer).Where("id = ?", page_id).First(&amp;page); res.Error != nil </span><span class="cov0" title="0">{
                return contx.Status(http.StatusServiceUnavailable).JSON(common.ResponseHTTP{
                        Success: false,
                        Message: res.Error.Error(),
                        Data:    nil,
                })
        }</span>

        //  pageending assocation
        <span class="cov0" title="0">var role models.Role
        if err := db.WithContext(tracer.Tracer).Where("ID = ? ", role_id).First(&amp;role); err.Error != nil </span><span class="cov0" title="0">{
                return contx.Status(http.StatusNotFound).JSON(common.ResponseHTTP{
                        Success: false,
                        Message: "Record not Found",
                        Data:    err.Error.Error(),
                })
        }</span>

        <span class="cov0" title="0">tx := db.WithContext(tracer.Tracer).Begin()
        if err := db.WithContext(tracer.Tracer).Model(&amp;role).Association("Pages").Append(&amp;page); err != nil </span><span class="cov0" title="0">{
                tx.Rollback()
                return contx.Status(http.StatusNotFound).JSON(common.ResponseHTTP{
                        Success: false,
                        Message: "Pageending Page Failed",
                        Data:    err.Error(),
                })
        }</span>
        <span class="cov0" title="0">tx.Commit()

        // return value if transaction is sucessfull
        return contx.Status(http.StatusOK).JSON(common.ResponseHTTP{
                Success: true,
                Message: "Success Creating a page Role.",
                Data:    page,
        })</span>
}

// Delete Page to Role
// @Summary Add Page
// @Description Delete Role Page
// @Tags Roles
// @Security ApiKeyAuth
// @Accept json
// @Produce json
// @Param role_id path int true "Role ID"
// @Param page_id path int true "Page ID"
// @Success 200 {object} common.ResponseHTTP{data=models.PagePost}
// @Failure 400 {object} common.ResponseHTTP{}
// @Failure 500 {object} common.ResponseHTTP{}
// @Router /rolepage/{role_id}/{page_id} [delete]
func DeleteRolePages(contx *fiber.Ctx) error <span class="cov0" title="0">{

        // Starting tracer context and tracer
        ctx := contx.Locals("tracer")
        tracer, _ := ctx.(*observe.RouteTracer)

        //Connect to Database
        db, _ := contx.Locals("db").(*gorm.DB)

        // validate path params
        role_id, err := strconv.Atoi(contx.Params("role_id"))
        if err != nil || role_id == 0 </span><span class="cov0" title="0">{
                return contx.Status(http.StatusBadRequest).JSON(common.ResponseHTTP{
                        Success: false,
                        Message: err.Error(),
                        Data:    nil,
                })
        }</span>

        <span class="cov0" title="0">page_id, err := strconv.Atoi(contx.Params("page_id"))
        if err != nil || page_id == 0 </span><span class="cov0" title="0">{
                return contx.Status(http.StatusBadRequest).JSON(common.ResponseHTTP{
                        Success: false,
                        Message: err.Error(),
                        Data:    nil,
                })
        }</span>
        // fetching page to be deleted
        <span class="cov0" title="0">var page models.Page
        if res := db.WithContext(tracer.Tracer).Where("id = ?", page_id).First(&amp;page); res.Error != nil </span><span class="cov0" title="0">{
                return contx.Status(http.StatusServiceUnavailable).JSON(common.ResponseHTTP{
                        Success: false,
                        Message: res.Error.Error(),
                        Data:    nil,
                })
        }</span>

        // fettchng role
        <span class="cov0" title="0">var role models.Role
        role.ID = uint(role_id)
        if err := db.WithContext(tracer.Tracer).Where("id = ?", role_id).First(&amp;role); err.Error != nil </span><span class="cov0" title="0">{
                return contx.Status(http.StatusNotFound).JSON(common.ResponseHTTP{
                        Success: false,
                        Message: "Record not Found",
                        Data:    err.Error.Error(),
                })
        }</span>

        // removing page
        <span class="cov0" title="0">tx := db.WithContext(tracer.Tracer).Begin()
        if err := db.WithContext(tracer.Tracer).Model(&amp;role).Association("Pages").Delete(&amp;page); err != nil </span><span class="cov0" title="0">{
                tx.Rollback()
                return contx.Status(http.StatusNonAuthoritativeInfo).JSON(common.ResponseHTTP{
                        Success: false,
                        Message: "Please Try Again Something Unexpected Hpageened",
                        Data:    err.Error(),
                })
        }</span>

        <span class="cov0" title="0">tx.Commit()

        // return value if transaction is sucessfull
        return contx.Status(http.StatusOK).JSON(common.ResponseHTTP{
                Success: true,
                Message: "Success Removing a page from role.",
                Data:    page,
        })</span>
}
</pre>
		
		<pre class="file" id="file15" style="display: none">package controllers

import (
        "net/http"
        "strconv"

        "blue-admin.com/common"
        "blue-admin.com/models"
        "blue-admin.com/observe"
        "github.com/go-playground/validator/v10"
        "github.com/gofiber/fiber/v2"
        "github.com/mitchellh/mapstructure"
        "gorm.io/gorm"
        "gorm.io/gorm/clause"
)

// GetRoleis a function to get a Roles by ID
// @Summary Get Roles
// @Description Get Roles
// @Tags Roles
// @Accept json
// @Produce json
// @Security ApiKeyAuth
// @Security Refresh
// @Param page query int true "page"
// @Param size query int true "page size"
// @Success 200 {object} common.ResponsePagination{data=[]models.RoleGet}
// @Failure 404 {object} common.ResponseHTTP{}
// @Router /role [get]
func GetRoles(contx *fiber.Ctx) error <span class="cov8" title="1">{

        //  Getting tracer context
        ctx := contx.Locals("tracer")
        tracer, _ := ctx.(*observe.RouteTracer)

        //  Getting Database connection
        db, _ := contx.Locals("db").(*gorm.DB)

        //  parsing Query Prameters
        Page, _ := strconv.Atoi(contx.Query("page"))
        Limit, _ := strconv.Atoi(contx.Query("size"))
        //  checking if query parameters  are correct
        if Page == 0 || Limit == 0 </span><span class="cov8" title="1">{
                return contx.Status(http.StatusBadRequest).JSON(common.ResponseHTTP{
                        Success: false,
                        Message: "Not Allowed, Bad request",
                        Data:    nil,
                })
        }</span>

        //  querying result with pagination using gorm function
        <span class="cov8" title="1">result, err := common.PaginationPureModel(db, models.Role{}, []models.Role{}, uint(Page), uint(Limit), tracer.Tracer)
        if err != nil </span><span class="cov0" title="0">{
                return contx.Status(http.StatusInternalServerError).JSON(common.ResponseHTTP{
                        Success: false,
                        Message: err.Error(),
                        Data:    nil,
                })
        }</span>

        // returning result if all the above completed successfully
        <span class="cov8" title="1">return contx.Status(http.StatusOK).JSON(result)</span>
}

// GetRoleByID is a function to get a Roles by ID
// @Summary Get Role by ID
// @Description Get role by ID
// @Tags Roles
// @Security ApiKeyAuth
// @Accept json
// @Produce json
// @Param role_id path int true "Role ID"
// @Success 200 {object} common.ResponseHTTP{data=models.RoleGet}
// @Failure 404 {object} common.ResponseHTTP{}
// @Router /role/{role_id} [get]
func GetRoleByID(contx *fiber.Ctx) error <span class="cov8" title="1">{

        // Starting tracer context and tracer
        ctx := contx.Locals("tracer")
        tracer, _ := ctx.(*observe.RouteTracer)

        //  Getting Database connection
        db, _ := contx.Locals("db").(*gorm.DB)

        //  parsing Query Prameters
        id, err := strconv.Atoi(contx.Params("role_id"))
        if err != nil </span><span class="cov0" title="0">{
                return contx.Status(http.StatusBadRequest).JSON(common.ResponseHTTP{
                        Success: false,
                        Message: err.Error(),
                        Data:    nil,
                })
        }</span>

        // Preparing and querying database using Gorm
        <span class="cov8" title="1">var roles_get models.RoleGet
        var roles models.Role
        if res := db.WithContext(tracer.Tracer).Model(&amp;models.Role{}).Preload(clause.Associations).Where("id = ?", id).First(&amp;roles); res.Error != nil </span><span class="cov8" title="1">{
                return contx.Status(http.StatusNotFound).JSON(common.ResponseHTTP{
                        Success: false,
                        Message: res.Error.Error(),
                        Data:    nil,
                })
        }</span>

        // filtering response data according to filtered defined struct
        <span class="cov8" title="1">mapstructure.Decode(roles, &amp;roles_get)

        //  Finally returing response if All the above compeleted successfully
        return contx.Status(http.StatusOK).JSON(common.ResponseHTTP{
                Success: true,
                Message: "Success got one role.",
                Data:    &amp;roles_get,
        })</span>
}

type RoleDropDown struct {
        ID   uint   `validate:"required" json:"id"`
        Name string `validate:"required" json:"name"`
}

// Get Roles Dropdown only active roles
// @Summary Get RoleDropDown
// @Description Get RoleDropDown
// @Tags Role
// @Security ApiKeyAuth
// @Accept json
// @Produce json
// @Success 200 {object} common.ResponseHTTP{data=[]RoleDropDown}
// @Failure 404 {object} common.ResponseHTTP{}
// @Router /droproles [get]
func GetDropDownRoles(contx *fiber.Ctx) error <span class="cov0" title="0">{

        //  Getting tracer context
        ctx := contx.Locals("tracer")
        tracer, _ := ctx.(*observe.RouteTracer)

        //  Getting Database connection
        db, _ := contx.Locals("db").(*gorm.DB)

        var roles_drop []RoleDropDown
        if res := db.WithContext(tracer.Tracer).Model(&amp;models.Role{}).Where("active = ?", true).Find(&amp;roles_drop); res.Error != nil </span><span class="cov0" title="0">{
                return contx.Status(http.StatusServiceUnavailable).JSON(common.ResponseHTTP{
                        Success: false,
                        Message: res.Error.Error(),
                        Data:    nil,
                })
        }</span>

        <span class="cov0" title="0">return contx.Status(http.StatusOK).JSON(common.ResponseHTTP{
                Success: true,
                Message: "Success got one role.",
                Data:    &amp;roles_drop,
        })</span>
}

// Add Role to data
// @Summary Add a new Role
// @Description Add Role
// @Tags Roles
// @Security ApiKeyAuth
// @Accept json
// @Produce json
// @Param role body models.RolePost true "Add Role"
// @Success 200 {object} common.ResponseHTTP{data=models.RolePost}
// @Failure 400 {object} common.ResponseHTTP{}
// @Failure 500 {object} common.ResponseHTTP{}
// @Router /role [post]
func PostRole(contx *fiber.Ctx) error <span class="cov8" title="1">{

        // Starting tracer context and tracer
        ctx := contx.Locals("tracer")
        tracer, _ := ctx.(*observe.RouteTracer)

        // Getting Database Connection
        db, _ := contx.Locals("db").(*gorm.DB)

        // validator initialization
        validate := validator.New()

        //validating post data
        posted_role := new(models.RolePost)

        //first parse request data
        if err := contx.BodyParser(&amp;posted_role); err != nil </span><span class="cov0" title="0">{
                return contx.Status(http.StatusBadRequest).JSON(common.ResponseHTTP{
                        Success: false,
                        Message: err.Error(),
                        Data:    nil,
                })
        }</span>

        // then validate structure
        <span class="cov8" title="1">if err := validate.Struct(posted_role); err != nil </span><span class="cov8" title="1">{
                return contx.Status(http.StatusBadRequest).JSON(common.ResponseHTTP{
                        Success: false,
                        Message: err.Error(),
                        Data:    nil,
                })
        }</span>

        //  initiate -&gt; role
        <span class="cov8" title="1">role := new(models.Role)
        role.Name = posted_role.Name
        role.Description = posted_role.Description

        //  start transaction to database
        tx := db.WithContext(tracer.Tracer).Begin()

        // add  data using transaction if values are valid
        if err := tx.Create(&amp;role).Error; err != nil </span><span class="cov8" title="1">{
                tx.Rollback()
                return contx.Status(http.StatusInternalServerError).JSON(common.ResponseHTTP{
                        Success: false,
                        Message: "Role Creation Failed",
                        Data:    err,
                })
        }</span>

        // close transaction
        <span class="cov8" title="1">tx.Commit()

        // return data if transaction is sucessfull
        return contx.Status(http.StatusOK).JSON(common.ResponseHTTP{
                Success: true,
                Message: "Role created successfully.",
                Data:    role,
        })</span>
}

// Patch Role to data
// @Summary Patch Role
// @Description Patch Role
// @Tags Roles
// @Security ApiKeyAuth
// @Accept json
// @Produce json
// @Param role body models.RolePost true "Patch Role"
// @Param role_id path int true "Role ID"
// @Success 200 {object} common.ResponseHTTP{data=models.RolePost}
// @Failure 400 {object} common.ResponseHTTP{}
// @Failure 500 {object} common.ResponseHTTP{}
// @Router /role/{role_id} [patch]
func PatchRole(contx *fiber.Ctx) error <span class="cov8" title="1">{

        // Starting tracer context and tracer
        ctx := contx.Locals("tracer")
        tracer, _ := ctx.(*observe.RouteTracer)

        // Get database connection
        db, _ := contx.Locals("db").(*gorm.DB)

        //  initialize data validator
        validate := validator.New()

        // validate path params
        id, err := strconv.Atoi(contx.Params("role_id"))
        if err != nil </span><span class="cov8" title="1">{
                return contx.Status(http.StatusBadRequest).JSON(common.ResponseHTTP{
                        Success: false,
                        Message: err.Error(),
                        Data:    nil,
                })
        }</span>

        // validate data struct
        <span class="cov8" title="1">patch_role := new(models.RolePatch)
        if err := contx.BodyParser(&amp;patch_role); err != nil </span><span class="cov0" title="0">{
                return contx.Status(http.StatusBadRequest).JSON(common.ResponseHTTP{
                        Success: false,
                        Message: err.Error(),
                        Data:    nil,
                })
        }</span>

        // then validating
        <span class="cov8" title="1">if err := validate.Struct(patch_role); err != nil </span><span class="cov0" title="0">{
                return contx.Status(http.StatusBadRequest).JSON(common.ResponseHTTP{
                        Success: false,
                        Message: err.Error(),
                        Data:    nil,
                })
        }</span>

        // startng update transaction
        <span class="cov8" title="1">var role models.Role
        role.ID = uint(id)
        tx := db.WithContext(tracer.Tracer).Begin()

        // Check if the record exists
        if err := db.WithContext(tracer.Tracer).First(&amp;role, role.ID).Error; err != nil </span><span class="cov8" title="1">{
                tx.Rollback()
                return contx.Status(http.StatusNotFound).JSON(common.ResponseHTTP{
                        Success: false,
                        Message: err.Error(),
                        Data:    nil,
                })
        }</span>

        // Update the record
        <span class="cov8" title="1">if err := db.WithContext(tracer.Tracer).Model(&amp;role).UpdateColumns(*patch_role).Error; err != nil </span><span class="cov0" title="0">{
                tx.Rollback()
                return contx.Status(http.StatusInternalServerError).JSON(common.ResponseHTTP{
                        Success: false,
                        Message: err.Error(),
                        Data:    nil,
                })
        }</span>

        // Return  success response
        <span class="cov8" title="1">return contx.Status(http.StatusOK).JSON(common.ResponseHTTP{
                Success: true,
                Message: "Role updated successfully.",
                Data:    role,
        })</span>
}

// DeleteRoles function removes a role by ID
// @Summary Remove Role by ID
// @Description Remove role by ID
// @Tags Roles
// @Security ApiKeyAuth
// @Accept json
// @Produce json
// @Param role_id path int true "Role ID"
// @Success 200 {object} common.ResponseHTTP{}
// @Failure 404 {object} common.ResponseHTTP{}
// @Failure 503 {object} common.ResponseHTTP{}
// @Router /role/{role_id} [delete]
func DeleteRole(contx *fiber.Ctx) error <span class="cov8" title="1">{

        // Starting tracer context and tracer
        ctx := contx.Locals("tracer")
        tracer, _ := ctx.(*observe.RouteTracer)

        // Getting Database connection
        db, _ := contx.Locals("db").(*gorm.DB)

        // get deleted role attributes to return
        var role models.Role

        // validate path params
        id, err := strconv.Atoi(contx.Params("role_id"))
        if err != nil </span><span class="cov8" title="1">{
                return contx.Status(http.StatusBadRequest).JSON(common.ResponseHTTP{
                        Success: false,
                        Message: err.Error(),
                        Data:    nil,
                })
        }</span>

        // perform delete operation if the object exists
        <span class="cov8" title="1">tx := db.WithContext(tracer.Tracer).Begin()

        // first getting role and checking if it exists
        if err := db.WithContext(tracer.Tracer).Where("id = ?", id).First(&amp;role).Error; err != nil </span><span class="cov8" title="1">{
                tx.Rollback()
                return contx.Status(http.StatusNotFound).JSON(common.ResponseHTTP{
                        Success: false,
                        Message: err.Error(),
                        Data:    nil,
                })

        }</span>

        // Delete the role
        <span class="cov8" title="1">if err := db.WithContext(tracer.Tracer).Delete(&amp;role).Error; err != nil </span><span class="cov0" title="0">{
                tx.Rollback()
                return contx.Status(http.StatusInternalServerError).JSON(common.ResponseHTTP{
                        Success: false,
                        Message: "Error deleting role",
                        Data:    nil,
                })
        }</span>

        // Commit the transaction
        <span class="cov8" title="1">tx.Commit()

        // Return success respons
        return contx.Status(http.StatusOK).JSON(common.ResponseHTTP{
                Success: true,
                Message: "Role deleted successfully.",
                Data:    role,
        })</span>
}

// ################################################################
// Relationship Based Endpoints
// ################################################################

// Add User to Role
// @Summary Add Role to User
// @Description Add User Role
// @Tags UserRoles
// @Security ApiKeyAuth
// @Accept json
// @Produce json
// @Param user_id path int true "User ID"
// @Param role_id path int true "Role ID"
// @Failure 400 {object} common.ResponseHTTP{}
// @Router /userrole/{user_id}/{role_id} [post]
func AddUserRoles(contx *fiber.Ctx) error <span class="cov0" title="0">{

        // Starting tracer context and tracer
        ctx := contx.Locals("tracer")
        tracer, _ := ctx.(*observe.RouteTracer)

        // database connection
        db, _ := contx.Locals("db").(*gorm.DB)

        // validate path params
        user_id, err := strconv.Atoi(contx.Params("user_id"))
        if err != nil </span><span class="cov0" title="0">{
                return contx.Status(http.StatusBadRequest).JSON(common.ResponseHTTP{
                        Success: false,
                        Message: err.Error(),
                        Data:    nil,
                })
        }</span>

        // validate path params
        <span class="cov0" title="0">role_id, err := strconv.Atoi(contx.Params("role_id"))
        if err != nil </span><span class="cov0" title="0">{
                return contx.Status(http.StatusBadRequest).JSON(common.ResponseHTTP{
                        Success: false,
                        Message: err.Error(),
                        Data:    nil,
                })
        }</span>

        // fetching role to be added
        <span class="cov0" title="0">var role models.Role
        if res := db.WithContext(tracer.Tracer).Where("id = ?", role_id).First(&amp;role); res.Error != nil </span><span class="cov0" title="0">{
                return contx.Status(http.StatusNotFound).JSON(common.ResponseHTTP{
                        Success: false,
                        Message: res.Error.Error(),
                        Data:    nil,
                })
        }</span>

        //  roleending assocation
        <span class="cov0" title="0">var user models.User
        if err := db.WithContext(tracer.Tracer).Where("id = ?", user_id).First(&amp;user); err.Error != nil </span><span class="cov0" title="0">{
                return contx.Status(http.StatusNotFound).JSON(common.ResponseHTTP{
                        Success: false,
                        Message: "Record not Found",
                        Data:    err.Error.Error(),
                })
        }</span>

        <span class="cov0" title="0">tx := db.WithContext(tracer.Tracer).Begin()
        if err := db.WithContext(tracer.Tracer).Model(&amp;user).Association("Roles").Append(&amp;role); err != nil </span><span class="cov0" title="0">{
                tx.Rollback()
                return contx.Status(http.StatusNotFound).JSON(common.ResponseHTTP{
                        Success: false,
                        Message: "Adding Role Failed",
                        Data:    err.Error(),
                })
        }</span>
        <span class="cov0" title="0">tx.Commit()

        // return value if transaction is sucessfull
        return contx.Status(http.StatusOK).JSON(common.ResponseHTTP{
                Success: true,
                Message: "Success Creating a role User.",
                Data:    role,
        })</span>
}

// Delete Role to User
// @Summary Add Role
// @Description Delete User Role
// @Tags Users
// @Security ApiKeyAuth
// @Accept json
// @Produce json
// @Param user_id path int true "User ID"
// @Param role_id path int true "Role ID"
// @Success 200 {object} common.ResponseHTTP{data=models.RolePost}
// @Failure 400 {object} common.ResponseHTTP{}
// @Failure 500 {object} common.ResponseHTTP{}
// @Router /userrole/{user_id}/{role_id} [delete]
func DeleteUserRoles(contx *fiber.Ctx) error <span class="cov0" title="0">{

        // Starting tracer context and tracer
        ctx := contx.Locals("tracer")
        tracer, _ := ctx.(*observe.RouteTracer)

        //Connect to Database
        db, _ := contx.Locals("db").(*gorm.DB)

        // validate path params
        user_id, err := strconv.Atoi(contx.Params("user_id"))
        if err != nil || user_id == 0 </span><span class="cov0" title="0">{
                return contx.Status(http.StatusBadRequest).JSON(common.ResponseHTTP{
                        Success: false,
                        Message: err.Error(),
                        Data:    nil,
                })
        }</span>

        <span class="cov0" title="0">role_id, err := strconv.Atoi(contx.Params("role_id"))
        if err != nil || role_id == 0 </span><span class="cov0" title="0">{
                return contx.Status(http.StatusBadRequest).JSON(common.ResponseHTTP{
                        Success: false,
                        Message: err.Error(),
                        Data:    nil,
                })
        }</span>
        // fetching role to be deleted
        <span class="cov0" title="0">var role models.Role
        if res := db.WithContext(tracer.Tracer).Where("id = ?", role_id).First(&amp;role); res.Error != nil </span><span class="cov0" title="0">{
                return contx.Status(http.StatusNotFound).JSON(common.ResponseHTTP{
                        Success: false,
                        Message: res.Error.Error(),
                        Data:    nil,
                })
        }</span>

        // fettchng user
        <span class="cov0" title="0">var user models.User
        if err := db.WithContext(tracer.Tracer).Where("id = ?", user_id).First(&amp;user); err.Error != nil </span><span class="cov0" title="0">{
                return contx.Status(http.StatusNotFound).JSON(common.ResponseHTTP{
                        Success: false,
                        Message: err.Error.Error(),
                        Data:    nil,
                })
        }</span>

        // removing role
        <span class="cov0" title="0">tx := db.WithContext(tracer.Tracer).Begin()
        if err := db.WithContext(tracer.Tracer).Model(&amp;user).Association("Roles").Delete(&amp;role); err != nil </span><span class="cov0" title="0">{
                tx.Rollback()
                return contx.Status(http.StatusNonAuthoritativeInfo).JSON(common.ResponseHTTP{
                        Success: false,
                        Message: "Please Try Again Something Unexpected Hroleened",
                        Data:    err.Error(),
                })
        }</span>

        <span class="cov0" title="0">tx.Commit()

        // return value if transaction is sucessfull
        return contx.Status(http.StatusOK).JSON(common.ResponseHTTP{
                Success: true,
                Message: "Success Removing a role from user.",
                Data:    role,
        })</span>
}

// Add Role Feature
// @Summary Add Role to Feature
// @Description Add Role to Feature
// @Tags Roles
// @Security ApiKeyAuth
// @Accept json
// @Produce json
// @Param feature_id path int true "Feature ID"
// @Param role_id query int true " Role ID"
// @Failure 400 {object} common.ResponseHTTP{}
// @Router /featurerole/{feature_id} [patch]
func AddFeatureRoles(contx *fiber.Ctx) error <span class="cov0" title="0">{

        // Starting tracer context and tracer
        ctx := contx.Locals("tracer")
        tracer, _ := ctx.(*observe.RouteTracer)

        // connect
        db, _ := contx.Locals("db").(*gorm.DB)

        // validate path params
        feature_id, err := strconv.Atoi(contx.Params("feature_id"))
        if err != nil </span><span class="cov0" title="0">{
                return contx.Status(http.StatusBadRequest).JSON(common.ResponseHTTP{
                        Success: false,
                        Message: err.Error(),
                        Data:    nil,
                })
        }</span>

        // fetching Endpionts
        <span class="cov0" title="0">var feature models.Feature
        if res := db.WithContext(tracer.Tracer).Model(&amp;models.Feature{}).Where("id = ?", feature_id).First(&amp;feature); res.Error != nil </span><span class="cov0" title="0">{
                return contx.Status(http.StatusServiceUnavailable).JSON(common.ResponseHTTP{
                        Success: false,
                        Message: res.Error.Error(),
                        Data:    nil,
                })
        }</span>

        // fetching feature to be added
        <span class="cov0" title="0">role_id, _ := strconv.Atoi(contx.Query("role_id"))
        var role models.Role
        if res := db.WithContext(tracer.Tracer).Model(&amp;models.Role{}).Where("id = ?", role_id).First(&amp;role); res.Error != nil </span><span class="cov0" title="0">{
                return contx.Status(http.StatusServiceUnavailable).JSON(common.ResponseHTTP{
                        Success: false,
                        Message: res.Error.Error(),
                        Data:    nil,
                })
        }</span>

        // startng update transaction

        <span class="cov0" title="0">tx := db.WithContext(tracer.Tracer).Begin()
        //  Adding one to many Relation
        if err := db.WithContext(tracer.Tracer).Model(&amp;role).Association("Features").Append(&amp;feature); err != nil </span><span class="cov0" title="0">{
                tx.Rollback()
                return contx.Status(http.StatusNotFound).JSON(common.ResponseHTTP{
                        Success: false,
                        Message: "Error Adding Record",
                        Data:    err.Error(),
                })
        }</span>
        <span class="cov0" title="0">tx.Commit()

        // return value if transaction is sucessfull
        return contx.Status(http.StatusOK).JSON(common.ResponseHTTP{
                Success: true,
                Message: "Success Adding a Feature to Role.",
                Data:    role,
        })</span>
}

// Delete Role Feature
// @Summary Delete Role Feature
// @Description Delete Role Feature
// @Tags Roles
// @Security ApiKeyAuth
// @Accept json
// @Produce json
// @Param feature_id path int true "Role ID"
// @Param role_id query int true "Feature ID"
// @Failure 400 {object} common.ResponseHTTP{}
// @Router /featurerole/{feature_id} [delete]
func DeleteFeatureRoles(contx *fiber.Ctx) error <span class="cov0" title="0">{

        // Starting tracer context and tracer
        ctx := contx.Locals("tracer")
        tracer, _ := ctx.(*observe.RouteTracer)

        //  database connection
        db, _ := contx.Locals("db").(*gorm.DB)

        // validate path params
        feature_id, err := strconv.Atoi(contx.Params("feature_id"))
        if err != nil </span><span class="cov0" title="0">{
                return contx.Status(http.StatusBadRequest).JSON(common.ResponseHTTP{
                        Success: false,
                        Message: err.Error(),
                        Data:    nil,
                })
        }</span>

        // Getting Feature
        <span class="cov0" title="0">var feature models.Feature
        if res := db.WithContext(tracer.Tracer).Model(&amp;models.Feature{}).Where("id = ?", feature_id).First(&amp;feature); res.Error != nil </span><span class="cov0" title="0">{
                return contx.Status(http.StatusServiceUnavailable).JSON(common.ResponseHTTP{
                        Success: false,
                        Message: res.Error.Error(),
                        Data:    nil,
                })
        }</span>

        // fetching role to be added
        <span class="cov0" title="0">var role models.Role
        role_id, _ := strconv.Atoi(contx.Query("role_id"))
        if res := db.WithContext(tracer.Tracer).Model(&amp;models.Role{}).Where("id = ?", role_id).First(&amp;role); res.Error != nil </span><span class="cov0" title="0">{
                return contx.Status(http.StatusServiceUnavailable).JSON(common.ResponseHTTP{
                        Success: false,
                        Message: res.Error.Error(),
                        Data:    nil,
                })
        }</span>

        // Removing Feature From Role
        <span class="cov0" title="0">tx := db.WithContext(tracer.Tracer).Begin()
        if err := db.WithContext(tracer.Tracer).Model(&amp;role).Association("Features").Delete(&amp;feature); err != nil </span><span class="cov0" title="0">{
                tx.Rollback()
                return contx.Status(http.StatusNotFound).JSON(common.ResponseHTTP{
                        Success: false,
                        Message: "Record not Found",
                        Data:    err.Error(),
                })
        }</span>
        <span class="cov0" title="0">tx.Commit()

        // return value if transaction is sucessfull
        return contx.Status(http.StatusOK).JSON(common.ResponseHTTP{
                Success: true,
                Message: "Success Deleteing a Feature From Role.",
                Data:    role,
        })</span>
}

// Activate/Deactivate Role to data
// @Summary Activate/Deactivate
// @Description Activate/Deactivate
// @Tags Role
// @Security ApiKeyAuth
// @Accept json
// @Produce json
// @Param role_id path int true "Role ID"
// @Param active query bool true "Active"
// @Success 200 {object} common.ResponseHTTP{data=models.RolePost}
// @Failure 400 {object} common.ResponseHTTP{}
// @Router /role/{role_id} [put]
func ActivateDeactivateRoles(contx *fiber.Ctx) error <span class="cov0" title="0">{
        //  Getting tracer context
        ctx := contx.Locals("tracer")
        tracer, _ := ctx.(*observe.RouteTracer)

        //  Getting Database connection
        db, _ := contx.Locals("db").(*gorm.DB)

        // validate path params
        id, err := strconv.Atoi(contx.Params("role_id"))
        if err != nil </span><span class="cov0" title="0">{
                return contx.Status(http.StatusBadRequest).JSON(common.ResponseHTTP{
                        Success: false,
                        Message: err.Error(),
                        Data:    nil,
                })
        }</span>
        //  Get qurery Parm
        <span class="cov0" title="0">active := contx.QueryBool("active")
        // startng update transaction
        var role models.Role
        tx := db.WithContext(tracer.Tracer).Begin()
        if err := db.WithContext(tracer.Tracer).Where("id = ? ", id).First(&amp;role).Error; err != nil </span><span class="cov0" title="0">{
                tx.Rollback()
                return contx.Status(http.StatusNotFound).JSON(common.ResponseHTTP{
                        Success: false,
                        Message: "Record not Found",
                        Data:    err,
                })
        }</span>
        <span class="cov0" title="0">db.WithContext(tracer.Tracer).Model(&amp;role).Update("active", active)
        tx.Commit()

        if role.ID != 0 </span><span class="cov0" title="0">{
                role.Active = active
                // return value if transaction is sucessfull
                return contx.Status(http.StatusOK).JSON(common.ResponseHTTP{
                        Success: true,
                        Message: "Success Updating a role.",
                        Data:    role,
                })
        }</span>

        <span class="cov0" title="0">return contx.Status(http.StatusBadRequest).JSON(common.ResponseHTTP{
                Success: false,
                Message: "No Record Found",
                Data:    nil,
        })</span>
}

type EndpiontsRoles struct {
        ID   uint   `json:"id,omitempty"`
        Name string `json:"name,omitempty"`
}

// GetRole EndPoints By ID is a function to get a Roles by ID
// @Summary Get EndPoints Role by ID
// @Description Get role EndPoints by ID
// @Tags Role
// @Security ApiKeyAuth
// @Accept json
// @Produce json
// @Param role_id query int true "Role ID"
// @Success 200 {object} common.ResponseHTTP{data=[]models.EndpointGet}
// @Failure 404 {object} common.ResponseHTTP{}
// @Router /role_endpoints [get]
func GetRoleEndpointsID(contx *fiber.Ctx) error <span class="cov0" title="0">{
        //  Getting tracer context
        ctx := contx.Locals("tracer")
        tracer, _ := ctx.(*observe.RouteTracer)

        //  Getting Database connection
        db, _ := contx.Locals("db").(*gorm.DB)

        role_id := contx.QueryInt("role_id")
        var endpoints []EndpiontsRoles
        var roles models.Role
        if res := db.WithContext(tracer.Tracer).Model(&amp;models.Role{}).Preload(clause.Associations).Preload("Features.Endpoints").Preload(clause.Associations).Where("id = ?", role_id).First(&amp;roles); res.Error != nil </span><span class="cov0" title="0">{
                return contx.Status(http.StatusServiceUnavailable).JSON(common.ResponseHTTP{
                        Success: false,
                        Message: res.Error.Error(),
                        Data:    "nil",
                })
        }</span>

        <span class="cov0" title="0">for x := range roles.Features </span><span class="cov0" title="0">{
                if len(roles.Features[x].Endpoints) &gt; 0 </span><span class="cov0" title="0">{
                        for i := range roles.Features[x].Endpoints </span><span class="cov0" title="0">{
                                resp_endpoint := EndpiontsRoles{ID: roles.Features[x].Endpoints[i].ID, Name: roles.Features[x].Endpoints[i].Name}
                                endpoints = append(endpoints, resp_endpoint)
                        }</span>
                }
        }

        <span class="cov0" title="0">return contx.Status(http.StatusOK).JSON(common.ResponseHTTP{
                Success: true,
                Message: "Success got one role.",
                Data:    &amp;endpoints,
        })</span>
}
</pre>
		
		<pre class="file" id="file16" style="display: none">package controllers

import (
        "net/http"
        "strconv"

        "blue-admin.com/common"
        "blue-admin.com/models"
        "blue-admin.com/observe"
        "blue-admin.com/utils"
        "github.com/go-playground/validator/v10"
        "github.com/gofiber/fiber/v2"
        "github.com/mitchellh/mapstructure"
        "gorm.io/gorm"
        "gorm.io/gorm/clause"
)

// GetUseris a function to get a Users by ID
// @Summary Get Users
// @Description Get Users
// @Tags Users
// @Accept json
// @Produce json
// @Security ApiKeyAuth
// @Security Refresh
// @Param page query int true "page"
// @Param size query int true "page size"
// @Success 200 {object} common.ResponsePagination{data=[]models.UserGet}
// @Failure 404 {object} common.ResponseHTTP{}
// @Router /user [get]
func GetUsers(contx *fiber.Ctx) error <span class="cov8" title="1">{

        //  Getting tracer context
        ctx := contx.Locals("tracer")
        tracer, _ := ctx.(*observe.RouteTracer)

        //  Getting Database connection
        db, _ := contx.Locals("db").(*gorm.DB)

        //  parsing Query Prameters
        Page, _ := strconv.Atoi(contx.Query("page"))
        Limit, _ := strconv.Atoi(contx.Query("size"))

        //  checking if query parameters  are correct
        if Page == 0 || Limit == 0 </span><span class="cov8" title="1">{
                return contx.Status(http.StatusBadRequest).JSON(common.ResponseHTTP{
                        Success: false,
                        Message: "Not Allowed, Bad request",
                        Data:    nil,
                })
        }</span>

        //  querying result with pagination using gorm function
        <span class="cov8" title="1">result, err := common.PaginationPureModel(db, models.User{}, []models.User{}, uint(Page), uint(Limit), tracer.Tracer)
        if err != nil </span><span class="cov0" title="0">{
                return contx.Status(http.StatusInternalServerError).JSON(common.ResponseHTTP{
                        Success: false,
                        Message: "Failed to get all User.",
                        Data:    "something",
                })
        }</span>

        // returning result if all the above completed successfully
        <span class="cov8" title="1">return contx.Status(http.StatusOK).JSON(result)</span>
}

// Get App Users a function to get app Users by ID
// @Summary Get App Users
// @Description Get App Users
// @Tags Users
// @Accept json
// @Produce json
// @Security ApiKeyAuth
// @Security Refresh
// @Param page query int true "page"
// @Param size query int true "page size"
// @Param app_uuid query string true "app uuid"
// @Success 200 {object} common.ResponsePagination{data=[]models.UserGet}
// @Failure 404 {object} common.ResponseHTTP{}
// @Router /appusers [get]
func GetAppUsers(contx *fiber.Ctx) error <span class="cov8" title="1">{

        //  Getting tracer context
        ctx := contx.Locals("tracer")
        tracer, _ := ctx.(*observe.RouteTracer)

        //  Getting Database connection
        db, _ := contx.Locals("db").(*gorm.DB)

        //  parsing Query Prameters
        Page, _ := strconv.Atoi(contx.Query("page"))
        Limit, _ := strconv.Atoi(contx.Query("size"))
        app_uuid := contx.Query("app_uuid")

        //  checking if query parameters  are correct
        if Page == 0 || Limit == 0 || app_uuid == "" </span><span class="cov8" title="1">{
                return contx.Status(http.StatusBadRequest).JSON(common.ResponseHTTP{
                        Success: false,
                        Message: "Not Allowed, Bad request",
                        Data:    nil,
                })
        }</span>

        //  querying result with pagination using gorm function
        // result, err := common.PaginationPureModel(db, models.User{}, []models.User{}, uint(Page), uint(Limit), tracer.Tracer)
        <span class="cov8" title="1">query_string := `SELECT DISTINCT u.email, u.uuid, u.id, a.uuid
                FROM users u
                INNER JOIN user_roles ur ON u.id = ur.user_id
                INNER JOIN roles r ON ur.role_id = r.id
                INNER JOIN apps a ON r.app_id = a.id
                WHERE a.uuid = ? limit ? offset ?;
                `
        var users []models.UserGet
        if res := db.WithContext(tracer.Tracer).Raw(query_string, app_uuid, Limit, Page-1).Scan(&amp;users); res.Error != nil </span><span class="cov0" title="0">{
                return contx.Status(http.StatusInternalServerError).JSON(common.ResponseHTTP{
                        Success: false,
                        Message: "Failed to get all User.",
                        Data:    "something",
                })
        }</span>

        // returning result if all the above completed successfully
        <span class="cov8" title="1">return contx.Status(http.StatusOK).JSON(common.ResponseHTTP{
                Success: true,
                Message: "sucess get all app Users.",
                Data:    users,
        })</span>
}

// GetUserByID is a function to get a Users by ID
// @Summary Get User by ID
// @Description Get user by ID
// @Tags Users
// @Security ApiKeyAuth
// @Accept json
// @Produce json
// @Param user_id path int true "User ID"
// @Success 200 {object} common.ResponseHTTP{data=models.UserGet}
// @Failure 404 {object} common.ResponseHTTP{}
// @Router /user/{user_id} [get]
func GetUserByID(contx *fiber.Ctx) error <span class="cov8" title="1">{

        // Starting tracer context and tracer
        ctx := contx.Locals("tracer")
        tracer, _ := ctx.(*observe.RouteTracer)

        //  Getting Database connection
        db, _ := contx.Locals("db").(*gorm.DB)

        //  parsing Query Prameters
        id, err := strconv.Atoi(contx.Params("user_id"))
        if err != nil </span><span class="cov0" title="0">{
                return contx.Status(http.StatusBadRequest).JSON(common.ResponseHTTP{
                        Success: false,
                        Message: err.Error(),
                        Data:    nil,
                })
        }</span>

        // Preparing and querying database using Gorm
        <span class="cov8" title="1">var users_get models.UserGet
        var users models.User
        if res := db.WithContext(tracer.Tracer).Model(&amp;models.User{}).Preload(clause.Associations).Where("id = ?", id).First(&amp;users); res.Error != nil </span><span class="cov8" title="1">{
                return contx.Status(http.StatusNotFound).JSON(common.ResponseHTTP{
                        Success: false,
                        Message: res.Error.Error(),
                        Data:    nil,
                })
        }</span>

        // filtering response data according to filtered defined struct
        <span class="cov8" title="1">mapstructure.Decode(users, &amp;users_get)

        //  Finally returing response if All the above compeleted successfully
        return contx.Status(http.StatusOK).JSON(common.ResponseHTTP{
                Success: true,
                Message: "Success got one user.",
                Data:    &amp;users_get,
        })</span>
}

// GetAppUserByID is a function to get a Users by ID
// @Summary Get App User by ID
// @Description Get App user by ID
// @Tags Users
// @Security ApiKeyAuth
// @Accept json
// @Produce json
// @Param user_id path int true "User ID"
// @Param app_uuid query string true "app uuid"
// @Success 200 {object} common.ResponseHTTP{data=models.UserGet}
// @Failure 404 {object} common.ResponseHTTP{}
// @Router /appuser/{user_id} [get]
func GetAppUserByID(contx *fiber.Ctx) error <span class="cov8" title="1">{

        // Starting tracer context and tracer
        ctx := contx.Locals("tracer")
        tracer, _ := ctx.(*observe.RouteTracer)

        //  Getting Database connection
        db, _ := contx.Locals("db").(*gorm.DB)

        //  parsing Query Prameters
        id, err := strconv.Atoi(contx.Params("user_id"))
        if err != nil </span><span class="cov8" title="1">{
                return contx.Status(http.StatusBadRequest).JSON(common.ResponseHTTP{
                        Success: false,
                        Message: err.Error(),
                        Data:    nil,
                })
        }</span>

        <span class="cov8" title="1">app_uuid := contx.Query("app_uuid")
        if app_uuid == "" </span><span class="cov0" title="0">{
                return contx.Status(http.StatusBadRequest).JSON(common.ResponseHTTP{
                        Success: false,
                        Message: "No provided app uuid",
                        Data:    nil,
                })
        }</span>

        // Preparing and querying database using Gorm
        <span class="cov8" title="1">var users_get models.UserGet
        query_string := `SELECT DISTINCT u.email, u.uuid, u.id, a.uuid
                        FROM users u
                        INNER JOIN user_roles ur ON u.id = ur.user_id
                        INNER JOIN roles r ON ur.role_id = r.id
                        INNER JOIN apps a ON r.app_id = a.id
                        WHERE a.uuid = ? AND u.id = ?;`

        if res := db.WithContext(tracer.Tracer).Raw(query_string, app_uuid, id).Scan(&amp;users_get); res.Error != nil </span><span class="cov0" title="0">{
                return contx.Status(http.StatusNotFound).JSON(common.ResponseHTTP{
                        Success: false,
                        Message: "Some thing happened",
                        Data:    nil,
                })
        }</span>

        //  Finally returing response if All the above compeleted successfully
        <span class="cov8" title="1">return contx.Status(http.StatusOK).JSON(common.ResponseHTTP{
                Success: true,
                Message: "Success got one user.",
                Data:    &amp;users_get,
        })</span>
}

// GetUserByUUID is a function to get a Users by UUID
// @Summary Get User by UUID
// @Description Get user by UUID
// @Tags Users
// @Security ApiKeyAuth
// @Accept json
// @Produce json
// @Param uuid query string true "User UUID"
// @Param app_uuid query string true "App UUID"
// @Success 200 {object} common.ResponseHTTP{data=models.UserNoRlnGet}
// @Failure 404 {object} common.ResponseHTTP{}
// @Router /useruuid [get]
func GetUserByUUID(contx *fiber.Ctx) error <span class="cov8" title="1">{

        // Starting tracer context and tracer
        ctx := contx.Locals("tracer")
        tracer, _ := ctx.(*observe.RouteTracer)

        //  Getting Database connection
        db, _ := contx.Locals("db").(*gorm.DB)

        //  parsing Query Prameters
        user_uuid := contx.Query("uuid")
        if user_uuid == "" </span><span class="cov8" title="1">{
                return contx.Status(http.StatusBadRequest).JSON(common.ResponseHTTP{
                        Success: false,
                        Message: "No User UUID provided",
                        Data:    nil,
                })
        }</span>

        //  parsing Query Prameters
        <span class="cov8" title="1">app_uuid := contx.Query("app_uuid")
        if app_uuid == "" </span><span class="cov8" title="1">{
                return contx.Status(http.StatusBadRequest).JSON(common.ResponseHTTP{
                        Success: false,
                        Message: "No App UUID provided",
                        Data:    nil,
                })
        }</span>

        // Preparing and querying database using Gorm
        <span class="cov8" title="1">var users_get models.UserNoRlnGet
        query_string := `SELECT DISTINCT u.email, u.uuid, u.id, a.uuid
                        FROM users u
                        INNER JOIN user_roles ur ON u.id = ur.user_id
                        INNER JOIN roles r ON ur.role_id = r.id
                        INNER JOIN apps a ON r.app_id = a.id
                        WHERE a.uuid = ? AND u.uuid = ?;`

        if res := db.WithContext(tracer.Tracer).Raw(query_string, app_uuid, user_uuid).Scan(&amp;users_get); res.Error != nil </span><span class="cov0" title="0">{
                return contx.Status(http.StatusInternalServerError).JSON(common.ResponseHTTP{
                        Success: false,
                        Message: res.Error.Error(),
                        Data:    nil,
                })
        }</span>

        //  Finally returing response if All the above compeleted successfully
        <span class="cov8" title="1">return contx.Status(http.StatusOK).JSON(common.ResponseHTTP{
                Success: true,
                Message: "Success got one user.",
                Data:    &amp;users_get,
        })</span>
}

// Add User to data
// @Summary Add a new User
// @Description Add User
// @Tags Users
// @Security ApiKeyAuth
// @Accept json
// @Produce json
// @Param user body models.UserPost true "Add User"
// @Success 200 {object} common.ResponseHTTP{data=models.UserPost}
// @Failure 400 {object} common.ResponseHTTP{}
// @Failure 500 {object} common.ResponseHTTP{}
// @Router /user [post]
func PostUser(contx *fiber.Ctx) error <span class="cov8" title="1">{
        // Starting tracer context and tracer
        ctx := contx.Locals("tracer")
        tracer, _ := ctx.(*observe.RouteTracer)

        // Getting Database Connection
        db, _ := contx.Locals("db").(*gorm.DB)

        // validator initialization
        validate := validator.New()

        //validating post data
        posted_user := new(models.UserPost)

        //first parse request data
        if err := contx.BodyParser(&amp;posted_user); err != nil </span><span class="cov0" title="0">{
                return contx.Status(http.StatusBadRequest).JSON(common.ResponseHTTP{
                        Success: false,
                        Message: err.Error(),
                        Data:    nil,
                })
        }</span>

        // then validate structure
        <span class="cov8" title="1">if err := validate.Struct(posted_user); err != nil </span><span class="cov0" title="0">{
                return contx.Status(http.StatusBadRequest).JSON(common.ResponseHTTP{
                        Success: false,
                        Message: err.Error(),
                        Data:    nil,
                })
        }</span>

        //  initiate -&gt; user
        <span class="cov8" title="1">user := new(models.User)
        user.Email = posted_user.Email
        user.Password = posted_user.Password
        //  start transaction to database
        tx := db.WithContext(tracer.Tracer).Begin()

        // add  data using transaction if values are valid
        if err := tx.Create(&amp;user).Error; err != nil </span><span class="cov8" title="1">{
                tx.Rollback()
                return contx.Status(http.StatusInternalServerError).JSON(common.ResponseHTTP{
                        Success: false,
                        Message: "User Creation Failed",
                        Data:    err,
                })
        }</span>

        // close transaction
        <span class="cov8" title="1">tx.Commit()

        var user_get models.UserGet
        mapstructure.Decode(user, &amp;user_get)

        // return data if transaction is sucessfull
        return contx.Status(http.StatusOK).JSON(common.ResponseHTTP{
                Success: true,
                Message: "User created successfully.",
                Data:    user_get,
        })</span>
}

// Patch User to data
// @Summary Patch User
// @Description Patch User
// @Tags Users
// @Security ApiKeyAuth
// @Accept json
// @Produce json
// @Param user body models.UserPost true "Patch User"
// @Param user_id path int true "User ID"
// @Success 200 {object} common.ResponseHTTP{data=models.UserPost}
// @Failure 400 {object} common.ResponseHTTP{}
// @Failure 500 {object} common.ResponseHTTP{}
// @Router /user/{user_id} [patch]
func PatchUser(contx *fiber.Ctx) error <span class="cov8" title="1">{

        // Starting tracer context and tracer
        ctx := contx.Locals("tracer")
        tracer, _ := ctx.(*observe.RouteTracer)

        // Get database connection
        db, _ := contx.Locals("db").(*gorm.DB)

        //  initialize data validator
        validate := validator.New()

        // validate path params
        id, err := strconv.Atoi(contx.Params("user_id"))
        if err != nil </span><span class="cov8" title="1">{
                return contx.Status(http.StatusBadRequest).JSON(common.ResponseHTTP{
                        Success: false,
                        Message: err.Error(),
                        Data:    nil,
                })
        }</span>

        // validate data struct
        <span class="cov8" title="1">patch_user := new(models.UserPatch)
        if err := contx.BodyParser(&amp;patch_user); err != nil </span><span class="cov0" title="0">{
                return contx.Status(http.StatusBadRequest).JSON(common.ResponseHTTP{
                        Success: false,
                        Message: err.Error(),
                        Data:    nil,
                })
        }</span>

        // then validating
        <span class="cov8" title="1">if err := validate.Struct(patch_user); err != nil </span><span class="cov0" title="0">{
                return contx.Status(http.StatusBadRequest).JSON(common.ResponseHTTP{
                        Success: false,
                        Message: err.Error(),
                        Data:    nil,
                })
        }</span>

        // startng update transaction
        <span class="cov8" title="1">var user models.User
        tx := db.WithContext(tracer.Tracer).Begin()
        if err := db.WithContext(tracer.Tracer).Where("id = ? ", id).First(&amp;user).Error; err != nil </span><span class="cov8" title="1">{
                tx.Rollback()
                return contx.Status(http.StatusNotFound).JSON(common.ResponseHTTP{
                        Success: false,
                        Message: err.Error(),
                        Data:    nil,
                })
        }</span>

        <span class="cov8" title="1">if err := db.WithContext(tracer.Tracer).Model(&amp;user).UpdateColumns(*patch_user).Error; err != nil </span><span class="cov0" title="0">{
                tx.Rollback()
                return contx.Status(http.StatusInternalServerError).JSON(common.ResponseHTTP{
                        Success: false,
                        Message: err.Error(),
                        Data:    nil,
                })
        }</span>

        // Return  success response
        <span class="cov8" title="1">return contx.Status(http.StatusOK).JSON(common.ResponseHTTP{
                Success: true,
                Message: "User updated successfully.",
                Data:    user,
        })</span>
}

// DeleteUsers function removes a user by ID
// @Summary Remove User by ID
// @Description Remove user by ID
// @Tags Users
// @Security ApiKeyAuth
// @Accept json
// @Produce json
// @Param user_id path int true "User ID"
// @Success 200 {object} common.ResponseHTTP{}
// @Failure 404 {object} common.ResponseHTTP{}
// @Failure 503 {object} common.ResponseHTTP{}
// @Router /user/{user_id} [delete]
func DeleteUser(contx *fiber.Ctx) error <span class="cov8" title="1">{

        // Starting tracer context and tracer
        ctx := contx.Locals("tracer")
        tracer, _ := ctx.(*observe.RouteTracer)

        // Getting Database connection
        db, _ := contx.Locals("db").(*gorm.DB)

        // get deleted user attributes to return
        var user models.User

        // validate path params
        id, err := strconv.Atoi(contx.Params("user_id"))
        if err != nil </span><span class="cov8" title="1">{
                return contx.Status(http.StatusBadRequest).JSON(common.ResponseHTTP{
                        Success: false,
                        Message: err.Error(),
                        Data:    nil,
                })
        }</span>

        // perform delete operation if the object exists
        <span class="cov8" title="1">tx := db.WithContext(tracer.Tracer).Begin()

        // first getting user and checking if it exists
        if err := db.WithContext(tracer.Tracer).Where("id = ?", id).First(&amp;user).Error; err != nil </span><span class="cov8" title="1">{
                tx.Rollback()
                return contx.Status(http.StatusNotFound).JSON(common.ResponseHTTP{
                        Success: false,
                        Message: err.Error(),
                        Data:    nil,
                })
        }</span>

        // Delete the user
        <span class="cov8" title="1">if err := db.WithContext(tracer.Tracer).Delete(&amp;user).Error; err != nil </span><span class="cov0" title="0">{
                tx.Rollback()
                return contx.Status(http.StatusInternalServerError).JSON(common.ResponseHTTP{
                        Success: false,
                        Message: "Error deleting user",
                        Data:    nil,
                })
        }</span>

        // Commit the transaction
        <span class="cov8" title="1">tx.Commit()

        // Return success respons
        return contx.Status(http.StatusOK).JSON(common.ResponseHTTP{
                Success: true,
                Message: "User deleted successfully.",
                Data:    user,
        })</span>
}

// DeleteAppUsers function removes a user by ID ( specfic to provided app)
// @Summary Remove App User by ID
// @Description Remove App user by ID
// @Tags Users
// @Security ApiKeyAuth
// @Accept json
// @Produce json
// @Param user_id path int true "User ID"
// @Param app_uuid query string true "app uuid"
// @Success 200 {object} common.ResponseHTTP{}
// @Failure 404 {object} common.ResponseHTTP{}
// @Failure 503 {object} common.ResponseHTTP{}
// @Router /appuser/{user_id} [delete]
func DeleteAppUser(contx *fiber.Ctx) error <span class="cov0" title="0">{

        // Starting tracer context and tracer
        ctx := contx.Locals("tracer")
        tracer, _ := ctx.(*observe.RouteTracer)

        // Getting Database connection
        db, _ := contx.Locals("db").(*gorm.DB)

        // get deleted user attributes to return
        var user models.User

        // validate path params
        id, err := strconv.Atoi(contx.Params("user_id"))
        if err != nil </span><span class="cov0" title="0">{
                return contx.Status(http.StatusBadRequest).JSON(common.ResponseHTTP{
                        Success: false,
                        Message: err.Error(),
                        Data:    nil,
                })
        }</span>

        //  getting app uuid
        <span class="cov0" title="0">app_uuid := contx.Query("app_uuid")
        if app_uuid == "" </span><span class="cov0" title="0">{
                return contx.Status(http.StatusBadRequest).JSON(common.ResponseHTTP{
                        Success: false,
                        Message: "No provided app uuid",
                        Data:    nil,
                })
        }</span>

        // perform delete operation if the object exists
        <span class="cov0" title="0">tx := db.WithContext(tracer.Tracer).Begin()
        query_string := `SELECT DISTINCT u.email, u.uuid, u.id, a.uuid
                        FROM users u
                        INNER JOIN user_roles ur ON u.id = ur.user_id
                        INNER JOIN roles r ON ur.role_id = r.id
                        INNER JOIN apps a ON r.app_id = a.id
                        WHERE a.uuid = ? AND u.id = ?;
        `
        // first getting user and checking if it exists
        if err := db.WithContext(tracer.Tracer).Raw(query_string, app_uuid, id).Scan(&amp;user).Error; err != nil </span><span class="cov0" title="0">{
                tx.Rollback()
                return contx.Status(http.StatusInternalServerError).JSON(common.ResponseHTTP{
                        Success: false,
                        Message: err.Error(),
                        Data:    nil,
                })
        }</span>

        // Delete the user
        <span class="cov0" title="0">if err := db.WithContext(tracer.Tracer).Delete(&amp;user).Error; err != nil </span><span class="cov0" title="0">{
                tx.Rollback()
                return contx.Status(http.StatusInternalServerError).JSON(common.ResponseHTTP{
                        Success: false,
                        Message: "Error deleting user",
                        Data:    nil,
                })
        }</span>

        // Commit the transaction
        <span class="cov0" title="0">tx.Commit()

        // Return success respons
        return contx.Status(http.StatusOK).JSON(common.ResponseHTTP{
                Success: true,
                Message: "User deleted successfully.",
                Data:    user,
        })</span>
}

// ################################################################
// Relationship Based Endpoints
// ################################################################

// Add Role to User
// @Summary Add User to Role
// @Description Add Role User
// @Tags RoleUsers
// @Security ApiKeyAuth
// @Accept json
// @Produce json
// @Param role_id path int true "Role ID"
// @Param user_id path int true "User ID"
// @Failure 400 {object} common.ResponseHTTP{}
// @Router /roleuser/{role_id}/{user_id} [post]
func AddRoleUsers(contx *fiber.Ctx) error <span class="cov0" title="0">{

        // Starting tracer context and tracer
        ctx := contx.Locals("tracer")
        tracer, _ := ctx.(*observe.RouteTracer)

        // database connection
        db, _ := contx.Locals("db").(*gorm.DB)

        // validate path params
        role_id, err := strconv.Atoi(contx.Params("role_id"))
        if err != nil </span><span class="cov0" title="0">{
                return contx.Status(http.StatusBadRequest).JSON(common.ResponseHTTP{
                        Success: false,
                        Message: err.Error(),
                        Data:    nil,
                })
        }</span>

        // validate path params
        <span class="cov0" title="0">user_id, err := strconv.Atoi(contx.Params("user_id"))
        if err != nil </span><span class="cov0" title="0">{
                return contx.Status(http.StatusBadRequest).JSON(common.ResponseHTTP{
                        Success: false,
                        Message: err.Error(),
                        Data:    nil,
                })
        }</span>

        // fetching user to be added
        <span class="cov0" title="0">var user models.User
        // first getting user and checking if it exists
        if err := db.WithContext(tracer.Tracer).Where("id = ?", user_id).First(&amp;user).Error; err != nil </span><span class="cov0" title="0">{
                return contx.Status(http.StatusNotFound).JSON(common.ResponseHTTP{
                        Success: false,
                        Message: err.Error(),
                        Data:    nil,
                })
        }</span>

        //  userending assocation
        <span class="cov0" title="0">var role models.Role
        role.ID = uint(role_id)
        if err := db.Find(&amp;role); err.Error != nil </span><span class="cov0" title="0">{
                return contx.Status(http.StatusNotFound).JSON(common.ResponseHTTP{
                        Success: false,
                        Message: "Record not Found",
                        Data:    err.Error.Error(),
                })
        }</span>

        <span class="cov0" title="0">tx := db.WithContext(tracer.Tracer).Begin()
        if err := db.WithContext(tracer.Tracer).Model(&amp;role).Association("Users").Append(&amp;user); err != nil </span><span class="cov0" title="0">{
                tx.Rollback()
                return contx.Status(http.StatusNotFound).JSON(common.ResponseHTTP{
                        Success: false,
                        Message: "Userending User Failed",
                        Data:    err.Error(),
                })
        }</span>
        <span class="cov0" title="0">tx.Commit()

        // return value if transaction is sucessfull
        return contx.Status(http.StatusOK).JSON(common.ResponseHTTP{
                Success: true,
                Message: "Success Creating a user Role.",
                Data:    user,
        })</span>
}

// Add App Role to User
// @Summary Add User to Role
// @Description Add Role User
// @Tags RoleUsers
// @Security ApiKeyAuth
// @Accept json
// @Produce json
// @Param role_id path int true "Role ID"
// @Param user_id path int true "User ID"
// @Param app_uuid query string true "app uuid"
// @Failure 400 {object} common.ResponseHTTP{}
// @Router /approleuser/{role_id}/{user_id} [post]
func AddAppsRoleUsers(contx *fiber.Ctx) error <span class="cov0" title="0">{

        // Starting tracer context and tracer
        ctx := contx.Locals("tracer")
        tracer, _ := ctx.(*observe.RouteTracer)

        // database connection
        db, _ := contx.Locals("db").(*gorm.DB)

        // validate path params
        role_id, err := strconv.Atoi(contx.Params("role_id"))
        if err != nil </span><span class="cov0" title="0">{
                return contx.Status(http.StatusBadRequest).JSON(common.ResponseHTTP{
                        Success: false,
                        Message: err.Error(),
                        Data:    nil,
                })
        }</span>

        // validate path params
        <span class="cov0" title="0">user_id, err := strconv.Atoi(contx.Params("user_id"))
        if err != nil </span><span class="cov0" title="0">{
                return contx.Status(http.StatusBadRequest).JSON(common.ResponseHTTP{
                        Success: false,
                        Message: err.Error(),
                        Data:    nil,
                })
        }</span>

        //  getting app uuid
        <span class="cov0" title="0">app_uuid := contx.Query("app_uuid")
        if app_uuid == "" </span><span class="cov0" title="0">{
                return contx.Status(http.StatusBadRequest).JSON(common.ResponseHTTP{
                        Success: false,
                        Message: "No provided app uuid",
                        Data:    nil,
                })
        }</span>

        // fetching user to be added
        <span class="cov0" title="0">var user models.User
        if err := db.WithContext(tracer.Tracer).Where("id = ?", user_id).First(&amp;user).Error; err != nil </span><span class="cov0" title="0">{
                return contx.Status(http.StatusNotFound).JSON(common.ResponseHTTP{
                        Success: false,
                        Message: err.Error(),
                        Data:    nil,
                })

        }</span>

        //  userending assocation
        <span class="cov0" title="0">var role models.Role
        query_string := `SELECT DISTINCT roles.id, roles.name, roles.description, roles.app_id, roles.active
                        FROM roles
                        INNER JOIN apps a ON roles.app_id = a.id
                        WHERE a.uuid = ? AND roles.id = ?;`
        if res := db.WithContext(tracer.Tracer).Raw(query_string, app_uuid, role_id).Scan(&amp;role); res.Error != nil </span><span class="cov0" title="0">{
                return contx.Status(http.StatusNotFound).JSON(common.ResponseHTTP{
                        Success: false,
                        Message: "Record not Found",
                        Data:    res.Error.Error(),
                })
        }</span>

        <span class="cov0" title="0">if role.ID != 0 </span><span class="cov0" title="0">{

                tx := db.WithContext(tracer.Tracer).Begin()
                if err := db.WithContext(tracer.Tracer).Model(&amp;role).Association("Users").Append(&amp;user); err != nil </span><span class="cov0" title="0">{
                        tx.Rollback()
                        return contx.Status(http.StatusNotFound).JSON(common.ResponseHTTP{
                                Success: false,
                                Message: "Appending User Failed",
                                Data:    err.Error(),
                        })
                }</span>
                <span class="cov0" title="0">tx.Commit()

                // return value if transaction is sucessfull
                return contx.Status(http.StatusOK).JSON(common.ResponseHTTP{
                        Success: true,
                        Message: "Success Creating a user Role.",
                        Data:    user,
                })</span>
        }
        // return value if transaction is unsucessful
        <span class="cov0" title="0">return contx.Status(http.StatusBadRequest).JSON(common.ResponseHTTP{
                Success: false,
                Message: "Either role or user does not Exist.",
                Data:    nil,
        })</span>
}

// Delete User to Role
// @Summary Add User
// @Description Delete Role User
// @Tags Roles
// @Security ApiKeyAuth
// @Accept json
// @Produce json
// @Param role_id path int true "Role ID"
// @Param user_id path int true "User ID"
// @Success 200 {object} common.ResponseHTTP{data=models.UserPost}
// @Failure 400 {object} common.ResponseHTTP{}
// @Failure 500 {object} common.ResponseHTTP{}
// @Router /roleuser/{role_id}/{user_id} [delete]
func DeleteRoleUsers(contx *fiber.Ctx) error <span class="cov0" title="0">{

        // Starting tracer context and tracer
        ctx := contx.Locals("tracer")
        tracer, _ := ctx.(*observe.RouteTracer)

        //Connect to Database
        db, _ := contx.Locals("db").(*gorm.DB)

        // validate path params
        role_id, err := strconv.Atoi(contx.Params("role_id"))
        if err != nil || role_id == 0 </span><span class="cov0" title="0">{
                return contx.Status(http.StatusBadRequest).JSON(common.ResponseHTTP{
                        Success: false,
                        Message: err.Error(),
                        Data:    nil,
                })
        }</span>

        <span class="cov0" title="0">user_id, err := strconv.Atoi(contx.Params("user_id"))
        if err != nil || user_id == 0 </span><span class="cov0" title="0">{
                return contx.Status(http.StatusBadRequest).JSON(common.ResponseHTTP{
                        Success: false,
                        Message: err.Error(),
                        Data:    nil,
                })
        }</span>

        // fetching user to be deleted
        <span class="cov0" title="0">var user models.User
        if err := db.WithContext(tracer.Tracer).Where("id = ?", user_id).First(&amp;user).Error; err != nil </span><span class="cov0" title="0">{
                return contx.Status(http.StatusNotFound).JSON(common.ResponseHTTP{
                        Success: false,
                        Message: err.Error(),
                        Data:    nil,
                })

        }</span>

        // fettchng role
        <span class="cov0" title="0">var role models.Role
        if err := db.WithContext(tracer.Tracer).Where("id = ?", role_id).First(&amp;role).Error; err != nil </span><span class="cov0" title="0">{
                return contx.Status(http.StatusNotFound).JSON(common.ResponseHTTP{
                        Success: false,
                        Message: "Record not Found",
                        Data:    err.Error,
                })
        }</span>

        // removing user
        <span class="cov0" title="0">tx := db.WithContext(tracer.Tracer).Begin()
        if err := db.WithContext(tracer.Tracer).Model(&amp;role).Association("Users").Delete(&amp;user); err != nil </span><span class="cov0" title="0">{
                tx.Rollback()
                return contx.Status(http.StatusNonAuthoritativeInfo).JSON(common.ResponseHTTP{
                        Success: false,
                        Message: "Please Try Again Something Unexpected Huserened",
                        Data:    err.Error(),
                })
        }</span>

        <span class="cov0" title="0">tx.Commit()

        // return value if transaction is sucessfull
        return contx.Status(http.StatusOK).JSON(common.ResponseHTTP{
                Success: true,
                Message: "Success Removing a user from role.",
                Data:    user,
        })</span>
}

// Delete User to Role
// @Summary Add User
// @Description Delete Role User
// @Tags Roles
// @Security ApiKeyAuth
// @Accept json
// @Produce json
// @Param role_id path int true "Role ID"
// @Param user_id path int true "User ID"
// @Param app_uuid query string true "app uuid"
// @Success 200 {object} common.ResponseHTTP{data=models.UserPost}
// @Failure 400 {object} common.ResponseHTTP{}
// @Failure 500 {object} common.ResponseHTTP{}
// @Router /approleuser/{role_id}/{user_id} [delete]
func DeleteAppRoleUsers(contx *fiber.Ctx) error <span class="cov0" title="0">{

        // Starting tracer context and tracer
        ctx := contx.Locals("tracer")
        tracer, _ := ctx.(*observe.RouteTracer)

        //Connect to Database
        db, _ := contx.Locals("db").(*gorm.DB)

        // validate path params
        role_id, err := strconv.Atoi(contx.Params("role_id"))
        if err != nil || role_id == 0 </span><span class="cov0" title="0">{
                return contx.Status(http.StatusBadRequest).JSON(common.ResponseHTTP{
                        Success: false,
                        Message: err.Error(),
                        Data:    nil,
                })
        }</span>

        <span class="cov0" title="0">user_id, err := strconv.Atoi(contx.Params("user_id"))
        if err != nil || user_id == 0 </span><span class="cov0" title="0">{
                return contx.Status(http.StatusBadRequest).JSON(common.ResponseHTTP{
                        Success: false,
                        Message: err.Error(),
                        Data:    nil,
                })
        }</span>

        // fetching user to be deleted
        <span class="cov0" title="0">var user models.User
        if err := db.WithContext(tracer.Tracer).Where("id = ?", user_id).First(&amp;user).Error; err != nil </span><span class="cov0" title="0">{
                return contx.Status(http.StatusNotFound).JSON(common.ResponseHTTP{
                        Success: false,
                        Message: err.Error(),
                        Data:    nil,
                })

        }</span>

        //  getting app uuid
        <span class="cov0" title="0">app_uuid := contx.Query("app_uuid")
        if app_uuid == "" </span><span class="cov0" title="0">{
                return contx.Status(http.StatusBadRequest).JSON(common.ResponseHTTP{
                        Success: false,
                        Message: "No provided app uuid",
                        Data:    nil,
                })
        }</span>

        // fettchng role
        //  userending assocation
        <span class="cov0" title="0">var role models.Role
        query_string := `SELECT DISTINCT roles.id, roles.name, roles.description, roles.app_id, roles.active
                        FROM roles
                        INNER JOIN apps a ON roles.app_id = a.id
                        WHERE a.uuid = ? AND roles.id = ?;`
        if res := db.WithContext(tracer.Tracer).Raw(query_string, app_uuid, role_id).Scan(&amp;role); res.Error != nil </span><span class="cov0" title="0">{
                return contx.Status(http.StatusNotFound).JSON(common.ResponseHTTP{
                        Success: false,
                        Message: "Record not Found",
                        Data:    res.Error.Error(),
                })
        }</span>

        <span class="cov0" title="0">if role.ID != 0 </span><span class="cov0" title="0">{

                // removing user
                tx := db.WithContext(tracer.Tracer).Begin()
                if err := db.WithContext(tracer.Tracer).Model(&amp;role).Association("Users").Delete(&amp;user); err != nil </span><span class="cov0" title="0">{
                        tx.Rollback()
                        return contx.Status(http.StatusNonAuthoritativeInfo).JSON(common.ResponseHTTP{
                                Success: false,
                                Message: "Please Try Again Something Unexpected Huserened",
                                Data:    err.Error(),
                        })
                }</span>

                <span class="cov0" title="0">tx.Commit()

                // return value if transaction is sucessfull
                return contx.Status(http.StatusOK).JSON(common.ResponseHTTP{
                        Success: true,
                        Message: "Success Removing a user from role.",
                        Data:    user,
                })</span>
        }

        // return value if transaction is unsucessful
        <span class="cov0" title="0">return contx.Status(http.StatusBadRequest).JSON(common.ResponseHTTP{
                Success: false,
                Message: "Either role or user does not Exist.",
                Data:    nil,
        })</span>

}

// Activate/Deactivate User
// @Summary Activate/Deactivate User
// @Description Activate/Deactivate User
// @Tags Users
// @Security ApiKeyAuth
// @Accept json
// @Produce json
// @Param user_id path int true "User ID"
// @Param status query bool true "Disabled"
// @Failure 400 {object} common.ResponseHTTP{}
// @Router /user/{user_id} [put]
func ActivateDeactivateUser(contx *fiber.Ctx) error <span class="cov0" title="0">{
        //  Getting tracer context
        ctx := contx.Locals("tracer")
        tracer, _ := ctx.(*observe.RouteTracer)

        //  Getting Database connection
        db, _ := contx.Locals("db").(*gorm.DB)

        // validate path params
        user_id, err := strconv.Atoi(contx.Params("user_id"))
        if err != nil </span><span class="cov0" title="0">{
                return contx.Status(http.StatusBadRequest).JSON(common.ResponseHTTP{
                        Success: false,
                        Message: err.Error(),
                        Data:    nil,
                })
        }</span>

        // Getting Query Parameter
        <span class="cov0" title="0">status := contx.QueryBool("status")

        // Fetching User
        var user models.User
        //Updating Didabled Status it it exists
        tx := db.WithContext(tracer.Tracer).Begin()
        if err := db.WithContext(tracer.Tracer).Where("id = ?", user_id).First(&amp;user).Error; err != nil </span><span class="cov0" title="0">{
                tx.Rollback()
                return contx.Status(http.StatusNotFound).JSON(common.ResponseHTTP{
                        Success: false,
                        Message: err.Error(),
                        Data:    nil,
                })
        }</span>

        <span class="cov0" title="0">db.WithContext(tracer.Tracer).Model(&amp;user).Update("disabled", status)
        tx.Commit()

        var response_user models.UserGet
        if user.ID != 0 </span><span class="cov0" title="0">{
                mapstructure.Decode(user, &amp;response_user)
                response_user.Disabled = status
                // return value if transaction is sucessfull
                return contx.Status(http.StatusOK).JSON(common.ResponseHTTP{
                        Success: true,
                        Message: "Success Updating a User.",
                        Data:    response_user,
                })
        }</span>

        //  Finally return if no record found
        <span class="cov0" title="0">return contx.Status(http.StatusBadRequest).JSON(common.ResponseHTTP{
                Success: false,
                Message: "No Record Found",
                Data:    nil,
        })</span>
}

type UserPassword struct {
        Email    string `validate:"required" json:"email" example:"someone@domain.com"`
        Password string `validate:"required" json:"password"`
}

// Update User Password Details
// @Summary Put User
// @Description Put User
// @Tags Users
// @Security ApiKeyAuth
// @Accept json
// @Produce json
// @Param user body UserPassword true "Password User"
// @Param reset query bool true "Reset Password"
// @Success 200 {object} common.ResponseHTTP{data=models.UserGet}
// @Failure 400 {object} common.ResponseHTTP{}
// @Router /user         [put]
func ChangePassword(contx *fiber.Ctx) error <span class="cov0" title="0">{
        //  Getting tracer context
        ctx := contx.Locals("tracer")
        tracer, _ := ctx.(*observe.RouteTracer)

        //  Getting Database connection
        db, _ := contx.Locals("db").(*gorm.DB)

        validate := validator.New()
        // get query parms
        reset_password := contx.QueryBool("reset")

        // first parsing
        patch_User := new(UserPassword)
        if err := contx.BodyParser(&amp;patch_User); err != nil </span><span class="cov0" title="0">{
                return contx.Status(http.StatusBadRequest).JSON(common.ResponseHTTP{
                        Success: false,
                        Message: err.Error(),
                        Data:    nil,
                })
        }</span>
        // then validating
        <span class="cov0" title="0">if err := validate.Struct(patch_User); err != nil </span><span class="cov0" title="0">{
                return contx.Status(http.StatusBadRequest).JSON(common.ResponseHTTP{
                        Success: false,
                        Message: err.Error(),
                        Data:    nil,
                })
        }</span>

        // startng update transaction
        <span class="cov0" title="0">var user_q models.User
        if err := db.WithContext(tracer.Tracer).Model(&amp;user_q).Where("email =?", patch_User.Email).Find(&amp;user_q).Error; err != nil </span><span class="cov0" title="0">{

                return contx.Status(http.StatusNotFound).JSON(common.ResponseHTTP{
                        Success: false,
                        Message: "Record not Found",
                        Data:    err,
                })
        }</span>

        <span class="cov0" title="0">var user models.UserGet

        if !reset_password </span><span class="cov0" title="0">{
                tx := db.WithContext(tracer.Tracer).Begin()
                patch_User.Password = utils.HashFunc(patch_User.Password)
                if err := db.WithContext(tracer.Tracer).Model(&amp;user_q).UpdateColumns(*patch_User).Error; err != nil </span><span class="cov0" title="0">{
                        tx.Rollback()
                        return contx.Status(http.StatusNotFound).JSON(common.ResponseHTTP{
                                Success: false,
                                Message: "Record not Found",
                                Data:    err,
                        })
                }</span>
                <span class="cov0" title="0">tx.Commit()</span>
        } else<span class="cov0" title="0"> {
                tx := db.WithContext(tracer.Tracer).Begin()
                patch_User.Password = utils.HashFunc("default@123")
                if err := db.WithContext(tracer.Tracer).Model(&amp;user_q).UpdateColumns(*patch_User).Error; err != nil </span><span class="cov0" title="0">{
                        tx.Rollback()
                        return contx.Status(http.StatusNotFound).JSON(common.ResponseHTTP{
                                Success: false,
                                Message: "Record not Found",
                                Data:    err,
                        })
                }</span>
                <span class="cov0" title="0">tx.Commit()</span>
        }

        <span class="cov0" title="0">mapstructure.Decode(user_q, &amp;user)
        // return value if transaction is sucessfull
        return contx.Status(http.StatusOK).JSON(common.ResponseHTTP{
                Success: true,
                Message: "Success Updating a Password.",
                Data:    user,
        })</span>
}
</pre>
		
		<pre class="file" id="file17" style="display: none">package database

import (
        "fmt"
        "log"
        "os"
        "time"

        "blue-admin.com/configs"
        "gorm.io/driver/mysql"
        "gorm.io/driver/postgres"
        "gorm.io/driver/sqlite"
        "gorm.io/gorm"
        "gorm.io/gorm/logger"
        "gorm.io/plugin/opentelemetry/tracing"
)

var (
        DBConn *gorm.DB
)

func GormLoggerFile() (*os.File, error) <span class="cov8" title="1">{
        //  Gorm logging file
        gormLogFile, gerr := os.OpenFile("gormblue.log", os.O_RDWR|os.O_CREATE|os.O_APPEND, 0666)
        if gerr != nil </span><span class="cov0" title="0">{
                log.Fatalf("error opening file: %v", gerr)
        }</span>
        <span class="cov8" title="1">return gormLogFile, nil</span>
}

func ReturnSession() (*gorm.DB, error) <span class="cov8" title="1">{

        //  setting up database connection based on DB type
        app_env := configs.AppConfig.Get("DB_TYPE")

        //  This is file to output gorm logger on to
        gormlogger, err := GormLoggerFile()
        if err != nil </span><span class="cov0" title="0">{
                fmt.Printf("unable to create log file: %v\n", err)
                return nil, err
        }</span>

        <span class="cov8" title="1">gormFileLogger := log.Logger{}
        gormFileLogger.SetOutput(gormlogger)
        gormFileLogger.Writer()

        gormLogger := log.New(gormFileLogger.Writer(), "\r\n", log.LstdFlags|log.Ldate|log.Ltime|log.Lshortfile)
        newLogger := logger.New(
                gormLogger, // io writer
                logger.Config{
                        SlowThreshold:             time.Second, // Slow SQL threshold
                        LogLevel:                  logger.Info, // Log level
                        Colorful:                  true,        // Enable color
                        IgnoreRecordNotFoundError: true,        // Ignore ErrRecordNotFound error for logger
                        // ParameterizedQueries:      true,        // Don't include params in the SQL log

                },
        )

        var DBSession *gorm.DB

        switch app_env </span>{
        case "postgres":<span class="cov0" title="0">
                db, err := gorm.Open(postgres.New(postgres.Config{
                        DSN:                  configs.AppConfig.Get("POSTGRES_URI"),
                        PreferSimpleProtocol: true, // disables implicit prepared statement usage,

                }), &amp;gorm.Config{
                        DisableForeignKeyConstraintWhenMigrating: true,
                        Logger:                                   newLogger,
                        SkipDefaultTransaction:                   true,
                })
                if err != nil </span><span class="cov0" title="0">{
                        panic(err)</span>
                }

                <span class="cov0" title="0">sqlDB, err := db.DB()
                if err != nil </span><span class="cov0" title="0">{
                        fmt.Printf("Error during connecting to database: %v\n", err)
                        return nil, err
                }</span>
                <span class="cov0" title="0">sqlDB.SetMaxOpenConns(10)
                sqlDB.SetConnMaxLifetime(5 * time.Second)

                DBSession = db</span>
        case "sqlite":<span class="cov8" title="1">
                //  this is sqlite connection
                db, _ := gorm.Open(sqlite.Open(configs.AppConfig.Get("SQLLITE_URI")), &amp;gorm.Config{
                        DisableForeignKeyConstraintWhenMigrating: true,
                        Logger:                                   newLogger,
                        SkipDefaultTransaction:                   true,
                })

                sqlDB, err := db.DB()
                if err != nil </span><span class="cov0" title="0">{
                        fmt.Printf("Error during connecting to database: %v\n", err)
                        return nil, err
                }</span>
                <span class="cov8" title="1">sqlDB.SetMaxOpenConns(10)
                sqlDB.SetConnMaxLifetime(5 * time.Second)
                DBSession = db</span>
        case "mysql":<span class="cov0" title="0">
                db, _ := gorm.Open(mysql.New(mysql.Config{
                        DSN:                       configs.AppConfig.Get("MYSQL_URI"), // data source name
                        DefaultStringSize:         256,                                // default size for string fields
                        DisableDatetimePrecision:  true,                               // disable datetime precision, which not supported before MySQL 5.6
                        DontSupportRenameIndex:    true,                               // drop &amp; create when rename index, rename index not supported before MySQL 5.7, MariaDB
                        DontSupportRenameColumn:   true,                               //  when rename column, rename column not supported before MySQL 8, MariaDB
                        SkipInitializeWithVersion: false,                              // auto configure based on currently MySQL version
                }), &amp;gorm.Config{
                        DisableForeignKeyConstraintWhenMigrating: true,
                        Logger:                                   newLogger,
                        SkipDefaultTransaction:                   true,
                })

                sqlDB, err := db.DB()
                if err != nil </span><span class="cov0" title="0">{
                        fmt.Printf("Error during connecting to database: %v\n", err)
                        return nil, err
                }</span>
                <span class="cov0" title="0">sqlDB.SetMaxOpenConns(10)
                sqlDB.SetConnMaxLifetime(5 * time.Second)
                DBSession = db</span>
        case "":<span class="cov8" title="1">
                //  this is sqlite connection
                db, _ := gorm.Open(sqlite.Open("goframe-2.db"), &amp;gorm.Config{
                        DisableForeignKeyConstraintWhenMigrating: true,
                        Logger:                                   newLogger,
                        SkipDefaultTransaction:                   true,
                })

                sqlDB, err := db.DB()
                if err != nil </span><span class="cov0" title="0">{
                        fmt.Printf("Error during connecting to database: %v\n", err)
                        return nil, err
                }</span>
                <span class="cov8" title="1">sqlDB.SetMaxOpenConns(10)
                sqlDB.SetConnMaxLifetime(5 * time.Second)
                DBSession = db</span>
        default:<span class="cov0" title="0">
                //  this is sqlite connection
                db, _ := gorm.Open(sqlite.Open(configs.AppConfig.Get("SQLITE_URI")), &amp;gorm.Config{
                        DisableForeignKeyConstraintWhenMigrating: true,
                        Logger:                                   newLogger,
                        SkipDefaultTransaction:                   true,
                })

                sqlDB, err := db.DB()
                if err != nil </span><span class="cov0" title="0">{
                        fmt.Printf("Error during connecting to database: %v\n", err)
                        return nil, err
                }</span>
                <span class="cov0" title="0">sqlDB.SetMaxOpenConns(10)
                sqlDB.SetConnMaxLifetime(5 * time.Second)
                DBSession = db</span>

        }

        <span class="cov8" title="1">DBSession.Use(tracing.NewPlugin())
        return DBSession, nil</span>

}
</pre>
		
		<pre class="file" id="file18" style="display: none">// Package docs Code generated by swaggo/swag. DO NOT EDIT
package docs

import "github.com/swaggo/swag"

const docTemplate = `{
    "schemes": {{ marshal .Schemes }},
    "swagger": "2.0",
    "info": {
        "description": "{{escape .Description}}",
        "title": "{{.Title}}",
        "termsOfService": "http://swagger.io/terms/",
        "contact": {},
        "version": "{{.Version}}"
    },
    "host": "{{.Host}}",
    "basePath": "{{.BasePath}}",
    "paths": {
        "/app": {
            "get": {
                "security": [
                    {
                        "ApiKeyAuth": []
                    },
                    {
                        "Refresh": []
                    }
                ],
                "description": "Get Apps",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Apps"
                ],
                "summary": "Get Apps",
                "parameters": [
                    {
                        "type": "integer",
                        "description": "page",
                        "name": "page",
                        "in": "query",
                        "required": true
                    },
                    {
                        "type": "integer",
                        "description": "page size",
                        "name": "size",
                        "in": "query",
                        "required": true
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "allOf": [
                                {
                                    "$ref": "#/definitions/common.ResponsePagination"
                                },
                                {
                                    "type": "object",
                                    "properties": {
                                        "data": {
                                            "type": "array",
                                            "items": {
                                                "$ref": "#/definitions/models.AppGet"
                                            }
                                        }
                                    }
                                }
                            ]
                        }
                    },
                    "404": {
                        "description": "Not Found",
                        "schema": {
                            "$ref": "#/definitions/common.ResponseHTTP"
                        }
                    }
                }
            },
            "post": {
                "security": [
                    {
                        "ApiKeyAuth": []
                    }
                ],
                "description": "Add App",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Apps"
                ],
                "summary": "Add a new App",
                "parameters": [
                    {
                        "description": "Add App",
                        "name": "app",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/models.AppPost"
                        }
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "allOf": [
                                {
                                    "$ref": "#/definitions/common.ResponseHTTP"
                                },
                                {
                                    "type": "object",
                                    "properties": {
                                        "data": {
                                            "$ref": "#/definitions/models.AppPost"
                                        }
                                    }
                                }
                            ]
                        }
                    },
                    "400": {
                        "description": "Bad Request",
                        "schema": {
                            "$ref": "#/definitions/common.ResponseHTTP"
                        }
                    },
                    "500": {
                        "description": "Internal Server Error",
                        "schema": {
                            "$ref": "#/definitions/common.ResponseHTTP"
                        }
                    }
                }
            }
        },
        "/app/{app_id}": {
            "get": {
                "security": [
                    {
                        "ApiKeyAuth": []
                    }
                ],
                "description": "Get app by ID",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Apps"
                ],
                "summary": "Get App by ID",
                "parameters": [
                    {
                        "type": "integer",
                        "description": "App ID",
                        "name": "app_id",
                        "in": "path",
                        "required": true
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "allOf": [
                                {
                                    "$ref": "#/definitions/common.ResponseHTTP"
                                },
                                {
                                    "type": "object",
                                    "properties": {
                                        "data": {
                                            "$ref": "#/definitions/models.AppGet"
                                        }
                                    }
                                }
                            ]
                        }
                    },
                    "404": {
                        "description": "Not Found",
                        "schema": {
                            "$ref": "#/definitions/common.ResponseHTTP"
                        }
                    }
                }
            },
            "delete": {
                "security": [
                    {
                        "ApiKeyAuth": []
                    }
                ],
                "description": "Remove app by ID",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Apps"
                ],
                "summary": "Remove App by ID",
                "parameters": [
                    {
                        "type": "integer",
                        "description": "App ID",
                        "name": "app_id",
                        "in": "path",
                        "required": true
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "$ref": "#/definitions/common.ResponseHTTP"
                        }
                    },
                    "404": {
                        "description": "Not Found",
                        "schema": {
                            "$ref": "#/definitions/common.ResponseHTTP"
                        }
                    },
                    "503": {
                        "description": "Service Unavailable",
                        "schema": {
                            "$ref": "#/definitions/common.ResponseHTTP"
                        }
                    }
                }
            },
            "patch": {
                "security": [
                    {
                        "ApiKeyAuth": []
                    }
                ],
                "description": "Patch App",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Apps"
                ],
                "summary": "Patch App",
                "parameters": [
                    {
                        "description": "Patch App",
                        "name": "app",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/models.AppPost"
                        }
                    },
                    {
                        "type": "integer",
                        "description": "App ID",
                        "name": "app_id",
                        "in": "path",
                        "required": true
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "allOf": [
                                {
                                    "$ref": "#/definitions/common.ResponseHTTP"
                                },
                                {
                                    "type": "object",
                                    "properties": {
                                        "data": {
                                            "$ref": "#/definitions/models.AppPost"
                                        }
                                    }
                                }
                            ]
                        }
                    },
                    "400": {
                        "description": "Bad Request",
                        "schema": {
                            "$ref": "#/definitions/common.ResponseHTTP"
                        }
                    },
                    "500": {
                        "description": "Internal Server Error",
                        "schema": {
                            "$ref": "#/definitions/common.ResponseHTTP"
                        }
                    }
                }
            }
        },
        "/approleuser/{role_id}/{user_id}": {
            "post": {
                "security": [
                    {
                        "ApiKeyAuth": []
                    }
                ],
                "description": "Add Role User",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "RoleUsers"
                ],
                "summary": "Add User to Role",
                "parameters": [
                    {
                        "type": "integer",
                        "description": "Role ID",
                        "name": "role_id",
                        "in": "path",
                        "required": true
                    },
                    {
                        "type": "integer",
                        "description": "User ID",
                        "name": "user_id",
                        "in": "path",
                        "required": true
                    },
                    {
                        "type": "string",
                        "description": "app uuid",
                        "name": "app_uuid",
                        "in": "query",
                        "required": true
                    }
                ],
                "responses": {
                    "400": {
                        "description": "Bad Request",
                        "schema": {
                            "$ref": "#/definitions/common.ResponseHTTP"
                        }
                    }
                }
            },
            "delete": {
                "security": [
                    {
                        "ApiKeyAuth": []
                    }
                ],
                "description": "Delete Role User",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Roles"
                ],
                "summary": "Add User",
                "parameters": [
                    {
                        "type": "integer",
                        "description": "Role ID",
                        "name": "role_id",
                        "in": "path",
                        "required": true
                    },
                    {
                        "type": "integer",
                        "description": "User ID",
                        "name": "user_id",
                        "in": "path",
                        "required": true
                    },
                    {
                        "type": "string",
                        "description": "app uuid",
                        "name": "app_uuid",
                        "in": "query",
                        "required": true
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "allOf": [
                                {
                                    "$ref": "#/definitions/common.ResponseHTTP"
                                },
                                {
                                    "type": "object",
                                    "properties": {
                                        "data": {
                                            "$ref": "#/definitions/models.UserPost"
                                        }
                                    }
                                }
                            ]
                        }
                    },
                    "400": {
                        "description": "Bad Request",
                        "schema": {
                            "$ref": "#/definitions/common.ResponseHTTP"
                        }
                    },
                    "500": {
                        "description": "Internal Server Error",
                        "schema": {
                            "$ref": "#/definitions/common.ResponseHTTP"
                        }
                    }
                }
            }
        },
        "/appruid/{app_uuid}": {
            "get": {
                "security": [
                    {
                        "ApiKeyAuth": []
                    }
                ],
                "description": "Get app roles by UUID",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Apps"
                ],
                "summary": "Get App Roles by UUID",
                "parameters": [
                    {
                        "type": "string",
                        "description": "App UUID",
                        "name": "app_uuid",
                        "in": "path",
                        "required": true
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "allOf": [
                                {
                                    "$ref": "#/definitions/common.ResponseHTTP"
                                },
                                {
                                    "type": "object",
                                    "properties": {
                                        "data": {
                                            "type": "array",
                                            "items": {
                                                "$ref": "#/definitions/models.RolePut"
                                            }
                                        }
                                    }
                                }
                            ]
                        }
                    },
                    "404": {
                        "description": "Not Found",
                        "schema": {
                            "$ref": "#/definitions/common.ResponseHTTP"
                        }
                    }
                }
            }
        },
        "/appsdrop": {
            "get": {
                "security": [
                    {
                        "ApiKeyAuth": []
                    }
                ],
                "description": "Get FeatureDropDown",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Feature"
                ],
                "summary": "Get FeatureDropDown",
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "allOf": [
                                {
                                    "$ref": "#/definitions/common.ResponseHTTP"
                                },
                                {
                                    "type": "object",
                                    "properties": {
                                        "data": {
                                            "type": "array",
                                            "items": {
                                                "$ref": "#/definitions/controllers.FeatureDropDown"
                                            }
                                        }
                                    }
                                }
                            ]
                        }
                    },
                    "404": {
                        "description": "Not Found",
                        "schema": {
                            "$ref": "#/definitions/common.ResponseHTTP"
                        }
                    }
                }
            }
        },
        "/appuser/{user_id}": {
            "get": {
                "security": [
                    {
                        "ApiKeyAuth": []
                    }
                ],
                "description": "Get App user by ID",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Users"
                ],
                "summary": "Get App User by ID",
                "parameters": [
                    {
                        "type": "integer",
                        "description": "User ID",
                        "name": "user_id",
                        "in": "path",
                        "required": true
                    },
                    {
                        "type": "string",
                        "description": "app uuid",
                        "name": "app_uuid",
                        "in": "query",
                        "required": true
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "allOf": [
                                {
                                    "$ref": "#/definitions/common.ResponseHTTP"
                                },
                                {
                                    "type": "object",
                                    "properties": {
                                        "data": {
                                            "$ref": "#/definitions/models.UserGet"
                                        }
                                    }
                                }
                            ]
                        }
                    },
                    "404": {
                        "description": "Not Found",
                        "schema": {
                            "$ref": "#/definitions/common.ResponseHTTP"
                        }
                    }
                }
            },
            "delete": {
                "security": [
                    {
                        "ApiKeyAuth": []
                    }
                ],
                "description": "Remove App user by ID",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Users"
                ],
                "summary": "Remove App User by ID",
                "parameters": [
                    {
                        "type": "integer",
                        "description": "User ID",
                        "name": "user_id",
                        "in": "path",
                        "required": true
                    },
                    {
                        "type": "string",
                        "description": "app uuid",
                        "name": "app_uuid",
                        "in": "query",
                        "required": true
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "$ref": "#/definitions/common.ResponseHTTP"
                        }
                    },
                    "404": {
                        "description": "Not Found",
                        "schema": {
                            "$ref": "#/definitions/common.ResponseHTTP"
                        }
                    },
                    "503": {
                        "description": "Service Unavailable",
                        "schema": {
                            "$ref": "#/definitions/common.ResponseHTTP"
                        }
                    }
                }
            }
        },
        "/appusers": {
            "get": {
                "security": [
                    {
                        "ApiKeyAuth": []
                    },
                    {
                        "Refresh": []
                    }
                ],
                "description": "Get App Users",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Users"
                ],
                "summary": "Get App Users",
                "parameters": [
                    {
                        "type": "integer",
                        "description": "page",
                        "name": "page",
                        "in": "query",
                        "required": true
                    },
                    {
                        "type": "integer",
                        "description": "page size",
                        "name": "size",
                        "in": "query",
                        "required": true
                    },
                    {
                        "type": "string",
                        "description": "app uuid",
                        "name": "app_uuid",
                        "in": "query",
                        "required": true
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "allOf": [
                                {
                                    "$ref": "#/definitions/common.ResponsePagination"
                                },
                                {
                                    "type": "object",
                                    "properties": {
                                        "data": {
                                            "type": "array",
                                            "items": {
                                                "$ref": "#/definitions/models.UserGet"
                                            }
                                        }
                                    }
                                }
                            ]
                        }
                    },
                    "404": {
                        "description": "Not Found",
                        "schema": {
                            "$ref": "#/definitions/common.ResponseHTTP"
                        }
                    }
                }
            }
        },
        "/checklogin": {
            "get": {
                "security": [
                    {
                        "ApiKeyAuth": []
                    }
                ],
                "description": "CheckLogin",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Authentication"
                ],
                "summary": "Auth",
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "allOf": [
                                {
                                    "$ref": "#/definitions/common.ResponseHTTP"
                                },
                                {
                                    "type": "object",
                                    "properties": {
                                        "data": {
                                            "$ref": "#/definitions/controllers.TokenResponse"
                                        }
                                    }
                                }
                            ]
                        }
                    },
                    "404": {
                        "description": "Not Found",
                        "schema": {
                            "$ref": "#/definitions/common.ResponseHTTP"
                        }
                    }
                }
            }
        },
        "/dashboard": {
            "get": {
                "security": [
                    {
                        "ApiKeyAuth": []
                    }
                ],
                "description": "Get App summary by App ID",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Dashboard Meta"
                ],
                "summary": "Get Roles Grouped By APP ID",
                "parameters": [
                    {
                        "type": "string",
                        "description": "App ID",
                        "name": "app_id",
                        "in": "query",
                        "required": true
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "allOf": [
                                {
                                    "$ref": "#/definitions/common.ResponseHTTP"
                                },
                                {
                                    "type": "object",
                                    "properties": {
                                        "data": {
                                            "$ref": "#/definitions/controllers.AppMeta"
                                        }
                                    }
                                }
                            ]
                        }
                    },
                    "404": {
                        "description": "Not Found",
                        "schema": {
                            "$ref": "#/definitions/common.ResponseHTTP"
                        }
                    }
                }
            }
        },
        "/dashboardends": {
            "get": {
                "security": [
                    {
                        "ApiKeyAuth": []
                    }
                ],
                "description": "Get App Endpoints summary",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Dashboard Meta"
                ],
                "summary": "Get App Endpoints Grouped By Role",
                "parameters": [
                    {
                        "type": "string",
                        "description": "App ID",
                        "name": "app_id",
                        "in": "query",
                        "required": true
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "allOf": [
                                {
                                    "$ref": "#/definitions/common.ResponseHTTP"
                                },
                                {
                                    "type": "object",
                                    "properties": {
                                        "data": {
                                            "$ref": "#/definitions/controllers.AppEndpointsMeta"
                                        }
                                    }
                                }
                            ]
                        }
                    },
                    "404": {
                        "description": "Not Found",
                        "schema": {
                            "$ref": "#/definitions/common.ResponseHTTP"
                        }
                    }
                }
            }
        },
        "/dashboardfeat": {
            "get": {
                "security": [
                    {
                        "ApiKeyAuth": []
                    }
                ],
                "description": "Get App Featuers summary",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Dashboard Meta"
                ],
                "summary": "Get App Features Grouped By Role",
                "parameters": [
                    {
                        "type": "string",
                        "description": "App ID",
                        "name": "app_id",
                        "in": "query",
                        "required": true
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "allOf": [
                                {
                                    "$ref": "#/definitions/common.ResponseHTTP"
                                },
                                {
                                    "type": "object",
                                    "properties": {
                                        "data": {
                                            "$ref": "#/definitions/controllers.AppFeaturesMeta"
                                        }
                                    }
                                }
                            ]
                        }
                    },
                    "404": {
                        "description": "Not Found",
                        "schema": {
                            "$ref": "#/definitions/common.ResponseHTTP"
                        }
                    }
                }
            }
        },
        "/dashboardpages": {
            "get": {
                "security": [
                    {
                        "ApiKeyAuth": []
                    }
                ],
                "description": "Get App Pages summary",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Dashboard Meta"
                ],
                "summary": "Get App Pages",
                "parameters": [
                    {
                        "type": "string",
                        "description": "App ID",
                        "name": "app_id",
                        "in": "query",
                        "required": true
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "allOf": [
                                {
                                    "$ref": "#/definitions/common.ResponseHTTP"
                                },
                                {
                                    "type": "object",
                                    "properties": {
                                        "data": {
                                            "$ref": "#/definitions/controllers.AppFeaturesMeta"
                                        }
                                    }
                                }
                            ]
                        }
                    },
                    "404": {
                        "description": "Not Found",
                        "schema": {
                            "$ref": "#/definitions/common.ResponseHTTP"
                        }
                    }
                }
            }
        },
        "/dashboardroles": {
            "get": {
                "security": [
                    {
                        "ApiKeyAuth": []
                    }
                ],
                "description": "Get App Roles summary",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Dashboard Meta"
                ],
                "summary": "Get App Roles",
                "parameters": [
                    {
                        "type": "string",
                        "description": "App ID",
                        "name": "app_id",
                        "in": "query",
                        "required": true
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "allOf": [
                                {
                                    "$ref": "#/definitions/common.ResponseHTTP"
                                },
                                {
                                    "type": "object",
                                    "properties": {
                                        "data": {
                                            "$ref": "#/definitions/controllers.AppFeaturesMeta"
                                        }
                                    }
                                }
                            ]
                        }
                    },
                    "404": {
                        "description": "Not Found",
                        "schema": {
                            "$ref": "#/definitions/common.ResponseHTTP"
                        }
                    }
                }
            }
        },
        "/dashboardrolespage": {
            "get": {
                "security": [
                    {
                        "ApiKeyAuth": []
                    }
                ],
                "description": "Get Roles by page by ID",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Dashboard Meta"
                ],
                "summary": "Get Page Roles for Secfic App by ID",
                "parameters": [
                    {
                        "type": "string",
                        "description": "App ID",
                        "name": "app_id",
                        "in": "query",
                        "required": true
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "allOf": [
                                {
                                    "$ref": "#/definitions/common.ResponseHTTP"
                                },
                                {
                                    "type": "object",
                                    "properties": {
                                        "data": {
                                            "$ref": "#/definitions/models.PageGet"
                                        }
                                    }
                                }
                            ]
                        }
                    },
                    "404": {
                        "description": "Not Found",
                        "schema": {
                            "$ref": "#/definitions/common.ResponseHTTP"
                        }
                    }
                }
            }
        },
        "/droproles": {
            "get": {
                "security": [
                    {
                        "ApiKeyAuth": []
                    }
                ],
                "description": "Get RoleDropDown",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Role"
                ],
                "summary": "Get RoleDropDown",
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "allOf": [
                                {
                                    "$ref": "#/definitions/common.ResponseHTTP"
                                },
                                {
                                    "type": "object",
                                    "properties": {
                                        "data": {
                                            "type": "array",
                                            "items": {
                                                "$ref": "#/definitions/controllers.RoleDropDown"
                                            }
                                        }
                                    }
                                }
                            ]
                        }
                    },
                    "404": {
                        "description": "Not Found",
                        "schema": {
                            "$ref": "#/definitions/common.ResponseHTTP"
                        }
                    }
                }
            }
        },
        "/email": {
            "post": {
                "security": [
                    {
                        "ApiKeyAuth": []
                    }
                ],
                "description": "Sending Email",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Utilities"
                ],
                "summary": "Send Email to",
                "parameters": [
                    {
                        "description": "messages",
                        "name": "User",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/messages.EmailMessage"
                        }
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "allOf": [
                                {
                                    "$ref": "#/definitions/common.ResponseHTTP"
                                },
                                {
                                    "type": "object",
                                    "properties": {
                                        "data": {
                                            "$ref": "#/definitions/messages.EmailMessage"
                                        }
                                    }
                                }
                            ]
                        }
                    },
                    "404": {
                        "description": "Not Found",
                        "schema": {
                            "$ref": "#/definitions/common.ResponseHTTP"
                        }
                    }
                }
            }
        },
        "/endpoint": {
            "get": {
                "security": [
                    {
                        "ApiKeyAuth": []
                    },
                    {
                        "Refresh": []
                    }
                ],
                "description": "Get Endpoints",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Endpoints"
                ],
                "summary": "Get Endpoints",
                "parameters": [
                    {
                        "type": "integer",
                        "description": "page",
                        "name": "page",
                        "in": "query",
                        "required": true
                    },
                    {
                        "type": "integer",
                        "description": "page size",
                        "name": "size",
                        "in": "query",
                        "required": true
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "allOf": [
                                {
                                    "$ref": "#/definitions/common.ResponsePagination"
                                },
                                {
                                    "type": "object",
                                    "properties": {
                                        "data": {
                                            "type": "array",
                                            "items": {
                                                "$ref": "#/definitions/models.EndpointGet"
                                            }
                                        }
                                    }
                                }
                            ]
                        }
                    },
                    "404": {
                        "description": "Not Found",
                        "schema": {
                            "$ref": "#/definitions/common.ResponseHTTP"
                        }
                    }
                }
            },
            "post": {
                "security": [
                    {
                        "ApiKeyAuth": []
                    }
                ],
                "description": "Add Endpoint",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Endpoints"
                ],
                "summary": "Add a new Endpoint",
                "parameters": [
                    {
                        "description": "Add Endpoint",
                        "name": "endpoint",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/models.EndpointPost"
                        }
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "allOf": [
                                {
                                    "$ref": "#/definitions/common.ResponseHTTP"
                                },
                                {
                                    "type": "object",
                                    "properties": {
                                        "data": {
                                            "$ref": "#/definitions/models.EndpointPost"
                                        }
                                    }
                                }
                            ]
                        }
                    },
                    "400": {
                        "description": "Bad Request",
                        "schema": {
                            "$ref": "#/definitions/common.ResponseHTTP"
                        }
                    },
                    "500": {
                        "description": "Internal Server Error",
                        "schema": {
                            "$ref": "#/definitions/common.ResponseHTTP"
                        }
                    }
                }
            }
        },
        "/endpoint/{endpoint_id}": {
            "get": {
                "security": [
                    {
                        "ApiKeyAuth": []
                    }
                ],
                "description": "Get endpoint by ID",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Endpoints"
                ],
                "summary": "Get Endpoint by ID",
                "parameters": [
                    {
                        "type": "integer",
                        "description": "Endpoint ID",
                        "name": "endpoint_id",
                        "in": "path",
                        "required": true
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "allOf": [
                                {
                                    "$ref": "#/definitions/common.ResponseHTTP"
                                },
                                {
                                    "type": "object",
                                    "properties": {
                                        "data": {
                                            "$ref": "#/definitions/models.EndpointGet"
                                        }
                                    }
                                }
                            ]
                        }
                    },
                    "404": {
                        "description": "Not Found",
                        "schema": {
                            "$ref": "#/definitions/common.ResponseHTTP"
                        }
                    }
                }
            },
            "delete": {
                "security": [
                    {
                        "ApiKeyAuth": []
                    }
                ],
                "description": "Remove endpoint by ID",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Endpoints"
                ],
                "summary": "Remove Endpoint by ID",
                "parameters": [
                    {
                        "type": "integer",
                        "description": "Endpoint ID",
                        "name": "endpoint_id",
                        "in": "path",
                        "required": true
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "$ref": "#/definitions/common.ResponseHTTP"
                        }
                    },
                    "404": {
                        "description": "Not Found",
                        "schema": {
                            "$ref": "#/definitions/common.ResponseHTTP"
                        }
                    },
                    "503": {
                        "description": "Service Unavailable",
                        "schema": {
                            "$ref": "#/definitions/common.ResponseHTTP"
                        }
                    }
                }
            },
            "patch": {
                "security": [
                    {
                        "ApiKeyAuth": []
                    }
                ],
                "description": "Patch Endpoint",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Endpoints"
                ],
                "summary": "Patch Endpoint",
                "parameters": [
                    {
                        "description": "Patch Endpoint",
                        "name": "endpoint",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/models.EndpointPost"
                        }
                    },
                    {
                        "type": "integer",
                        "description": "Endpoint ID",
                        "name": "endpoint_id",
                        "in": "path",
                        "required": true
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "allOf": [
                                {
                                    "$ref": "#/definitions/common.ResponseHTTP"
                                },
                                {
                                    "type": "object",
                                    "properties": {
                                        "data": {
                                            "$ref": "#/definitions/models.EndpointPost"
                                        }
                                    }
                                }
                            ]
                        }
                    },
                    "400": {
                        "description": "Bad Request",
                        "schema": {
                            "$ref": "#/definitions/common.ResponseHTTP"
                        }
                    },
                    "500": {
                        "description": "Internal Server Error",
                        "schema": {
                            "$ref": "#/definitions/common.ResponseHTTP"
                        }
                    }
                }
            }
        },
        "/endpointdrop": {
            "get": {
                "security": [
                    {
                        "ApiKeyAuth": []
                    }
                ],
                "description": "Get EndPointDropDown",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "EndPoints"
                ],
                "summary": "Get EndPointDropDown",
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "allOf": [
                                {
                                    "$ref": "#/definitions/common.ResponseHTTP"
                                },
                                {
                                    "type": "object",
                                    "properties": {
                                        "data": {
                                            "type": "array",
                                            "items": {
                                                "$ref": "#/definitions/controllers.EndPointDropDown"
                                            }
                                        }
                                    }
                                }
                            ]
                        }
                    },
                    "404": {
                        "description": "Not Found",
                        "schema": {
                            "$ref": "#/definitions/common.ResponseHTTP"
                        }
                    }
                }
            }
        },
        "/endpointfeature/{endpoint_id}": {
            "delete": {
                "security": [
                    {
                        "ApiKeyAuth": []
                    }
                ],
                "description": "Delete Feature Endpoint",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Features"
                ],
                "summary": "Delete Feature Endpoint",
                "parameters": [
                    {
                        "type": "integer",
                        "description": "Feature ID",
                        "name": "endpoint_id",
                        "in": "path",
                        "required": true
                    },
                    {
                        "type": "integer",
                        "description": "Endpoint ID",
                        "name": "feature_id",
                        "in": "query",
                        "required": true
                    }
                ],
                "responses": {
                    "400": {
                        "description": "Bad Request",
                        "schema": {
                            "$ref": "#/definitions/common.ResponseHTTP"
                        }
                    }
                }
            },
            "patch": {
                "security": [
                    {
                        "ApiKeyAuth": []
                    }
                ],
                "description": "Add Feature to Endpoint",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Features"
                ],
                "summary": "Add Feature to Endpoint",
                "parameters": [
                    {
                        "type": "integer",
                        "description": "Endpoint ID",
                        "name": "endpoint_id",
                        "in": "path",
                        "required": true
                    },
                    {
                        "type": "integer",
                        "description": " Feature ID",
                        "name": "feature_id",
                        "in": "query",
                        "required": true
                    }
                ],
                "responses": {
                    "400": {
                        "description": "Bad Request",
                        "schema": {
                            "$ref": "#/definitions/common.ResponseHTTP"
                        }
                    }
                }
            }
        },
        "/feature": {
            "get": {
                "security": [
                    {
                        "ApiKeyAuth": []
                    },
                    {
                        "Refresh": []
                    }
                ],
                "description": "Get Features",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Features"
                ],
                "summary": "Get Features",
                "parameters": [
                    {
                        "type": "integer",
                        "description": "page",
                        "name": "page",
                        "in": "query",
                        "required": true
                    },
                    {
                        "type": "integer",
                        "description": "page size",
                        "name": "size",
                        "in": "query",
                        "required": true
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "allOf": [
                                {
                                    "$ref": "#/definitions/common.ResponsePagination"
                                },
                                {
                                    "type": "object",
                                    "properties": {
                                        "data": {
                                            "type": "array",
                                            "items": {
                                                "$ref": "#/definitions/models.FeatureGet"
                                            }
                                        }
                                    }
                                }
                            ]
                        }
                    },
                    "404": {
                        "description": "Not Found",
                        "schema": {
                            "$ref": "#/definitions/common.ResponseHTTP"
                        }
                    }
                }
            },
            "post": {
                "security": [
                    {
                        "ApiKeyAuth": []
                    }
                ],
                "description": "Add Feature",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Features"
                ],
                "summary": "Add a new Feature",
                "parameters": [
                    {
                        "description": "Add Feature",
                        "name": "feature",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/models.FeaturePost"
                        }
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "allOf": [
                                {
                                    "$ref": "#/definitions/common.ResponseHTTP"
                                },
                                {
                                    "type": "object",
                                    "properties": {
                                        "data": {
                                            "$ref": "#/definitions/models.FeaturePost"
                                        }
                                    }
                                }
                            ]
                        }
                    },
                    "400": {
                        "description": "Bad Request",
                        "schema": {
                            "$ref": "#/definitions/common.ResponseHTTP"
                        }
                    },
                    "500": {
                        "description": "Internal Server Error",
                        "schema": {
                            "$ref": "#/definitions/common.ResponseHTTP"
                        }
                    }
                }
            }
        },
        "/feature/{feature_id}": {
            "get": {
                "security": [
                    {
                        "ApiKeyAuth": []
                    }
                ],
                "description": "Get feature by ID",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Features"
                ],
                "summary": "Get Feature by ID",
                "parameters": [
                    {
                        "type": "integer",
                        "description": "Feature ID",
                        "name": "feature_id",
                        "in": "path",
                        "required": true
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "allOf": [
                                {
                                    "$ref": "#/definitions/common.ResponseHTTP"
                                },
                                {
                                    "type": "object",
                                    "properties": {
                                        "data": {
                                            "$ref": "#/definitions/models.FeatureGet"
                                        }
                                    }
                                }
                            ]
                        }
                    },
                    "404": {
                        "description": "Not Found",
                        "schema": {
                            "$ref": "#/definitions/common.ResponseHTTP"
                        }
                    }
                }
            },
            "delete": {
                "security": [
                    {
                        "ApiKeyAuth": []
                    }
                ],
                "description": "Remove feature by ID",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Features"
                ],
                "summary": "Remove Feature by ID",
                "parameters": [
                    {
                        "type": "integer",
                        "description": "Feature ID",
                        "name": "feature_id",
                        "in": "path",
                        "required": true
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "$ref": "#/definitions/common.ResponseHTTP"
                        }
                    },
                    "404": {
                        "description": "Not Found",
                        "schema": {
                            "$ref": "#/definitions/common.ResponseHTTP"
                        }
                    },
                    "503": {
                        "description": "Service Unavailable",
                        "schema": {
                            "$ref": "#/definitions/common.ResponseHTTP"
                        }
                    }
                }
            },
            "patch": {
                "security": [
                    {
                        "ApiKeyAuth": []
                    }
                ],
                "description": "Patch Feature",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Features"
                ],
                "summary": "Patch Feature",
                "parameters": [
                    {
                        "description": "Patch Feature",
                        "name": "feature",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/models.FeaturePost"
                        }
                    },
                    {
                        "type": "integer",
                        "description": "Feature ID",
                        "name": "feature_id",
                        "in": "path",
                        "required": true
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "allOf": [
                                {
                                    "$ref": "#/definitions/common.ResponseHTTP"
                                },
                                {
                                    "type": "object",
                                    "properties": {
                                        "data": {
                                            "$ref": "#/definitions/models.FeaturePost"
                                        }
                                    }
                                }
                            ]
                        }
                    },
                    "400": {
                        "description": "Bad Request",
                        "schema": {
                            "$ref": "#/definitions/common.ResponseHTTP"
                        }
                    },
                    "500": {
                        "description": "Internal Server Error",
                        "schema": {
                            "$ref": "#/definitions/common.ResponseHTTP"
                        }
                    }
                }
            }
        },
        "/featuredrop": {
            "get": {
                "security": [
                    {
                        "ApiKeyAuth": []
                    }
                ],
                "description": "Get FeatureDropDown",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Feature"
                ],
                "summary": "Get FeatureDropDown",
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "allOf": [
                                {
                                    "$ref": "#/definitions/common.ResponseHTTP"
                                },
                                {
                                    "type": "object",
                                    "properties": {
                                        "data": {
                                            "type": "array",
                                            "items": {
                                                "$ref": "#/definitions/controllers.FeatureDropDown"
                                            }
                                        }
                                    }
                                }
                            ]
                        }
                    },
                    "404": {
                        "description": "Not Found",
                        "schema": {
                            "$ref": "#/definitions/common.ResponseHTTP"
                        }
                    }
                }
            }
        },
        "/featurerole/{feature_id}": {
            "delete": {
                "security": [
                    {
                        "ApiKeyAuth": []
                    }
                ],
                "description": "Delete Role Feature",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Roles"
                ],
                "summary": "Delete Role Feature",
                "parameters": [
                    {
                        "type": "integer",
                        "description": "Role ID",
                        "name": "feature_id",
                        "in": "path",
                        "required": true
                    },
                    {
                        "type": "integer",
                        "description": "Feature ID",
                        "name": "role_id",
                        "in": "query",
                        "required": true
                    }
                ],
                "responses": {
                    "400": {
                        "description": "Bad Request",
                        "schema": {
                            "$ref": "#/definitions/common.ResponseHTTP"
                        }
                    }
                }
            },
            "patch": {
                "security": [
                    {
                        "ApiKeyAuth": []
                    }
                ],
                "description": "Add Role to Feature",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Roles"
                ],
                "summary": "Add Role to Feature",
                "parameters": [
                    {
                        "type": "integer",
                        "description": "Feature ID",
                        "name": "feature_id",
                        "in": "path",
                        "required": true
                    },
                    {
                        "type": "integer",
                        "description": " Role ID",
                        "name": "role_id",
                        "in": "query",
                        "required": true
                    }
                ],
                "responses": {
                    "400": {
                        "description": "Bad Request",
                        "schema": {
                            "$ref": "#/definitions/common.ResponseHTTP"
                        }
                    }
                }
            }
        },
        "/features/{feature_id}": {
            "put": {
                "security": [
                    {
                        "ApiKeyAuth": []
                    }
                ],
                "description": "Activate/Deactivate Feature",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Feature"
                ],
                "summary": "Activate/Deactivate Feature",
                "parameters": [
                    {
                        "type": "integer",
                        "description": "Feature ID",
                        "name": "feature_id",
                        "in": "path",
                        "required": true
                    },
                    {
                        "type": "boolean",
                        "description": "Active",
                        "name": "active",
                        "in": "query",
                        "required": true
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "allOf": [
                                {
                                    "$ref": "#/definitions/common.ResponseHTTP"
                                },
                                {
                                    "type": "object",
                                    "properties": {
                                        "data": {
                                            "$ref": "#/definitions/models.FeaturePost"
                                        }
                                    }
                                }
                            ]
                        }
                    },
                    "400": {
                        "description": "Bad Request",
                        "schema": {
                            "$ref": "#/definitions/common.ResponseHTTP"
                        }
                    }
                }
            }
        },
        "/jwtsalt": {
            "get": {
                "security": [
                    {
                        "ApiKeyAuth": []
                    },
                    {
                        "Refresh": []
                    }
                ],
                "description": "Get JWTSalts",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "JWTSalts"
                ],
                "summary": "Get JWTSalts",
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "allOf": [
                                {
                                    "$ref": "#/definitions/common.ResponsePagination"
                                },
                                {
                                    "type": "object",
                                    "properties": {
                                        "data": {
                                            "$ref": "#/definitions/models.JWTSalt"
                                        }
                                    }
                                }
                            ]
                        }
                    },
                    "404": {
                        "description": "Not Found",
                        "schema": {
                            "$ref": "#/definitions/common.ResponseHTTP"
                        }
                    }
                }
            }
        },
        "/login": {
            "post": {
                "description": "Login",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Authentication"
                ],
                "summary": "Auth",
                "parameters": [
                    {
                        "description": "Login",
                        "name": "user",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/controllers.LoginPost"
                        }
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "allOf": [
                                {
                                    "$ref": "#/definitions/common.ResponseHTTP"
                                },
                                {
                                    "type": "object",
                                    "properties": {
                                        "data": {
                                            "$ref": "#/definitions/controllers.TokenResponse"
                                        }
                                    }
                                }
                            ]
                        }
                    },
                    "404": {
                        "description": "Not Found",
                        "schema": {
                            "$ref": "#/definitions/common.ResponseHTTP"
                        }
                    },
                    "503": {
                        "description": "Service Unavailable",
                        "schema": {
                            "$ref": "#/definitions/common.ResponseHTTP"
                        }
                    }
                }
            }
        },
        "/page": {
            "get": {
                "security": [
                    {
                        "ApiKeyAuth": []
                    },
                    {
                        "Refresh": []
                    }
                ],
                "description": "Get Pages",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Pages"
                ],
                "summary": "Get Pages",
                "parameters": [
                    {
                        "type": "integer",
                        "description": "page",
                        "name": "page",
                        "in": "query",
                        "required": true
                    },
                    {
                        "type": "integer",
                        "description": "page size",
                        "name": "size",
                        "in": "query",
                        "required": true
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "allOf": [
                                {
                                    "$ref": "#/definitions/common.ResponsePagination"
                                },
                                {
                                    "type": "object",
                                    "properties": {
                                        "data": {
                                            "type": "array",
                                            "items": {
                                                "$ref": "#/definitions/models.PageGet"
                                            }
                                        }
                                    }
                                }
                            ]
                        }
                    },
                    "404": {
                        "description": "Not Found",
                        "schema": {
                            "$ref": "#/definitions/common.ResponseHTTP"
                        }
                    }
                }
            },
            "post": {
                "security": [
                    {
                        "ApiKeyAuth": []
                    }
                ],
                "description": "Add Page",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Pages"
                ],
                "summary": "Add a new Page",
                "parameters": [
                    {
                        "description": "Add Page",
                        "name": "page",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/models.PagePost"
                        }
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "allOf": [
                                {
                                    "$ref": "#/definitions/common.ResponseHTTP"
                                },
                                {
                                    "type": "object",
                                    "properties": {
                                        "data": {
                                            "$ref": "#/definitions/models.PagePost"
                                        }
                                    }
                                }
                            ]
                        }
                    },
                    "400": {
                        "description": "Bad Request",
                        "schema": {
                            "$ref": "#/definitions/common.ResponseHTTP"
                        }
                    },
                    "500": {
                        "description": "Internal Server Error",
                        "schema": {
                            "$ref": "#/definitions/common.ResponseHTTP"
                        }
                    }
                }
            }
        },
        "/page/{page_id}": {
            "get": {
                "security": [
                    {
                        "ApiKeyAuth": []
                    }
                ],
                "description": "Get page by ID",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Pages"
                ],
                "summary": "Get Page by ID",
                "parameters": [
                    {
                        "type": "integer",
                        "description": "Page ID",
                        "name": "page_id",
                        "in": "path",
                        "required": true
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "allOf": [
                                {
                                    "$ref": "#/definitions/common.ResponseHTTP"
                                },
                                {
                                    "type": "object",
                                    "properties": {
                                        "data": {
                                            "$ref": "#/definitions/models.PageGet"
                                        }
                                    }
                                }
                            ]
                        }
                    },
                    "404": {
                        "description": "Not Found",
                        "schema": {
                            "$ref": "#/definitions/common.ResponseHTTP"
                        }
                    }
                }
            },
            "delete": {
                "security": [
                    {
                        "ApiKeyAuth": []
                    }
                ],
                "description": "Remove page by ID",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Pages"
                ],
                "summary": "Remove Page by ID",
                "parameters": [
                    {
                        "type": "integer",
                        "description": "Page ID",
                        "name": "page_id",
                        "in": "path",
                        "required": true
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "$ref": "#/definitions/common.ResponseHTTP"
                        }
                    },
                    "404": {
                        "description": "Not Found",
                        "schema": {
                            "$ref": "#/definitions/common.ResponseHTTP"
                        }
                    },
                    "503": {
                        "description": "Service Unavailable",
                        "schema": {
                            "$ref": "#/definitions/common.ResponseHTTP"
                        }
                    }
                }
            },
            "patch": {
                "security": [
                    {
                        "ApiKeyAuth": []
                    }
                ],
                "description": "Patch Page",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Pages"
                ],
                "summary": "Patch Page",
                "parameters": [
                    {
                        "description": "Patch Page",
                        "name": "page",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/models.PagePost"
                        }
                    },
                    {
                        "type": "integer",
                        "description": "Page ID",
                        "name": "page_id",
                        "in": "path",
                        "required": true
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "allOf": [
                                {
                                    "$ref": "#/definitions/common.ResponseHTTP"
                                },
                                {
                                    "type": "object",
                                    "properties": {
                                        "data": {
                                            "$ref": "#/definitions/models.PagePost"
                                        }
                                    }
                                }
                            ]
                        }
                    },
                    "400": {
                        "description": "Bad Request",
                        "schema": {
                            "$ref": "#/definitions/common.ResponseHTTP"
                        }
                    },
                    "500": {
                        "description": "Internal Server Error",
                        "schema": {
                            "$ref": "#/definitions/common.ResponseHTTP"
                        }
                    }
                }
            }
        },
        "/role": {
            "get": {
                "security": [
                    {
                        "ApiKeyAuth": []
                    },
                    {
                        "Refresh": []
                    }
                ],
                "description": "Get Roles",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Roles"
                ],
                "summary": "Get Roles",
                "parameters": [
                    {
                        "type": "integer",
                        "description": "page",
                        "name": "page",
                        "in": "query",
                        "required": true
                    },
                    {
                        "type": "integer",
                        "description": "page size",
                        "name": "size",
                        "in": "query",
                        "required": true
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "allOf": [
                                {
                                    "$ref": "#/definitions/common.ResponsePagination"
                                },
                                {
                                    "type": "object",
                                    "properties": {
                                        "data": {
                                            "type": "array",
                                            "items": {
                                                "$ref": "#/definitions/models.RoleGet"
                                            }
                                        }
                                    }
                                }
                            ]
                        }
                    },
                    "404": {
                        "description": "Not Found",
                        "schema": {
                            "$ref": "#/definitions/common.ResponseHTTP"
                        }
                    }
                }
            },
            "post": {
                "security": [
                    {
                        "ApiKeyAuth": []
                    }
                ],
                "description": "Add Role",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Roles"
                ],
                "summary": "Add a new Role",
                "parameters": [
                    {
                        "description": "Add Role",
                        "name": "role",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/models.RolePost"
                        }
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "allOf": [
                                {
                                    "$ref": "#/definitions/common.ResponseHTTP"
                                },
                                {
                                    "type": "object",
                                    "properties": {
                                        "data": {
                                            "$ref": "#/definitions/models.RolePost"
                                        }
                                    }
                                }
                            ]
                        }
                    },
                    "400": {
                        "description": "Bad Request",
                        "schema": {
                            "$ref": "#/definitions/common.ResponseHTTP"
                        }
                    },
                    "500": {
                        "description": "Internal Server Error",
                        "schema": {
                            "$ref": "#/definitions/common.ResponseHTTP"
                        }
                    }
                }
            }
        },
        "/role/{role_id}": {
            "get": {
                "security": [
                    {
                        "ApiKeyAuth": []
                    }
                ],
                "description": "Get role by ID",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Roles"
                ],
                "summary": "Get Role by ID",
                "parameters": [
                    {
                        "type": "integer",
                        "description": "Role ID",
                        "name": "role_id",
                        "in": "path",
                        "required": true
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "allOf": [
                                {
                                    "$ref": "#/definitions/common.ResponseHTTP"
                                },
                                {
                                    "type": "object",
                                    "properties": {
                                        "data": {
                                            "$ref": "#/definitions/models.RoleGet"
                                        }
                                    }
                                }
                            ]
                        }
                    },
                    "404": {
                        "description": "Not Found",
                        "schema": {
                            "$ref": "#/definitions/common.ResponseHTTP"
                        }
                    }
                }
            },
            "put": {
                "security": [
                    {
                        "ApiKeyAuth": []
                    }
                ],
                "description": "Activate/Deactivate",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Role"
                ],
                "summary": "Activate/Deactivate",
                "parameters": [
                    {
                        "type": "integer",
                        "description": "Role ID",
                        "name": "role_id",
                        "in": "path",
                        "required": true
                    },
                    {
                        "type": "boolean",
                        "description": "Active",
                        "name": "active",
                        "in": "query",
                        "required": true
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "allOf": [
                                {
                                    "$ref": "#/definitions/common.ResponseHTTP"
                                },
                                {
                                    "type": "object",
                                    "properties": {
                                        "data": {
                                            "$ref": "#/definitions/models.RolePost"
                                        }
                                    }
                                }
                            ]
                        }
                    },
                    "400": {
                        "description": "Bad Request",
                        "schema": {
                            "$ref": "#/definitions/common.ResponseHTTP"
                        }
                    }
                }
            },
            "delete": {
                "security": [
                    {
                        "ApiKeyAuth": []
                    }
                ],
                "description": "Remove role by ID",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Roles"
                ],
                "summary": "Remove Role by ID",
                "parameters": [
                    {
                        "type": "integer",
                        "description": "Role ID",
                        "name": "role_id",
                        "in": "path",
                        "required": true
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "$ref": "#/definitions/common.ResponseHTTP"
                        }
                    },
                    "404": {
                        "description": "Not Found",
                        "schema": {
                            "$ref": "#/definitions/common.ResponseHTTP"
                        }
                    },
                    "503": {
                        "description": "Service Unavailable",
                        "schema": {
                            "$ref": "#/definitions/common.ResponseHTTP"
                        }
                    }
                }
            },
            "patch": {
                "security": [
                    {
                        "ApiKeyAuth": []
                    }
                ],
                "description": "Patch Role",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Roles"
                ],
                "summary": "Patch Role",
                "parameters": [
                    {
                        "description": "Patch Role",
                        "name": "role",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/models.RolePost"
                        }
                    },
                    {
                        "type": "integer",
                        "description": "Role ID",
                        "name": "role_id",
                        "in": "path",
                        "required": true
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "allOf": [
                                {
                                    "$ref": "#/definitions/common.ResponseHTTP"
                                },
                                {
                                    "type": "object",
                                    "properties": {
                                        "data": {
                                            "$ref": "#/definitions/models.RolePost"
                                        }
                                    }
                                }
                            ]
                        }
                    },
                    "400": {
                        "description": "Bad Request",
                        "schema": {
                            "$ref": "#/definitions/common.ResponseHTTP"
                        }
                    },
                    "500": {
                        "description": "Internal Server Error",
                        "schema": {
                            "$ref": "#/definitions/common.ResponseHTTP"
                        }
                    }
                }
            }
        },
        "/role_endpoints": {
            "get": {
                "security": [
                    {
                        "ApiKeyAuth": []
                    }
                ],
                "description": "Get role EndPoints by ID",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Role"
                ],
                "summary": "Get EndPoints Role by ID",
                "parameters": [
                    {
                        "type": "integer",
                        "description": "Role ID",
                        "name": "role_id",
                        "in": "query",
                        "required": true
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "allOf": [
                                {
                                    "$ref": "#/definitions/common.ResponseHTTP"
                                },
                                {
                                    "type": "object",
                                    "properties": {
                                        "data": {
                                            "type": "array",
                                            "items": {
                                                "$ref": "#/definitions/models.EndpointGet"
                                            }
                                        }
                                    }
                                }
                            ]
                        }
                    },
                    "404": {
                        "description": "Not Found",
                        "schema": {
                            "$ref": "#/definitions/common.ResponseHTTP"
                        }
                    }
                }
            }
        },
        "/roleapp/{role_id}": {
            "delete": {
                "security": [
                    {
                        "ApiKeyAuth": []
                    }
                ],
                "description": "Delete App Role",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Apps"
                ],
                "summary": "Delete App Role",
                "parameters": [
                    {
                        "type": "integer",
                        "description": "App ID",
                        "name": "role_id",
                        "in": "path",
                        "required": true
                    },
                    {
                        "type": "integer",
                        "description": "Role ID",
                        "name": "app_id",
                        "in": "query",
                        "required": true
                    }
                ],
                "responses": {
                    "400": {
                        "description": "Bad Request",
                        "schema": {
                            "$ref": "#/definitions/common.ResponseHTTP"
                        }
                    }
                }
            },
            "patch": {
                "security": [
                    {
                        "ApiKeyAuth": []
                    }
                ],
                "description": "Add App to Role",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Apps"
                ],
                "summary": "Add App to Role",
                "parameters": [
                    {
                        "type": "integer",
                        "description": "Role ID",
                        "name": "role_id",
                        "in": "path",
                        "required": true
                    },
                    {
                        "type": "integer",
                        "description": " App ID",
                        "name": "app_id",
                        "in": "query",
                        "required": true
                    }
                ],
                "responses": {
                    "400": {
                        "description": "Bad Request",
                        "schema": {
                            "$ref": "#/definitions/common.ResponseHTTP"
                        }
                    }
                }
            }
        },
        "/rolepage/{role_id}/{page_id}": {
            "post": {
                "security": [
                    {
                        "ApiKeyAuth": []
                    }
                ],
                "description": "Add Role Page",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "RolePages"
                ],
                "summary": "Add Page to Role",
                "parameters": [
                    {
                        "type": "integer",
                        "description": "Role ID",
                        "name": "role_id",
                        "in": "path",
                        "required": true
                    },
                    {
                        "type": "integer",
                        "description": "Page ID",
                        "name": "page_id",
                        "in": "path",
                        "required": true
                    }
                ],
                "responses": {
                    "400": {
                        "description": "Bad Request",
                        "schema": {
                            "$ref": "#/definitions/common.ResponseHTTP"
                        }
                    }
                }
            },
            "delete": {
                "security": [
                    {
                        "ApiKeyAuth": []
                    }
                ],
                "description": "Delete Role Page",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Roles"
                ],
                "summary": "Add Page",
                "parameters": [
                    {
                        "type": "integer",
                        "description": "Role ID",
                        "name": "role_id",
                        "in": "path",
                        "required": true
                    },
                    {
                        "type": "integer",
                        "description": "Page ID",
                        "name": "page_id",
                        "in": "path",
                        "required": true
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "allOf": [
                                {
                                    "$ref": "#/definitions/common.ResponseHTTP"
                                },
                                {
                                    "type": "object",
                                    "properties": {
                                        "data": {
                                            "$ref": "#/definitions/models.PagePost"
                                        }
                                    }
                                }
                            ]
                        }
                    },
                    "400": {
                        "description": "Bad Request",
                        "schema": {
                            "$ref": "#/definitions/common.ResponseHTTP"
                        }
                    },
                    "500": {
                        "description": "Internal Server Error",
                        "schema": {
                            "$ref": "#/definitions/common.ResponseHTTP"
                        }
                    }
                }
            }
        },
        "/roleuser/{role_id}/{user_id}": {
            "post": {
                "security": [
                    {
                        "ApiKeyAuth": []
                    }
                ],
                "description": "Add Role User",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "RoleUsers"
                ],
                "summary": "Add User to Role",
                "parameters": [
                    {
                        "type": "integer",
                        "description": "Role ID",
                        "name": "role_id",
                        "in": "path",
                        "required": true
                    },
                    {
                        "type": "integer",
                        "description": "User ID",
                        "name": "user_id",
                        "in": "path",
                        "required": true
                    }
                ],
                "responses": {
                    "400": {
                        "description": "Bad Request",
                        "schema": {
                            "$ref": "#/definitions/common.ResponseHTTP"
                        }
                    }
                }
            },
            "delete": {
                "security": [
                    {
                        "ApiKeyAuth": []
                    }
                ],
                "description": "Delete Role User",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Roles"
                ],
                "summary": "Add User",
                "parameters": [
                    {
                        "type": "integer",
                        "description": "Role ID",
                        "name": "role_id",
                        "in": "path",
                        "required": true
                    },
                    {
                        "type": "integer",
                        "description": "User ID",
                        "name": "user_id",
                        "in": "path",
                        "required": true
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "allOf": [
                                {
                                    "$ref": "#/definitions/common.ResponseHTTP"
                                },
                                {
                                    "type": "object",
                                    "properties": {
                                        "data": {
                                            "$ref": "#/definitions/models.UserPost"
                                        }
                                    }
                                }
                            ]
                        }
                    },
                    "400": {
                        "description": "Bad Request",
                        "schema": {
                            "$ref": "#/definitions/common.ResponseHTTP"
                        }
                    },
                    "500": {
                        "description": "Internal Server Error",
                        "schema": {
                            "$ref": "#/definitions/common.ResponseHTTP"
                        }
                    }
                }
            }
        },
        "/user": {
            "get": {
                "security": [
                    {
                        "ApiKeyAuth": []
                    },
                    {
                        "Refresh": []
                    }
                ],
                "description": "Get Users",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Users"
                ],
                "summary": "Get Users",
                "parameters": [
                    {
                        "type": "integer",
                        "description": "page",
                        "name": "page",
                        "in": "query",
                        "required": true
                    },
                    {
                        "type": "integer",
                        "description": "page size",
                        "name": "size",
                        "in": "query",
                        "required": true
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "allOf": [
                                {
                                    "$ref": "#/definitions/common.ResponsePagination"
                                },
                                {
                                    "type": "object",
                                    "properties": {
                                        "data": {
                                            "type": "array",
                                            "items": {
                                                "$ref": "#/definitions/models.UserGet"
                                            }
                                        }
                                    }
                                }
                            ]
                        }
                    },
                    "404": {
                        "description": "Not Found",
                        "schema": {
                            "$ref": "#/definitions/common.ResponseHTTP"
                        }
                    }
                }
            },
            "put": {
                "security": [
                    {
                        "ApiKeyAuth": []
                    }
                ],
                "description": "Put User",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Users"
                ],
                "summary": "Put User",
                "parameters": [
                    {
                        "description": "Password User",
                        "name": "user",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/controllers.UserPassword"
                        }
                    },
                    {
                        "type": "boolean",
                        "description": "Reset Password",
                        "name": "reset",
                        "in": "query",
                        "required": true
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "allOf": [
                                {
                                    "$ref": "#/definitions/common.ResponseHTTP"
                                },
                                {
                                    "type": "object",
                                    "properties": {
                                        "data": {
                                            "$ref": "#/definitions/models.UserGet"
                                        }
                                    }
                                }
                            ]
                        }
                    },
                    "400": {
                        "description": "Bad Request",
                        "schema": {
                            "$ref": "#/definitions/common.ResponseHTTP"
                        }
                    }
                }
            },
            "post": {
                "security": [
                    {
                        "ApiKeyAuth": []
                    }
                ],
                "description": "Add User",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Users"
                ],
                "summary": "Add a new User",
                "parameters": [
                    {
                        "description": "Add User",
                        "name": "user",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/models.UserPost"
                        }
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "allOf": [
                                {
                                    "$ref": "#/definitions/common.ResponseHTTP"
                                },
                                {
                                    "type": "object",
                                    "properties": {
                                        "data": {
                                            "$ref": "#/definitions/models.UserPost"
                                        }
                                    }
                                }
                            ]
                        }
                    },
                    "400": {
                        "description": "Bad Request",
                        "schema": {
                            "$ref": "#/definitions/common.ResponseHTTP"
                        }
                    },
                    "500": {
                        "description": "Internal Server Error",
                        "schema": {
                            "$ref": "#/definitions/common.ResponseHTTP"
                        }
                    }
                }
            }
        },
        "/user/{user_id}": {
            "get": {
                "security": [
                    {
                        "ApiKeyAuth": []
                    }
                ],
                "description": "Get user by ID",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Users"
                ],
                "summary": "Get User by ID",
                "parameters": [
                    {
                        "type": "integer",
                        "description": "User ID",
                        "name": "user_id",
                        "in": "path",
                        "required": true
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "allOf": [
                                {
                                    "$ref": "#/definitions/common.ResponseHTTP"
                                },
                                {
                                    "type": "object",
                                    "properties": {
                                        "data": {
                                            "$ref": "#/definitions/models.UserGet"
                                        }
                                    }
                                }
                            ]
                        }
                    },
                    "404": {
                        "description": "Not Found",
                        "schema": {
                            "$ref": "#/definitions/common.ResponseHTTP"
                        }
                    }
                }
            },
            "put": {
                "security": [
                    {
                        "ApiKeyAuth": []
                    }
                ],
                "description": "Activate/Deactivate User",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Users"
                ],
                "summary": "Activate/Deactivate User",
                "parameters": [
                    {
                        "type": "integer",
                        "description": "User ID",
                        "name": "user_id",
                        "in": "path",
                        "required": true
                    },
                    {
                        "type": "boolean",
                        "description": "Disabled",
                        "name": "status",
                        "in": "query",
                        "required": true
                    }
                ],
                "responses": {
                    "400": {
                        "description": "Bad Request",
                        "schema": {
                            "$ref": "#/definitions/common.ResponseHTTP"
                        }
                    }
                }
            },
            "delete": {
                "security": [
                    {
                        "ApiKeyAuth": []
                    }
                ],
                "description": "Remove user by ID",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Users"
                ],
                "summary": "Remove User by ID",
                "parameters": [
                    {
                        "type": "integer",
                        "description": "User ID",
                        "name": "user_id",
                        "in": "path",
                        "required": true
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "$ref": "#/definitions/common.ResponseHTTP"
                        }
                    },
                    "404": {
                        "description": "Not Found",
                        "schema": {
                            "$ref": "#/definitions/common.ResponseHTTP"
                        }
                    },
                    "503": {
                        "description": "Service Unavailable",
                        "schema": {
                            "$ref": "#/definitions/common.ResponseHTTP"
                        }
                    }
                }
            },
            "patch": {
                "security": [
                    {
                        "ApiKeyAuth": []
                    }
                ],
                "description": "Patch User",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Users"
                ],
                "summary": "Patch User",
                "parameters": [
                    {
                        "description": "Patch User",
                        "name": "user",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/models.UserPost"
                        }
                    },
                    {
                        "type": "integer",
                        "description": "User ID",
                        "name": "user_id",
                        "in": "path",
                        "required": true
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "allOf": [
                                {
                                    "$ref": "#/definitions/common.ResponseHTTP"
                                },
                                {
                                    "type": "object",
                                    "properties": {
                                        "data": {
                                            "$ref": "#/definitions/models.UserPost"
                                        }
                                    }
                                }
                            ]
                        }
                    },
                    "400": {
                        "description": "Bad Request",
                        "schema": {
                            "$ref": "#/definitions/common.ResponseHTTP"
                        }
                    },
                    "500": {
                        "description": "Internal Server Error",
                        "schema": {
                            "$ref": "#/definitions/common.ResponseHTTP"
                        }
                    }
                }
            }
        },
        "/userrole/{user_id}/{role_id}": {
            "post": {
                "security": [
                    {
                        "ApiKeyAuth": []
                    }
                ],
                "description": "Add User Role",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "UserRoles"
                ],
                "summary": "Add Role to User",
                "parameters": [
                    {
                        "type": "integer",
                        "description": "User ID",
                        "name": "user_id",
                        "in": "path",
                        "required": true
                    },
                    {
                        "type": "integer",
                        "description": "Role ID",
                        "name": "role_id",
                        "in": "path",
                        "required": true
                    }
                ],
                "responses": {
                    "400": {
                        "description": "Bad Request",
                        "schema": {
                            "$ref": "#/definitions/common.ResponseHTTP"
                        }
                    }
                }
            },
            "delete": {
                "security": [
                    {
                        "ApiKeyAuth": []
                    }
                ],
                "description": "Delete User Role",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Users"
                ],
                "summary": "Add Role",
                "parameters": [
                    {
                        "type": "integer",
                        "description": "User ID",
                        "name": "user_id",
                        "in": "path",
                        "required": true
                    },
                    {
                        "type": "integer",
                        "description": "Role ID",
                        "name": "role_id",
                        "in": "path",
                        "required": true
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "allOf": [
                                {
                                    "$ref": "#/definitions/common.ResponseHTTP"
                                },
                                {
                                    "type": "object",
                                    "properties": {
                                        "data": {
                                            "$ref": "#/definitions/models.RolePost"
                                        }
                                    }
                                }
                            ]
                        }
                    },
                    "400": {
                        "description": "Bad Request",
                        "schema": {
                            "$ref": "#/definitions/common.ResponseHTTP"
                        }
                    },
                    "500": {
                        "description": "Internal Server Error",
                        "schema": {
                            "$ref": "#/definitions/common.ResponseHTTP"
                        }
                    }
                }
            }
        },
        "/useruuid": {
            "get": {
                "security": [
                    {
                        "ApiKeyAuth": []
                    }
                ],
                "description": "Get user by UUID",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Users"
                ],
                "summary": "Get User by UUID",
                "parameters": [
                    {
                        "type": "string",
                        "description": "User UUID",
                        "name": "uuid",
                        "in": "query",
                        "required": true
                    },
                    {
                        "type": "string",
                        "description": "App UUID",
                        "name": "app_uuid",
                        "in": "query",
                        "required": true
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "allOf": [
                                {
                                    "$ref": "#/definitions/common.ResponseHTTP"
                                },
                                {
                                    "type": "object",
                                    "properties": {
                                        "data": {
                                            "$ref": "#/definitions/models.UserNoRlnGet"
                                        }
                                    }
                                }
                            ]
                        }
                    },
                    "404": {
                        "description": "Not Found",
                        "schema": {
                            "$ref": "#/definitions/common.ResponseHTTP"
                        }
                    }
                }
            }
        }
    },
    "definitions": {
        "common.ResponseHTTP": {
            "type": "object",
            "properties": {
                "data": {},
                "details": {
                    "type": "string"
                },
                "success": {
                    "type": "boolean"
                }
            }
        },
        "common.ResponsePagination": {
            "type": "object",
            "properties": {
                "data": {},
                "details": {
                    "type": "string"
                },
                "page": {
                    "type": "integer"
                },
                "pages": {
                    "type": "integer"
                },
                "size": {
                    "type": "integer"
                },
                "success": {
                    "type": "boolean"
                },
                "total": {
                    "type": "integer"
                }
            }
        },
        "controllers.AppEndpointsMeta": {
            "type": "object",
            "additionalProperties": {
                "type": "array",
                "items": {
                    "type": "string"
                }
            }
        },
        "controllers.AppFeaturesMeta": {
            "type": "object",
            "additionalProperties": {
                "type": "array",
                "items": {
                    "type": "string"
                }
            }
        },
        "controllers.AppMeta": {
            "type": "object",
            "properties": {
                "name": {
                    "type": "string"
                },
                "roles": {
                    "type": "array",
                    "items": {
                        "$ref": "#/definitions/controllers.roles"
                    }
                },
                "uuid": {
                    "type": "string"
                }
            }
        },
        "controllers.EndPointDropDown": {
            "type": "object",
            "required": [
                "id",
                "name"
            ],
            "properties": {
                "id": {
                    "type": "integer"
                },
                "name": {
                    "type": "string"
                }
            }
        },
        "controllers.FeatureDropDown": {
            "type": "object",
            "required": [
                "id",
                "name"
            ],
            "properties": {
                "id": {
                    "type": "integer"
                },
                "name": {
                    "type": "string"
                }
            }
        },
        "controllers.LoginPost": {
            "type": "object",
            "required": [
                "grant_type"
            ],
            "properties": {
                "email": {
                    "type": "string",
                    "maxLength": 32,
                    "minLength": 6
                },
                "grant_type": {
                    "type": "string",
                    "example": "authorization_code"
                },
                "password": {
                    "type": "string"
                },
                "token": {
                    "type": "string"
                }
            }
        },
        "controllers.RoleDropDown": {
            "type": "object",
            "required": [
                "id",
                "name"
            ],
            "properties": {
                "id": {
                    "type": "integer"
                },
                "name": {
                    "type": "string"
                }
            }
        },
        "controllers.TokenResponse": {
            "type": "object",
            "properties": {
                "access_token": {
                    "type": "string"
                },
                "refresh_token": {
                    "type": "string"
                },
                "token_type": {
                    "type": "string"
                }
            }
        },
        "controllers.UserPassword": {
            "type": "object",
            "required": [
                "email",
                "password"
            ],
            "properties": {
                "email": {
                    "type": "string",
                    "example": "someone@domain.com"
                },
                "password": {
                    "type": "string"
                }
            }
        },
        "controllers.endpoints": {
            "type": "object",
            "properties": {
                "method": {
                    "type": "string"
                },
                "name": {
                    "type": "string"
                },
                "route_path": {
                    "type": "string"
                }
            }
        },
        "controllers.features": {
            "type": "object",
            "properties": {
                "endpoints": {
                    "type": "array",
                    "items": {
                        "$ref": "#/definitions/controllers.endpoints"
                    }
                },
                "name": {
                    "type": "string"
                }
            }
        },
        "controllers.roles": {
            "type": "object",
            "properties": {
                "features": {
                    "type": "array",
                    "items": {
                        "$ref": "#/definitions/controllers.features"
                    }
                },
                "name": {
                    "type": "string"
                }
            }
        },
        "messages.EmailMessage": {
            "type": "object",
            "required": [
                "emails",
                "message",
                "subject"
            ],
            "properties": {
                "emails": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    }
                },
                "message": {
                    "type": "string"
                },
                "subject": {
                    "type": "string"
                }
            }
        },
        "models.AppGet": {
            "description": "AppGet type information",
            "type": "object",
            "properties": {
                "active": {
                    "type": "boolean"
                },
                "description": {
                    "type": "string"
                },
                "id": {
                    "type": "integer"
                },
                "name": {
                    "type": "string"
                },
                "roles": {
                    "type": "array",
                    "items": {
                        "$ref": "#/definitions/models.Role"
                    }
                },
                "uuid": {
                    "type": "string"
                }
            }
        },
        "models.AppPost": {
            "description": "AppPost type information",
            "type": "object",
            "properties": {
                "description": {
                    "type": "string"
                },
                "name": {
                    "type": "string"
                }
            }
        },
        "models.Endpoint": {
            "description": "App type information",
            "type": "object",
            "properties": {
                "description": {
                    "type": "string"
                },
                "feature_id": {
                    "type": "number"
                },
                "id": {
                    "type": "integer"
                },
                "method": {
                    "type": "string"
                },
                "name": {
                    "type": "string"
                },
                "route_path": {
                    "type": "string"
                }
            }
        },
        "models.EndpointGet": {
            "description": "EndpointGet type information",
            "type": "object",
            "properties": {
                "description": {
                    "type": "string"
                },
                "feature_id": {
                    "type": "number"
                },
                "id": {
                    "type": "integer"
                },
                "method": {
                    "type": "string"
                },
                "name": {
                    "type": "string"
                },
                "route_path": {
                    "type": "string"
                }
            }
        },
        "models.EndpointPost": {
            "description": "EndpointPost type information",
            "type": "object",
            "properties": {
                "description": {
                    "type": "string"
                },
                "method": {
                    "type": "string"
                },
                "name": {
                    "type": "string"
                },
                "route_path": {
                    "type": "string"
                }
            }
        },
        "models.Feature": {
            "description": "App type information",
            "type": "object",
            "properties": {
                "active": {
                    "type": "boolean"
                },
                "description": {
                    "type": "string"
                },
                "endpoints": {
                    "type": "array",
                    "items": {
                        "$ref": "#/definitions/models.Endpoint"
                    }
                },
                "id": {
                    "type": "integer"
                },
                "name": {
                    "type": "string"
                },
                "role": {
                    "type": "number"
                }
            }
        },
        "models.FeatureGet": {
            "description": "FeatureGet type information",
            "type": "object",
            "properties": {
                "active": {
                    "type": "boolean"
                },
                "description": {
                    "type": "string"
                },
                "endpoints": {
                    "type": "array",
                    "items": {
                        "$ref": "#/definitions/models.Endpoint"
                    }
                },
                "id": {
                    "type": "integer"
                },
                "name": {
                    "type": "string"
                }
            }
        },
        "models.FeaturePost": {
            "description": "FeaturePost type information",
            "type": "object",
            "properties": {
                "active": {
                    "type": "boolean"
                },
                "description": {
                    "type": "string"
                },
                "name": {
                    "type": "string"
                }
            }
        },
        "models.JWTSalt": {
            "description": "App type information",
            "type": "object",
            "properties": {
                "id": {
                    "type": "integer"
                },
                "salt_a": {
                    "type": "string"
                },
                "salt_b": {
                    "type": "string"
                }
            }
        },
        "models.Page": {
            "description": "App type information",
            "type": "object",
            "properties": {
                "active": {
                    "type": "boolean"
                },
                "description": {
                    "type": "string"
                },
                "id": {
                    "type": "integer"
                },
                "name": {
                    "type": "string"
                },
                "roles": {
                    "type": "array",
                    "items": {
                        "$ref": "#/definitions/models.Role"
                    }
                }
            }
        },
        "models.PageGet": {
            "description": "PageGet type information",
            "type": "object",
            "properties": {
                "active": {
                    "type": "boolean"
                },
                "description": {
                    "type": "string"
                },
                "id": {
                    "type": "integer"
                },
                "name": {
                    "type": "string"
                },
                "roles": {
                    "type": "array",
                    "items": {
                        "$ref": "#/definitions/models.Role"
                    }
                }
            }
        },
        "models.PagePost": {
            "description": "PagePost type information",
            "type": "object",
            "properties": {
                "description": {
                    "type": "string"
                },
                "name": {
                    "type": "string"
                }
            }
        },
        "models.Role": {
            "description": "App type information",
            "type": "object",
            "properties": {
                "active": {
                    "type": "boolean"
                },
                "app": {
                    "type": "number"
                },
                "description": {
                    "type": "string"
                },
                "features": {
                    "type": "array",
                    "items": {
                        "$ref": "#/definitions/models.Feature"
                    }
                },
                "id": {
                    "type": "integer"
                },
                "name": {
                    "type": "string"
                },
                "pages": {
                    "type": "array",
                    "items": {
                        "$ref": "#/definitions/models.Page"
                    }
                },
                "users": {
                    "type": "array",
                    "items": {
                        "$ref": "#/definitions/models.User"
                    }
                }
            }
        },
        "models.RoleGet": {
            "description": "RoleGet type information",
            "type": "object",
            "properties": {
                "active": {
                    "type": "boolean"
                },
                "app": {
                    "type": "number"
                },
                "description": {
                    "type": "string"
                },
                "features": {
                    "type": "array",
                    "items": {
                        "$ref": "#/definitions/models.Feature"
                    }
                },
                "id": {
                    "type": "integer"
                },
                "name": {
                    "type": "string"
                },
                "users": {
                    "type": "array",
                    "items": {
                        "$ref": "#/definitions/models.User"
                    }
                }
            }
        },
        "models.RolePost": {
            "description": "RolePost type information",
            "type": "object",
            "required": [
                "description",
                "name"
            ],
            "properties": {
                "description": {
                    "type": "string"
                },
                "name": {
                    "type": "string"
                }
            }
        },
        "models.RolePut": {
            "description": "RolePut type information",
            "type": "object",
            "properties": {
                "active": {
                    "type": "boolean"
                },
                "description": {
                    "type": "string"
                },
                "id": {
                    "type": "integer"
                },
                "name": {
                    "type": "string"
                }
            }
        },
        "models.User": {
            "description": "App type information",
            "type": "object",
            "properties": {
                "date_registered": {
                    "type": "string"
                },
                "disabled": {
                    "type": "boolean"
                },
                "email": {
                    "type": "string"
                },
                "id": {
                    "type": "integer"
                },
                "password": {
                    "type": "string"
                },
                "roles": {
                    "type": "array",
                    "items": {
                        "$ref": "#/definitions/models.Role"
                    }
                },
                "uuid": {
                    "type": "string"
                }
            }
        },
        "models.UserGet": {
            "description": "UserGet type information",
            "type": "object",
            "properties": {
                "date_registered": {
                    "type": "string"
                },
                "disabled": {
                    "type": "boolean"
                },
                "email": {
                    "type": "string"
                },
                "id": {
                    "type": "integer"
                },
                "roles": {
                    "type": "array",
                    "items": {
                        "$ref": "#/definitions/models.Role"
                    }
                },
                "uuid": {
                    "type": "string"
                }
            }
        },
        "models.UserNoRlnGet": {
            "description": "UserGet type information",
            "type": "object",
            "properties": {
                "date_registered": {
                    "type": "string"
                },
                "disabled": {
                    "type": "boolean"
                },
                "email": {
                    "type": "string"
                },
                "id": {
                    "type": "integer"
                },
                "uuid": {
                    "type": "string"
                }
            }
        },
        "models.UserPost": {
            "description": "UserPost type information",
            "type": "object",
            "properties": {
                "disabled": {
                    "type": "boolean"
                },
                "email": {
                    "type": "string"
                },
                "password": {
                    "type": "string"
                }
            }
        }
    },
    "securityDefinitions": {
        "ApiKeyAuth": {
            "description": "Description for what is this security definition being used",
            "type": "apiKey",
            "name": "X-APP-TOKEN",
            "in": "header"
        },
        "Refresh": {
            "description": "Description for what is this security definition being used",
            "type": "apiKey",
            "name": "X-REFRESH-TOKEN",
            "in": "header"
        }
    }
}`

// SwaggerInfo holds exported Swagger Info so clients can modify it
var SwaggerInfo = &amp;swag.Spec{
        Version:          "0.1",
        Host:             "",
        BasePath:         "/api/v1",
        Schemes:          []string{},
        Title:            "Swagger blue-admin API",
        Description:      "This is blue-admin API OPENAPI Documentation.",
        InfoInstanceName: "swagger",
        SwaggerTemplate:  docTemplate,
        LeftDelim:        "{{",
        RightDelim:       "}}",
}

func init() <span class="cov8" title="1">{
        swag.Register(SwaggerInfo.InstanceName(), SwaggerInfo)
}</span>
</pre>
		
		<pre class="file" id="file19" style="display: none">
package main

import (
        "blue-admin.com/manager"
)

//        @title                        Swagger blue-admin API
//        @version                0.1
//        @description        This is blue-admin API OPENAPI Documentation.
//        @termsOfService        http://swagger.io/terms/
//  @BasePath  /api/v1

//        @securityDefinitions.apikey        ApiKeyAuth
//        @in                                                        header
//        @name                                                X-APP-TOKEN
//        @description                                Description for what is this security definition being used

//        @securityDefinitions.apikey Refresh
//        @in                                                        header
//        @name                                                X-REFRESH-TOKEN
//        @description                                Description for what is this security definition being used

func main() <span class="cov0" title="0">{
        manager.Execute()
}</span>
</pre>
		
		<pre class="file" id="file20" style="display: none">package manager

import (
        "blue-admin.com/messages"
        "github.com/spf13/cobra"
)

var (
        startconsumercli = &amp;cobra.Command{
                Use:   "start",
                Short: "start rabbit consumer",
                Long:  "Start rabbit app consumer",
                Run: func(cmd *cobra.Command, args []string) <span class="cov0" title="0">{
                        startconsumer()
                }</span>,
        }
)

func startconsumer() <span class="cov0" title="0">{
        messages.RabbitConsumer("esb", env)
        messages.RabbitConsumer("email", env)
}</span>

func init() <span class="cov8" title="1">{
        goFrame.AddCommand(startconsumercli)

}</span>
</pre>
		
		<pre class="file" id="file21" style="display: none">package manager

import (
        "context"
        "encoding/json"
        "errors"
        "fmt"
        "log"
        "net/http"
        "os"
        "strconv"
        "strings"
        "time"

        "os/signal"

        "blue-admin.com/bluetasks"
        "blue-admin.com/common"
        "blue-admin.com/configs"
        "blue-admin.com/controllers"
        "blue-admin.com/database"
        _ "blue-admin.com/docs"
        "blue-admin.com/messages"
        "blue-admin.com/observe"
        "github.com/ansrivas/fiberprometheus/v2"
        "github.com/gofiber/contrib/otelfiber"
        "github.com/gofiber/fiber/v2"
        "github.com/gofiber/fiber/v2/middleware/cors"
        "github.com/gofiber/fiber/v2/middleware/idempotency"
        "github.com/gofiber/fiber/v2/middleware/limiter"
        "github.com/gofiber/fiber/v2/middleware/logger"
        "github.com/gofiber/fiber/v2/middleware/monitor"
        "github.com/gofiber/fiber/v2/middleware/recover"
        "github.com/gofiber/swagger"
        "github.com/spf13/cobra"
        "go.opentelemetry.io/otel/attribute"
)

var (
        env                            string
        BlueAPIRoleManagementSystemcli = &amp;cobra.Command{
                Use:   "run",
                Short: "Run Development server ",
                Long:  `Run Blue API Role Management System development server`,
                Run: func(cmd *cobra.Command, args []string) <span class="cov0" title="0">{

                        switch env </span>{
                        case "":<span class="cov0" title="0">
                                fiber_run("dev")</span>
                        default:<span class="cov0" title="0">
                                fiber_run(env)</span>
                        }

                },
        }

        // Define flags using cobra's mechanism

)

func otelspanstarter(ctx *fiber.Ctx) error <span class="cov8" title="1">{
        //  creating trace context from span if they exist
        route_name := ctx.Path() + "_" + strings.ToLower(ctx.Route().Method)
        tracer, span := observe.FiberAppSpanner(ctx, fmt.Sprintf("%v-root", route_name))
        ctx.Locals("tracer", &amp;observe.RouteTracer{Tracer: tracer, Span: span})
        if err := ctx.Next(); err != nil </span><span class="cov8" title="1">{
                return err
        }</span>
        <span class="cov8" title="1">span.SetAttributes(attribute.String("response", ctx.Response().String()))
        span.End()
        return nil</span>
}

func dbsessioninjection(ctx *fiber.Ctx) error <span class="cov8" title="1">{
        db, err := database.ReturnSession()
        if err != nil </span><span class="cov0" title="0">{
                return ctx.Status(http.StatusServiceUnavailable).JSON(common.ResponseHTTP{
                        Success: false,
                        Message: err.Error(),
                        Data:    nil,
                })
        }</span>

        <span class="cov8" title="1">ctx.Locals("db", db)
        return ctx.Next()</span>
}

func NextFunc(contx *fiber.Ctx) error <span class="cov8" title="1">{
        return contx.Next()
}</span>

func fiber_run(env string) <span class="cov0" title="0">{

        prefork := false
        if env == "prod" </span><span class="cov0" title="0">{
                prefork = true
        }</span>
        //  Loading Configuration
        <span class="cov0" title="0">configs.AppConfig.SetEnv(env)

        //  Staring global tracer
        tp := observe.InitTracer()
        defer func() </span><span class="cov0" title="0">{
                if err := tp.Shutdown(context.Background()); err != nil </span><span class="cov0" title="0">{
                        log.Printf("Error shutting down tracer provider: %v", err)
                }</span>
        }()

        //  starting scheduler files
        <span class="cov0" title="0">schd := bluetasks.ScheduledTasks()
        defer schd.Stop()

        //  Creating App logger output file
        //  App should not start with out clearing log scheduler, so panic here error response
        log_file, err := bluetasks.Logfile()
        if err != nil </span><span class="cov0" title="0">{
                fmt.Printf("Error Creating Logfile %v\n", err)
                panic(err)</span>
        }

        // Basic App Configs
        <span class="cov0" title="0">body_limit, _ := strconv.Atoi(configs.AppConfig.GetOrDefault("BODY_LIMIT", "70"))
        read_buffer_size, _ := strconv.Atoi(configs.AppConfig.GetOrDefault("READ_BUFFER_SIZE", "70"))
        rate_limit_per_second, _ := strconv.Atoi(configs.AppConfig.GetOrDefault("RATE_LIMIT_PER_SECOND", "5000"))

        //load config file
        app := fiber.New(fiber.Config{
                Prefork: prefork,
                // Network:     fiber.NetworkTCP,
                // Immutable:   true,
                JSONEncoder:    json.Marshal,
                JSONDecoder:    json.Unmarshal,
                BodyLimit:      body_limit * 1024 * 1024,
                ReadBufferSize: read_buffer_size * 1024,
                ErrorHandler: func(ctx *fiber.Ctx, err error) error </span><span class="cov0" title="0">{
                        // Status code defaults to 500
                        code := fiber.StatusInternalServerError
                        // Retrieve the custom status code if it's a *fiber.Error
                        var e *fiber.Error
                        if errors.As(err, &amp;e) </span><span class="cov0" title="0">{
                                code = e.Code
                        }</span>
                        // Send custom error page
                        <span class="cov0" title="0">err = ctx.Status(code).SendFile(fmt.Sprintf("./%d.html", code))
                        if err != nil </span><span class="cov0" title="0">{
                                // In case the SendFile fails
                                return ctx.Status(fiber.StatusInternalServerError).SendString("Internal Server Error")
                        }</span>
                        // Return from handler
                        <span class="cov0" title="0">return nil</span>
                },
        })

        // recover from panic attacks middlerware
        <span class="cov0" title="0">app.Use(recover.New())

        //  rate limiting middleware
        app.Use(limiter.New(limiter.Config{
                Max:               rate_limit_per_second,
                Expiration:        1 * time.Second,
                LimiterMiddleware: limiter.SlidingWindow{},
        }))

        // adding group with authenthication middleware
        SetupRoutes(app)

        // idempotency middleware
        app.Use(idempotency.New(idempotency.Config{
                Lifetime: 10 * time.Second,
        }))

        // logger middle ware with the custom file writer object
        app.Use(logger.New(logger.Config{
                Format:     "\n${cyan}-[${time}]-[${ip}] -${white}${pid} ${red}${status} ${blue}[${method}] ${white}-${path}\n [${body}]\n[${error}]\n[${resBody}]\n[${reqHeaders}]\n[${queryParams}]\n",
                TimeFormat: "15:04:05",
                TimeZone:   "Local",
                Output:     log_file,
        }))

        // prometheus middleware concrete instance
        prometheus := fiberprometheus.New("gobluefiber")
        prometheus.RegisterAt(app, "/metrics")

        // prometheus monitoring middleware
        app.Use(prometheus.Middleware)

        // allow cross origin request
        app.Use(cors.New())

        // app.Get("/", func(c *fiber.Ctx) error {
        //         return c.SendString("Hello, World!\n")
        // })
        app.Static("/", "./dist")
        app.Get("/admin/*", func(ctx *fiber.Ctx) error </span><span class="cov0" title="0">{
                return ctx.SendFile("./dist/index.html")
        }</span>)
        <span class="cov0" title="0">app.Get("/admin", func(ctx *fiber.Ctx) error </span><span class="cov0" title="0">{
                return ctx.SendFile("./dist/index.html")
        }</span>)

        // swagger docs
        <span class="cov0" title="0">app.Get("/docs/*", swagger.HandlerDefault)
        app.Get("/docs/*", swagger.New()).Name("swagger_routes")

        // fiber native monitoring metrics endpoint
        app.Get("/lmetrics", monitor.New(monitor.Config{Title: "goBlue Metrics Page"})).Name("custom_metrics_route")

        //  Starting Apps and Conumers comes here below
        HTTP_PORT := configs.AppConfig.Get("HTTP_PORT")
        // starting on provided port
        go func(app *fiber.App) </span><span class="cov0" title="0">{
                app.Listen("0.0.0.0:" + HTTP_PORT)
        }</span>(app)

        // Starting App Conumers
        // // running background consumer on specific quues
        // the provided arument is the name of the queues
        <span class="cov0" title="0">go func() </span><span class="cov0" title="0">{
                messages.RabbitConsumer("email", env)
                messages.RabbitConsumer("esb", env)
        }</span>()

        <span class="cov0" title="0">c := make(chan os.Signal, 1)   // Create channel to signify a signal being sent
        signal.Notify(c, os.Interrupt) // When an interrupt or termination signal is sent, notify the channel

        &lt;-c // This blocks the main thread until an interrupt is received
        fmt.Println("Gracefully shutting down...")
        app.Shutdown()

        fmt.Println("Running cleanup tasks...")
        // Your cleanup tasks go here
        fmt.Println("Blue API Role Management System was successful shutdown.")</span>
}

func init() <span class="cov8" title="1">{
        BlueAPIRoleManagementSystemcli.Flags().StringVar(&amp;env, "env", "help", "Which environment to run for example prod or dev")
        goFrame.AddCommand(BlueAPIRoleManagementSystemcli)

}</span>

func SetupRoutes(app *fiber.App) <span class="cov8" title="1">{

        //app logging open telemetery
        app.Use(otelfiber.Middleware())
        // app otel spanner
        app.Use(otelspanstarter)

        // database session injection to local context
        app.Use(dbsessioninjection)

        gapp := app.Group("/api/v1")

        gapp.Get("/role", NextFunc).Name("get_all_roles").Get("/role", controllers.GetRoles)
        gapp.Get("/role/:role_id", NextFunc).Name("get_one_roles").Get("/role/:role_id", controllers.GetRoleByID)
        gapp.Post("/role", NextFunc).Name("post_role").Post("/role", controllers.PostRole)
        gapp.Patch("/role/:role_id", NextFunc).Name("patch_role").Patch("/role/:role_id", controllers.PatchRole)
        gapp.Delete("/role/:role_id", NextFunc).Name("delete_role").Delete("/role/:role_id", controllers.DeleteRole)
        gapp.Get("/droproles", NextFunc).Name("drop_roles").Get("/droproles", controllers.GetDropDownRoles)
        gapp.Put("/role/:role_id", NextFunc).Name("activate_deactivate_role").Put("/role/:role_id", controllers.ActivateDeactivateRoles)
        gapp.Get("/role_endpoints", NextFunc).Name("roles_endpoints").Get("/role_endpoints", controllers.GetRoleEndpointsID)

        gapp.Post("/userrole/:user_id/:role_id", NextFunc).Name("add_userrole").Post("/userrole/:user_id/:role_id", controllers.AddUserRoles)
        gapp.Delete("/userrole/:user_id/:role_id", NextFunc).Name("delete_userrole").Delete("/userrole/:user_id/:role_id", controllers.DeleteUserRoles)
        gapp.Patch("/featurerole/:feature_id", NextFunc).Name("add_featurerole").Patch("/featurerole/:feature_id", controllers.AddFeatureRoles)
        gapp.Delete("/featurerole/:feature_id", NextFunc).Name("delete_featurerole").Delete("/featurerole/:feature_id", controllers.DeleteFeatureRoles)

        gapp.Get("/app", NextFunc).Name("get_all_apps").Get("/app", controllers.GetApps)
        gapp.Get("/app/:app_id", NextFunc).Name("get_one_apps").Get("/app/:app_id", controllers.GetAppByID)
        gapp.Get("/appruid/:app_uuid", NextFunc).Name("get_app_roles_uuid").Get("/appruid/:app_uuid", controllers.GetAppRoleUUID)
        gapp.Post("/app", NextFunc).Name("post_app").Post("/app", controllers.PostApp)
        gapp.Patch("/app/:app_id", NextFunc).Name("patch_app").Patch("/app/:app_id", controllers.PatchApp)
        gapp.Delete("/app/:app_id", NextFunc).Name("delete_app").Delete("/app/:app_id", controllers.DeleteApp).Name("delete_app")

        gapp.Patch("/approle/:role_id", NextFunc).Name("add_roleapp").Patch("/approle/:role_id", controllers.AddRoleApps)
        gapp.Delete("/approle/:role_id", NextFunc).Name("delete_roleapp").Delete("/approle/:role_id", controllers.DeleteRoleApps)

        gapp.Get("/user", NextFunc).Name("get_all_users").Get("/user", controllers.GetUsers)
        gapp.Get("/user/:user_id", NextFunc).Name("get_one_users").Get("/user/:user_id", controllers.GetUserByID)
        gapp.Get("/useruuid", NextFunc).Name("get_one_user_uuid").Get("/useruuid", controllers.GetUserByUUID)
        gapp.Get("/appuser", NextFunc).Name("get_appusers_uuid").Get("/appusers", controllers.GetAppUsers)
        gapp.Get("/appuser/:user_id", NextFunc).Name("get_one_appuser_by_app_id").Get("appuser/:user_id", controllers.GetAppUserByID)
        gapp.Post("/user", NextFunc).Name("post_user").Post("/user", controllers.PostUser)
        gapp.Patch("/user/:user_id", NextFunc).Name("patch_user").Patch("/user/:user_id", controllers.PatchUser)
        gapp.Delete("/user/:user_id", NextFunc).Name("delete_user").Delete("/user/:user_id", controllers.DeleteUser)
        gapp.Delete("/appuser/:user_id", NextFunc).Name("delete_app_user").Delete("/appuser/:user_id", controllers.DeleteAppUser)
        gapp.Put("/user/:user_id", NextFunc).Name("activate_deactivate_user").Put("/user/:user_id", controllers.ActivateDeactivateUser)
        gapp.Put("/user", NextFunc).Name("change_reset_password").Put("/user", controllers.ChangePassword)

        gapp.Post("/roleuser/:role_id/:user_id", NextFunc).Name("add_roleuser").Post("/roleuser/:role_id/:user_id", controllers.AddRoleUsers)
        gapp.Delete("/roleuser/:role_id/:user_id", NextFunc).Name("delete_roleuser").Delete("/roleuser/:role_id/:user_id", controllers.DeleteRoleUsers)
        gapp.Post("/approleuser/:role_id/:user_id", NextFunc).Name("add_approleuser").Post("/approleuser/:role_id/:user_id", controllers.AddAppsRoleUsers)
        gapp.Delete("/approleuser/:role_id/:user_id", NextFunc).Name("delete_approleuser").Delete("/approleuser/:role_id/:user_id", controllers.DeleteAppRoleUsers)

        gapp.Get("/feature", NextFunc).Name("get_all_features").Get("/feature", controllers.GetFeatures)
        gapp.Get("/feature/:feature_id", NextFunc).Name("get_one_features").Get("/feature/:feature_id", controllers.GetFeatureByID)
        gapp.Post("/feature", NextFunc).Name("post_feature").Post("/feature", controllers.PostFeature)
        gapp.Patch("/feature/:feature_id", NextFunc).Name("patch_feature").Patch("/feature/:feature_id", controllers.PatchFeature)
        gapp.Delete("/feature/:feature_id", NextFunc).Name("delete_feature").Delete("/feature/:feature_id", controllers.DeleteFeature)
        gapp.Put("/feature/:feature_id", NextFunc).Name("activate_deactivate_features").Put("/feature/:feature_id", controllers.ActivateDeactivateFeature)
        gapp.Get("/featuredrop", NextFunc).Name("drop_features").Get("/featuredrop", controllers.GetDropFeatures)

        gapp.Patch("/endpointfeature/:endpoint_id", NextFunc).Name("add_endpointfeature").Patch("/endpointfeature/:endpoint_id", controllers.AddEndpointFeatures)
        gapp.Delete("/endpointfeature/:endpoint_id", NextFunc).Name("delete_endpointfeature").Delete("/endpointfeature/:endpoint_id", controllers.DeleteEndpointFeatures)

        gapp.Get("/endpoint", NextFunc).Name("get_all_endpoints").Get("/endpoint", controllers.GetEndpoints)
        gapp.Get("/endpoint/:endpoint_id", NextFunc).Name("get_one_endpoint").Get("/endpoint/:endpoint_id", controllers.GetEndpointByID)
        gapp.Post("/endpoint", NextFunc).Name("post_endpoint").Post("/endpoint", controllers.PostEndpoint)
        gapp.Patch("/endpoint/:endpoint_id", NextFunc).Name("patch_endpoint").Patch("/endpoint/:endpoint_id", controllers.PatchEndpoint)
        gapp.Delete("/endpoint/:endpoint_id", NextFunc).Name("delete_endpoint").Delete("/endpoint/:endpoint_id", controllers.DeleteEndpoint).Name("delete_endpoint")

        gapp.Get("/page", NextFunc).Name("get_all_pages").Get("/page", controllers.GetPages)
        gapp.Get("/page/:page_id", NextFunc).Name("get_one_pages").Get("/page/:page_id", controllers.GetPageByID)
        gapp.Post("/page", NextFunc).Name("post_page").Post("/page", controllers.PostPage)
        gapp.Patch("/page/:page_id", NextFunc).Name("patch_page").Patch("/page/:page_id", controllers.PatchPage)
        gapp.Delete("/page/:page_id", NextFunc).Name("delete_page").Delete("/page/:page_id", controllers.DeletePage).Name("delete_page")

        gapp.Post("/rolepage/:role_id/:page_id", NextFunc).Name("add_rolepage").Post("/rolepage/:role_id/:page_id", controllers.AddRolePages)
        gapp.Delete("/rolepage/:role_id/:page_id", NextFunc).Name("delete_rolepage").Delete("/rolepage/:role_id/:page_id", controllers.DeleteRolePages)

        // adding endpoints
        gapp.Get("/checklogin", NextFunc).Name("check_login").Get("/checklogin", controllers.CheckLogin)
        gapp.Post("/login", controllers.PostLogin)

        gapp.Get("/endpointdrop", NextFunc).Name("drop_endpoints").Get("/endpointdrop", controllers.GetDropEndPoints)
        gapp.Get("/appsdrop", NextFunc).Name("drop_sppd").Get("/appsdrop", controllers.GetDropApps)

        // adding email endpoint
        gapp.Get("/email", NextFunc).Name("send_email").Get("/email", controllers.SendEmail).Name("send_email")

        gapp.Get("/jwtsalt", NextFunc).Name("get_all_jwtsalts").Get("/jwtsalt", controllers.GetJWTSalts)

        // dashboard
        gapp.Get("/dashboard", NextFunc).Name("dashboard_one").Get("/dashboard", controllers.GetDashBoardGrouped)
        gapp.Get("/dashboardends", NextFunc).Name("dashboard_two").Get("/dashboardends", controllers.GetAppEndpoitnsGroupedBy)
        gapp.Get("/dashboardfeat", NextFunc).Name("dashboard_three").Get("/dashboardfeat", controllers.GetAppFeaturesGroupedBy)
        gapp.Get("/dashboardpages", NextFunc).Name("dashboard_four").Get("/dashboardpages", controllers.GetAppPages)
        gapp.Get("/dashboardroles", NextFunc).Name("dashboard_five").Get("/dashboardroles", controllers.GetAppRoles)
        gapp.Get("/dashboardrolespage", NextFunc).Name("dashboard_six").Get("/dashboardrolespage", controllers.GetAppPagesInRoles)

}</span>
</pre>
		
		<pre class="file" id="file22" style="display: none">package manager

import (
        "fmt"
        "os"

        "github.com/spf13/cobra"
)

var (
        goFrame = &amp;cobra.Command{
                Use:           "AppMan",
                Short:         "AppMan – command-line tool to aid structure you fiber backend projects with gorm",
                Long:          "Manager File Framed by go frame",
                Version:       "0.0.0",
                SilenceErrors: true,
                SilenceUsage:  true,
        }
)

// go build -tags netgo -ldflags '-s -w' -o app
func Execute() <span class="cov0" title="0">{
        if err := goFrame.Execute(); err != nil </span><span class="cov0" title="0">{

                fmt.Println(err)
                os.Exit(1)
        }</span>
}
</pre>
		
		<pre class="file" id="file23" style="display: none">package manager

import (
        "fmt"

        "blue-admin.com/models"
        "github.com/spf13/cobra"
)

var (
        BlueAPIRoleManagementSystemmigrate = &amp;cobra.Command{
                Use:   "migrate",
                Short: "Run Database Migration for found in init migration Models",
                Long:  `Migrate to init database`,
                Run: func(cmd *cobra.Command, args []string) <span class="cov0" title="0">{
                        init_migrate()
                }</span>,
        }

        BlueAPIRoleManagementSystemmigrateclean = &amp;cobra.Command{
                Use:   "clean",
                Short: "Drop Database Models for found in init migration Models",
                Long:  `Drop Models found in the models definition`,
                Run: func(cmd *cobra.Command, args []string) <span class="cov0" title="0">{
                        clean_database()
                }</span>,
        }
)

func init_migrate() <span class="cov0" title="0">{
        models.InitDatabase()
        fmt.Println("Migrated Database Models sucessfully")
}</span>

func clean_database() <span class="cov0" title="0">{
        models.CleanDatabase()
        fmt.Println("Dropped Tables sucessfully")
}</span>

func init() <span class="cov8" title="1">{
        goFrame.AddCommand(BlueAPIRoleManagementSystemmigrate)
        goFrame.AddCommand(BlueAPIRoleManagementSystemmigrateclean)
}</span>
</pre>
		
		<pre class="file" id="file24" style="display: none">
package messages

import (
        "crypto/tls"
        "fmt"

        "github.com/streadway/amqp"
        "blue-admin.com/configs"
)


func QeueConnect(queue_name string) (*amqp.Connection, *amqp.Channel, error) <span class="cov0" title="0">{

        // Getting Rabbit URI from the ENV file
        con_str := configs.AppConfig.Get("RABBIT_URI")

        // RabbitMQ TLS configuration
        tlsConfig := &amp;tls.Config{
                InsecureSkipVerify: true, // Set to false for production use
        }

        // Dial RabbitMQ server with TLS
        connection, err := amqp.DialTLS(con_str, tlsConfig)
        if err != nil </span><span class="cov0" title="0">{
                fmt.Printf("connectin to %v failed due to : %v \n", con_str, err)
        }</span>

        // creating a channel to create a queue
        // instance over the connection we have already
        // established.
        <span class="cov0" title="0">channel, err := connection.Channel()
        if err != nil </span><span class="cov0" title="0">{
                fmt.Printf("connectin to channel failed due to : %v\n", err)
        }</span>

        // With the instance and declare Queues that we can
        // publish and subscribe to.
        <span class="cov0" title="0">_, err = channel.QueueDeclare(
                queue_name, // queue name
                true,        // durable
                false,       // auto delete
                false,       // exclusive
                false,       // no wait
                nil,         // arguments
        )

        if err != nil </span><span class="cov0" title="0">{
                connection.Close() // Close the connection if queue declaration fails
                channel.Close()    // Close the channel
                fmt.Printf("creating queue to %v failed due to : %v\n",con_str, err)
        }</span>
        <span class="cov0" title="0">return connection, channel, nil</span>

}
</pre>
		
		<pre class="file" id="file25" style="display: none">package messages

import (
        "context"
        "encoding/json"
        "fmt"
        "io"
        "math/rand"
        "net/http"
        "net/http/httptrace"

        "github.com/google/uuid"
        "github.com/streadway/amqp"
        "go.opentelemetry.io/otel/attribute"

        "blue-admin.com/configs"
        "blue-admin.com/observe"

        "go.opentelemetry.io/contrib/instrumentation/net/http/httptrace/otelhttptrace"
        "go.opentelemetry.io/contrib/instrumentation/net/http/otelhttp"
        "go.opentelemetry.io/otel/propagation"
)

type sample_message struct{}

func RabbitConsumer(queue_name string, env string) <span class="cov0" title="0">{

        // Loading configuration file
        if env == "" </span><span class="cov0" title="0">{
                configs.AppConfig.SetEnv(env)
        }</span>

        //  tracer
        // tp := observe.InitTracer()
        // defer func() {
        //         if err := tp.Shutdown(context.Background()); err != nil {
        //                 log.Printf("Error shutting down tracer provider: %v", err)
        //         }
        // }()

        // Getting app connection and channel
        <span class="cov0" title="0">connection, channel, err := QeueConnect(queue_name)
        if err != nil </span><span class="cov0" title="0">{
                fmt.Println("Failed to establish connection:", err)
                return
        }</span>
        <span class="cov0" title="0">defer connection.Close()
        defer channel.Close()

        // ########################################
        // Declaring consumer with its properties over the channel opened
        msgs, err := channel.Consume(
                queue_name, // queue
                "",         // consumer
                false,      // auto ack
                false,      // exclusive
                false,      // no local
                false,      // no wait
                nil,        // args
        )

        // ###########################################

        if err != nil </span><span class="cov0" title="0">{
                fmt.Println("Failed to consume messages:", err)
                return
        }</span>

        // Process received messages based on their types
        // Using a goroutine for asynchronous message consumption
        <span class="cov0" title="0">go func(msg &lt;-chan amqp.Delivery) </span><span class="cov0" title="0">{
                ctx := context.Background()

                for msg := range msgs </span><span class="cov0" title="0">{
                        // Extract the span context out of the AMQP header.

                        switch msg.Type </span>{
                        case "BULK_MAIL":<span class="cov0" title="0"> // make sure provide the type in the published message so to switch
                                var message sample_message
                                err := json.Unmarshal(msg.Body, &amp;message)
                                if err != nil </span><span class="cov0" title="0">{
                                        fmt.Println("Failed to unmarshal message:", err)
                                        msg.Reject(true)
                                        break</span>
                                }
                                <span class="cov0" title="0">msg.Ack(true)</span>
                        case "REQUEST":<span class="cov0" title="0">
                                //  Parsing Request object
                                var reqData RequestObject
                                err := json.Unmarshal(msg.Body, &amp;reqData)
                                if err != nil </span><span class="cov0" title="0">{
                                        fmt.Println(err.Error())
                                }</span>

                                // extracting request from otel propagator
                                <span class="cov0" title="0">propagator := propagation.TraceContext{}
                                ctx = propagator.Extract(ctx, propagation.HeaderCarrier(reqData.Tp))

                                //starting span for http client request
                                tracer, span := observe.AppTracer.Start(ctx, fmt.Sprintf("started-esb%v", rand.Intn(1000)))

                                // client with otel http middleware
                                client := http.Client{
                                        Transport: otelhttp.NewTransport(
                                                http.DefaultTransport,
                                                // By setting the otelhttptrace client in this transport, it can be
                                                // injected into the context after the span is started, which makes the
                                                // httptrace spans children of the transport one.
                                                otelhttp.WithClientTrace(func(ctx context.Context) *httptrace.ClientTrace </span><span class="cov0" title="0">{
                                                        return otelhttptrace.NewClientTrace(ctx)
                                                }</span>),
                                        ),
                                }

                                // Build request to be sent
                                <span class="cov0" title="0">req, rerr := http.NewRequestWithContext(tracer, reqData.Method, fmt.Sprintf("http://%v%v", reqData.Host, reqData.Endpoint), nil)
                                if rerr != nil </span><span class="cov0" title="0">{
                                        fmt.Printf("failed to perform request ######: %v\n", rerr)
                                }</span>

                                // generating uuid
                                <span class="cov0" title="0">gen, _ := uuid.NewV7()
                                id := gen.String()

                                //  performing the request
                                req_body := fmt.Sprintf("Method: %v\t %v \nBody: %v\n", req.Method, req.URL, req.Body)
                                resp, err := client.Do(req)
                                if err != nil </span><span class="cov0" title="0">{
                                        fmt.Printf("failed to perform request: %v\n", err)
                                        span.SetAttributes(attribute.String("esb-id", id))
                                        span.SetAttributes(attribute.String("esb-request", req_body))
                                        span.SetAttributes(attribute.String("esb-error", err.Error()))
                                        msg.Reject(true)
                                        // msg.Ack(true)
                                        span.End()
                                        break</span>
                                }

                                <span class="cov0" title="0">body, _ := io.ReadAll(resp.Body)
                                span.SetAttributes(attribute.String("esb-id", id))
                                span.SetAttributes(attribute.String("esb-request", req_body))
                                span.SetAttributes(attribute.String("esb-response", string(body)))
                                msg.Ack(true)
                                span.End()</span>

                        default:<span class="cov0" title="0">
                                fmt.Println("Unknown Task Type")</span>
                        }
                }
        }(msgs)

        <span class="cov0" title="0">fmt.Println("Waiting for messages...")
        select </span>{}
}
</pre>
		
		<pre class="file" id="file26" style="display: none">package messages

import (
        "encoding/json"
        "fmt"

        "github.com/streadway/amqp"
)

type SampleMessage struct{}

func PublishMessageQueue(posted_message RequestObject, queue_name string) error <span class="cov0" title="0">{

        //   connection and channels from rabbitmq
        connection, channel, _ := QeueConnect(queue_name)
        defer connection.Close()
        defer channel.Close()

        // Create a message to publish.
        queue_message, _ := json.Marshal(posted_message)
        message := amqp.Publishing{
                ContentType: "application/json",
                Body:        []byte(queue_message),
                Type:        "REQUEST",
        }

        //send to rabbit app module qeue using channel
        // Attempt to publish a message to the queue.
        if err := channel.Publish(
                "",         // exchange
                queue_name, // queue name
                false,      // mandatory
                false,      // immediate
                message,    // message to publish
        ); err != nil </span><span class="cov0" title="0">{
                fmt.Println(err.Error())
                return err
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func PublishEmailQueue(posted_message EmailMessage, queue_name string) error <span class="cov0" title="0">{

        //   connection and channels from rabbitmq
        connection, channel, _ := QeueConnect(queue_name)
        defer connection.Close()
        defer channel.Close()

        // Create a message to publish.
        email_message, _ := json.Marshal(posted_message)
        message := amqp.Publishing{
                ContentType: "application/json",
                Body:        []byte(email_message),
                Type:        "BULK_MAIL",
        }

        //send to rabbit app module qeue using channel
        // Attempt to publish a message to the queue.
        if err := channel.Publish(
                "",         // exchange
                queue_name, // queue name
                false,      // mandatory
                false,      // immediate
                message,    // message to publish
        ); err != nil </span><span class="cov0" title="0">{
                fmt.Println(err.Error())
                return err
        }</span>
        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file27" style="display: none">package models

import (
        "github.com/google/uuid"
        "gorm.io/gorm"
)

// App Database model info
// @Description App type information
type App struct {
        ID          uint   `gorm:"primaryKey;autoIncrement:true" json:"id,omitempty"`
        Name        string `gorm:"not null; unique;" json:"name,omitempty"`
        UUID        string `gorm:"constraint:not null; unique; type:string;" json:"uuid"`
        Active      bool   `gorm:"default:true; constraint:not null;" json:"active"`
        Description string `gorm:"not null;" json:"description,omitempty"`
        Roles       []Role `gorm:"association_foreignkey:AppID constraint:OnUpdate:SET NULL OnDelete:SET NULL" json:"roles,omitempty"`
}

func (app *App) BeforeCreate(tx *gorm.DB) (err error) <span class="cov8" title="1">{
        gen, _ := uuid.NewV7()
        id := gen.String()
        app.UUID = id
        return
}</span>

// AppPost model info
// @Description AppPost type information
type AppPost struct {
        Name        string `gorm:"not null; unique;" json:"name,omitempty"`
        Description string `gorm:"not null;" json:"description,omitempty"`
}

// AppGet model info
// @Description AppGet type information
type AppGet struct {
        ID          uint   `gorm:"primaryKey;autoIncrement:true" json:"id,omitempty"`
        Name        string `gorm:"not null; unique;" json:"name,omitempty"`
        UUID        string `gorm:"constraint:not null; unique; type:string;" json:"uuid"`
        Active      bool   `gorm:"default:true; constraint:not null;" json:"active"`
        Description string `gorm:"not null;" json:"description,omitempty"`
        Roles       []Role `gorm:"association_foreignkey:AppID constraint:OnUpdate:SET NULL OnDelete:SET NULL" json:"roles,omitempty"`
}

// AppPut model info
// @Description AppPut type information
type AppPut struct {
        ID   uint   `gorm:"primaryKey;autoIncrement:true" json:"id,omitempty"`
        Name string `gorm:"not null; unique;" json:"name,omitempty"`

        Active      bool   `gorm:"default:true; constraint:not null;" json:"active"`
        Description string `gorm:"not null;" json:"description,omitempty"`
}

// AppPatch model info
// @Description AppPatch type information
type AppPatch struct {
        ID          uint   `gorm:"primaryKey;autoIncrement:true" json:"id,omitempty"`
        Name        string `gorm:"not null; unique;" json:"name,omitempty"`
        Active      bool   `gorm:"default:true; constraint:not null;" json:"active"`
        Description string `gorm:"not null;" json:"description,omitempty"`
}
</pre>
		
		<pre class="file" id="file28" style="display: none">package models

import (
        "crypto/sha512"
        "encoding/hex"
        "log"

        "blue-admin.com/configs"
        "blue-admin.com/database"

        "github.com/google/uuid"
        "gorm.io/gorm/clause"
)

var Endpoints_JSON = make(map[string]string)

// Combine password and salt then hash them using the SHA-512
func hashfunc(password string) string <span class="cov8" title="1">{

        // var salt []byte
        // get salt from env variable
        salt := []byte(configs.AppConfig.Get("SECRETE_SALT"))

        // Convert password string to byte slice
        var pwdByte = []byte(password)

        // Create sha-512 hasher
        var sha512 = sha512.New()

        pwdByte = append(pwdByte, salt...)

        sha512.Write(pwdByte)

        // Get the SHA-512 hashed password
        var hashedPassword = sha512.Sum(nil)

        // Convert the hashed to hex string
        var hashedPasswordHex = hex.EncodeToString(hashedPassword)
        return hashedPasswordHex
}</span>

func GetAppFeatures(app_uuid string) <span class="cov0" title="0">{
        db, _ := database.ReturnSession()
        var app App
        // var app_get = make(map[string]string)
        app_id, _ := uuid.Parse(app_uuid)
        if res := db.Model(&amp;App{}).Preload(clause.Associations).Preload("Roles.Features").Preload("Roles.Features.Endpoints").Where("uuid = ?", app_id).First(&amp;app); res.Error != nil </span><span class="cov0" title="0">{
                log.Fatal(res.Error.Error())
        }</span>

        <span class="cov0" title="0">for _, value := range app.Roles </span><span class="cov0" title="0">{
                key := value.Name
                for _, value := range value.Features </span><span class="cov0" title="0">{
                        for _, value := range value.Endpoints </span><span class="cov0" title="0">{
                                Endpoints_JSON[value.Name] = key
                        }</span>
                }

        }

}
</pre>
		
		<pre class="file" id="file29" style="display: none">package models

import (
        "fmt"
        "log"

        "blue-admin.com/configs"
        "blue-admin.com/database"
)

func InitDatabase() <span class="cov8" title="1">{
        configs.NewEnvFile("./configs")
        database, err := database.ReturnSession()
        fmt.Println("Connection Opened to Database")
        if err == nil </span><span class="cov8" title="1">{
                if err := database.AutoMigrate(
                        &amp;Role{},
                        &amp;App{},
                        &amp;User{},
                        &amp;Feature{},
                        &amp;Endpoint{},
                        &amp;Page{},
                        &amp;JWTSalt{},
                ); err != nil </span><span class="cov0" title="0">{
                        log.Fatalln(err)
                }</span>
                <span class="cov8" title="1">fmt.Println("Database Migrated")</span>
        } else<span class="cov0" title="0"> {
                panic(err)</span>
        }
}

func CleanDatabase() <span class="cov8" title="1">{
        configs.NewEnvFile("./configs")
        database, err := database.ReturnSession()

        if err == nil </span><span class="cov8" title="1">{
                fmt.Println("Connection Opened to Database")
                fmt.Println("Dropping Models if Exist")
                database.Migrator().DropTable(
                        &amp;Role{},
                        &amp;App{},
                        &amp;User{},
                        &amp;Feature{},
                        &amp;Endpoint{},
                        &amp;Page{},
                        &amp;JWTSalt{},
                )
                fmt.Println("Database Cleaned")
                // Reset autoincrement values
                result := database.Exec("Delete from sqlite_sequence;")
                if result.Error != nil </span><span class="cov0" title="0">{
                        fmt.Println("Clean Database Function: " + result.Error.Error())
                }</span>
        } else<span class="cov0" title="0"> {
                panic(err)</span>
        }
}
</pre>
		
		<pre class="file" id="file30" style="display: none">package models

import (
        "time"

        "github.com/google/uuid"
        "gorm.io/gorm"
)

// User Database model info
// @Description App type information
type User struct {
        ID            uint      `gorm:"primaryKey;autoIncrement:true" json:"id,omitempty"`
        Email         string    `gorm:"not null; unique;" json:"email,omitempty"`
        Password      string    `gorm:"not null;" json:"password,omitempty"`
        DateRegistred time.Time `gorm:"constraint:not null; default:current_timestamp;" json:"date_registered,omitempty"`
        Disabled      bool      `gorm:"default:true; constraint:not null;" json:"disabled"`
        UUID          string    `gorm:"constraint:not null; unique; type:string;" json:"uuid"`
        Roles         []Role    `gorm:"many2many:user_roles; constraint:OnUpdate:CASCADE; OnDelete:CASCADE;" json:"roles,omitempty"`
}

func (user *User) BeforeCreate(tx *gorm.DB) (err error) <span class="cov8" title="1">{
        gen, _ := uuid.NewV7()
        id := gen.String()
        user.UUID = id
        user.Password = hashfunc(user.Password)
        return
}</span>

// UserPost model info
// @Description UserPost type information
type UserPost struct {
        Email    string `gorm:"not null; unique;" json:"email,omitempty"`
        Password string `gorm:"not null;" json:"password,omitempty"`
        Disabled bool   `gorm:"default:true; constraint:not null;" json:"disabled"`
}

// UserGet model info
// @Description UserGet type information
type UserGet struct {
        ID            uint      `gorm:"primaryKey;autoIncrement:true" json:"id,omitempty"`
        Email         string    `gorm:"not null; unique;" json:"email,omitempty"`
        DateRegistred time.Time `gorm:"constraint:not null; default:current_timestamp;" json:"date_registered,omitempty"`
        Disabled      bool      `gorm:"default:true; constraint:not null;" json:"disabled"`
        UUID          string    `gorm:"constraint:not null; unique; type:string;" json:"uuid"`
        Roles         []Role    `gorm:"many2many:user_roles; constraint:OnUpdate:CASCADE; OnDelete:CASCADE;" json:"roles,omitempty"`
}

// UserGet model info
// @Description UserGet type information
type UserNoRlnGet struct {
        ID            uint      `gorm:"primaryKey;autoIncrement:true" json:"id,omitempty"`
        Email         string    `gorm:"not null; unique;" json:"email,omitempty"`
        DateRegistred time.Time `gorm:"constraint:not null; default:current_timestamp;" json:"date_registered,omitempty"`
        Disabled      bool      `gorm:"default:true; constraint:not null;" json:"disabled"`
        UUID          string    `gorm:"constraint:not null; unique; type:string;" json:"uuid"`
}

// UserPut model info
// @Description UserPut type information
type UserPut struct {
        Email         string    `gorm:"not null; unique;" json:"email,omitempty"`
        Password      string    `gorm:"not null;" json:"password,omitempty"`
        DateRegistred time.Time `gorm:"constraint:not null; default:current_timestamp;" json:"date_registered,omitempty"`
        Disabled      bool      `gorm:"default:true; constraint:not null;" json:"disabled"`
}

// UserPatch model info
// @Description UserPatch type information
type UserPatch struct {
        Email    string `gorm:"not null; unique;" json:"email,omitempty"`
        Disabled bool   `gorm:"default:true; constraint:not null;" json:"disabled"`
}
</pre>
		
		<pre class="file" id="file31" style="display: none">package observe

import (
        "context"
        "fmt"
        "strings"

        "github.com/google/uuid"

        "blue-admin.com/configs"
        "github.com/gofiber/fiber/v2"
        "go.opentelemetry.io/otel"
        "go.opentelemetry.io/otel/attribute"
        "go.opentelemetry.io/otel/exporters/otlp/otlptrace/otlptracegrpc"
        "go.opentelemetry.io/otel/propagation"
        "go.opentelemetry.io/otel/sdk/resource"
        sdktrace "go.opentelemetry.io/otel/sdk/trace"
        semconv "go.opentelemetry.io/otel/semconv/v1.4.0"
        oteltrace "go.opentelemetry.io/otel/trace"
)

var AppTracer = otel.Tracer(fmt.Sprintf("badmin-server-%v", configs.AppConfig.Get("APP_NAME")))

func InitTracer() *sdktrace.TracerProvider <span class="cov0" title="0">{
        traceExporter := configs.AppConfig.Get("TRACE_EXPORTER")
        tracerHost := configs.AppConfig.Get("TRACER_HOST")
        tracerPort := configs.AppConfig.GetOrDefault("TRACER_PORT", "9411")

        tp := sdktrace.NewTracerProvider(
                sdktrace.WithResource(resource.NewWithAttributes(
                        semconv.SchemaURL,
                        semconv.ServiceNameKey.String(configs.AppConfig.Get("APP_NAME")),
                )),
        )
        // app logger with jager

        otel.SetTracerProvider(tp)
        otel.SetTextMapPropagator(propagation.NewCompositeTextMapPropagator(propagation.TraceContext{}, propagation.Baggage{}))
        // otel.SetErrorHandler(&amp;otelErrorHandler{logger: app_logger})

        const traceExporterFiber = "fiber"

        if (traceExporter != "" &amp;&amp; tracerHost != "") || traceExporter == traceExporterFiber </span><span class="cov0" title="0">{
                var (
                        exporter sdktrace.SpanExporter
                        // err      error
                )

                switch strings.ToLower(traceExporter) </span>{
                case "jaeger":<span class="cov0" title="0">
                        // app_logger.Log("Exporting traces to jaeger.")

                        exporter, _ = otlptracegrpc.New(context.Background(), otlptracegrpc.WithInsecure(),
                                otlptracegrpc.WithEndpoint(fmt.Sprintf("%s:%s", tracerHost, tracerPort)))

                        batcher := sdktrace.NewBatchSpanProcessor(exporter)
                        tp.RegisterSpanProcessor(batcher)</span>
                }
        }
        <span class="cov0" title="0">return tp</span>
}

func FiberAppSpanner(ctx *fiber.Ctx, span_name string) (context.Context, oteltrace.Span) <span class="cov8" title="1">{
        gen, _ := uuid.NewV7()
        id := gen.String()

        trace, span := AppTracer.Start(ctx.UserContext(), span_name,
                oteltrace.WithAttributes(attribute.String("id", id)),
                oteltrace.WithAttributes(attribute.String("request", ctx.Request().String())),
        )
        return trace, span
}</span>

type RouteTracer struct {
        Tracer context.Context
        Span   oteltrace.Span
}
</pre>
		
		<pre class="file" id="file32" style="display: none">package tests

import (
        "blue-admin.com/manager"
        "github.com/gofiber/fiber/v2"
        "github.com/joho/godotenv"
)

var (
        TestApp   *fiber.App
        groupPath = "/api/v1"
)

func setupUserTestApp() <span class="cov8" title="1">{
        godotenv.Load(".test.env")
        TestApp = fiber.New()
        manager.SetupRoutes(TestApp)
}</span>
</pre>
		
		<pre class="file" id="file33" style="display: none">package utils

import (
        "math/rand"
        "strconv"

        "blue-admin.com/configs"
        "blue-admin.com/database"
        "blue-admin.com/models"
)

const (
        charsetLen = 62
        charset    = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789"
)

func GenerateRandomString(length int) (string, error) <span class="cov8" title="1">{
        result := make([]byte, length)

        for i := 0; i &lt; length; i++ </span><span class="cov8" title="1">{
                index := rand.Intn(charsetLen)
                result[i] = charset[index]
        }</span>

        <span class="cov8" title="1">return string(result), nil</span>
}

func JWTSaltUpdate() <span class="cov8" title="1">{
        dbcon, _ := database.ReturnSession()

        //  getting salt length from configuration file
        salt_length, _ := strconv.Atoi(configs.AppConfig.Get("JWT_SALT_LENGTH"))

        //  generating for salt A
        salt_a, _ := GenerateRandomString(salt_length)

        //  defining jwt _object to work with
        var jwt_object models.JWTSalt

        // Fethching the JWT object if it exists
        dbcon.Model(&amp;models.JWTSalt{}).Where("id = ?", 1).First(&amp;jwt_object)

        // If it exists updating or creating if it does not exist
        if jwt_object.ID == 1 </span><span class="cov0" title="0">{
                // salt_b =
                jwt_object.SaltB = jwt_object.SaltA
                jwt_object.SaltA = salt_a

                tx := dbcon.Begin()
                if err := dbcon.Updates(&amp;jwt_object).Error; err != nil </span><span class="cov0" title="0">{

                        tx.Rollback()
                }</span>
                <span class="cov0" title="0">tx.Commit()</span>
        } else<span class="cov8" title="1"> {
                // generating salt b and creating new
                salt_b, _ := GenerateRandomString(salt_length)
                jwt_object.SaltA = salt_a
                jwt_object.SaltB = salt_b

                tx := dbcon.Begin()
                // add  data using transaction if values are valid
                if err := tx.Create(&amp;jwt_object).Error; err != nil </span><span class="cov8" title="1">{

                        tx.Rollback()

                }</span>
                <span class="cov8" title="1">tx.Commit()</span>
        }

}

func GetJWTSalt() (salt_a string, salt_b string) <span class="cov8" title="1">{
        dbcon, _ := database.ReturnSession()
        var jwt_object models.JWTSalt

        // Fethching the JWT object if it exists
        dbcon.Model(&amp;models.JWTSalt{}).Where("id = ?", 1).First(&amp;jwt_object)

        salt_a = jwt_object.SaltA
        salt_b = jwt_object.SaltB
        if salt_a == "" </span><span class="cov8" title="1">{
                JWTSaltUpdate()
        }</span>
        <span class="cov8" title="1">return salt_a, salt_b</span>

}
</pre>
		
		<pre class="file" id="file34" style="display: none">package utils

import (
        "context"
        "fmt"
        "net/smtp"
        "os"
        "strings"

        "blue-admin.com/configs"
)

type Mail struct {
        Sender  string
        To      []string
        Subject string
        Body    string
}

func SendEmailConsumer(ctx context.Context, msg string, sub string, emails []string) <span class="cov0" title="0">{
        // email server
        host := configs.AppConfig.Get("MAIL_SERVER")
        port := configs.AppConfig.Get("MAIL_PORT")
        sender_email := configs.AppConfig.Get("MAIL_USERNAME")
        password := configs.AppConfig.Get("MAIL_PASSWORD")

        body_msg := fmt.Sprintf("&lt;p&gt;&lt;b&gt;%s&lt;/b&gt;&lt;/p&gt;", msg)
        request := Mail{
                Sender:  sender_email,
                To:      emails,
                Subject: sub,
                Body:    body_msg,
        }
        my_msg := BuildMessage(request)

        // We can't send strings directly in mail,
        // strings need to be converted into slice bytes
        msg_body := []byte(my_msg)

        // PlainAuth uses the given username and password to
        // authenticate to host and act as identity.
        // Usually identity should be the empty string,
        // to act as username.
        auth := smtp.PlainAuth("", sender_email, password, host)

        // SendMail uses TLS connection to send the mail
        // The email is sent to all address in the toList,
        // the body should be of type bytes, not strings
        // This returns error if any occurred.
        err := smtp.SendMail(host+":"+port, auth, sender_email, emails, msg_body)

        // handling the errors
        if err != nil </span><span class="cov0" title="0">{
                fmt.Println(err)
                os.Exit(1)
        }</span>

        <span class="cov0" title="0">fmt.Println("Successfully sent mail to all user in toList")</span>
}

func BuildMessage(mail Mail) string <span class="cov0" title="0">{
        msg := "MIME-version: 1.0;\nContent-Type: text/html; charset=\"UTF-8\";\r\n"
        msg += fmt.Sprintf("From: %s\r\n", mail.Sender)
        msg += fmt.Sprintf("To: %s\r\n", strings.Join(mail.To, ";"))
        msg += fmt.Sprintf("Subject: %s\r\n", mail.Subject)
        msg += fmt.Sprintf("\r\n%s\r\n", mail.Body)

        return msg
}</span>
</pre>
		
		<pre class="file" id="file35" style="display: none">package utils

import (
        "crypto/sha512"
        "encoding/hex"
        "fmt"
        "time"

        "blue-admin.com/configs"
        "github.com/golang-jwt/jwt/v5"
)

type UserClaim struct {
        jwt.RegisteredClaims
        Email string   `json:"email"`
        Roles []string `json:"roles"`
        UUID  string   `json:"uuid"`
}

// Combine password and salt then hash them using the SHA-512
func HashFunc(password string) string <span class="cov8" title="1">{

        // var salt []byte
        // get salt from env variable
        hsalt := configs.AppConfig.Get("SECRETE_SALT")
        if configs.AppConfig.Get("SECRETE_SALT") == "" </span><span class="cov8" title="1">{
                hsalt = "test_salt"
        }</span>
        <span class="cov8" title="1">salt := []byte(hsalt)

        // Convert password string to byte slice
        var pwdByte = []byte(password)

        // Create sha-512 hasher
        var sha512 = sha512.New()

        pwdByte = append(pwdByte, salt...)

        sha512.Write(pwdByte)

        // Get the SHA-512 hashed password
        var hashedPassword = sha512.Sum(nil)

        // Convert the hashed to hex string
        var hashedPasswordHex = hex.EncodeToString(hashedPassword)
        return hashedPasswordHex</span>
}

func PasswordsMatch(hashedPassword, currPassword string) bool <span class="cov8" title="1">{

        var currPasswordHash = HashFunc(currPassword)
        return hashedPassword == currPasswordHash
}</span>

// source of this token encode decode functions
// https://github.com/gurleensethi/go-jwt-tutorial/blob/main/main.go
func CreateJWTToken(email string, uuid string, roles []string, duration int) (string, error) <span class="cov8" title="1">{
        my_claim := UserClaim{
                RegisteredClaims: jwt.RegisteredClaims{},
                Email:            email,
                Roles:            roles,
                UUID:             uuid,
        }

        salt_a, _ := GetJWTSalt()
        exp := time.Now().UTC().Add(time.Duration(duration) * time.Minute)
        my_claim.ExpiresAt = jwt.NewNumericDate(exp)
        my_claim.Issuer = "Blue Admin"
        my_claim.Subject = "UI Authentication Token"
        token := jwt.NewWithClaims(jwt.SigningMethodHS512, my_claim)
        signedString, err := token.SignedString([]byte(salt_a))
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("error creating signed string: %v", err)
        }</span>

        <span class="cov8" title="1">return signedString, nil</span>
}

func ParseJWTToken(jwtToken string) (UserClaim, error) <span class="cov8" title="1">{
        salt_a, salt_b := GetJWTSalt()
        response_a := UserClaim{}
        response_b := UserClaim{}

        token_a, aerr := jwt.ParseWithClaims(jwtToken, &amp;response_a, func(token *jwt.Token) (interface{}, error) </span><span class="cov8" title="1">{
                return []byte(salt_a), nil
        }</span>)
        <span class="cov8" title="1">token_b, berr := jwt.ParseWithClaims(jwtToken, &amp;response_b, func(token *jwt.Token) (interface{}, error) </span><span class="cov8" title="1">{
                return []byte(salt_b), nil
        }</span>)

        <span class="cov8" title="1">if aerr != nil &amp;&amp; berr != nil </span><span class="cov8" title="1">{
                return UserClaim{}, aerr
        }</span>

        // check token validity, for example token might have been expired
        <span class="cov8" title="1">if !token_a.Valid </span><span class="cov0" title="0">{
                if !token_b.Valid </span><span class="cov0" title="0">{
                        return UserClaim{}, fmt.Errorf("invalid token with second salt")
                }</span>
                <span class="cov0" title="0">return response_b, nil</span>
        }
        <span class="cov8" title="1">return response_a, nil</span>

}

// Return Unique values in list
func UniqueSlice(slice []string) []string <span class="cov8" title="1">{
        keys := make(map[string]bool)
        list := []string{}
        for _, entry := range slice </span><span class="cov8" title="1">{
                if _, value := keys[entry]; !value </span><span class="cov8" title="1">{
                        keys[entry] = true
                        list = append(list, entry)
                }</span>
        }
        <span class="cov8" title="1">return list</span>
}

// Return Unique values in list
func CheckValueExistsInSlice(slice []string, role_test string) bool <span class="cov8" title="1">{
        for _, role := range slice </span><span class="cov8" title="1">{
                if role == role_test || role == "superuser" </span><span class="cov8" title="1">{
                        return true
                }</span>
        }
        <span class="cov8" title="1">return false</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
